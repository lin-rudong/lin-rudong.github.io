<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>全排列</title>
      <link href="/2018/10/13/%E5%85%A8%E6%8E%92%E5%88%97/"/>
      <url>/2018/10/13/%E5%85%A8%E6%8E%92%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h1 id="递归交换"><a href="#递归交换" class="headerlink" title="递归交换"></a>递归交换</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public static void permutation(int[] array)&#123;</span><br><span class="line">    permutation(array,0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void permutation(int[] array,int index)&#123;</span><br><span class="line">    if(index==array.length-1) &#123;</span><br><span class="line">        System.out.println(Arrays.toString(array));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //第2次交换保证permutation方法不会打乱array</span><br><span class="line">    for(int i=index;i&lt;array.length;i++)&#123;</span><br><span class="line">        swap(array,index,i);</span><br><span class="line">        permutation(array,index+1);</span><br><span class="line">        swap(array,index,i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void swap(int[] array,int i,int j)&#123;</span><br><span class="line">    int t=array[i];</span><br><span class="line">    array[i]=array[j];</span><br><span class="line">    array[j]=t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="字典排序"><a href="#字典排序" class="headerlink" title="字典排序"></a>字典排序</h1><ol><li>首先数组必须先自然排序，然后按照字典顺序递增，比如排序后的数组为array={1,2,3,4,5}，其递增如下。</li></ol><blockquote><p>1 2 3 4 5<br>1 2 3 5 4<br>1 2 4 3 5<br>1 2 4 5 3<br>1 2 5 3 4<br>1 2 5 4 3<br>1 3 2 4 5<br>…<br>1 3 5 4 2<br>1 4 2 3 5<br>…<br>5 4 3 2 1</p></blockquote><ol start="2"><li>数组从<code>12345</code>逐渐递增到<code>54321</code>。<ul><li>从<code>1 3 542</code>递增到<code>1 4 235</code>作为例子可以看到。</li><li>把<code>1 3 542</code>分为3部分，右边是已逆序化的<code>542</code>，中间是从右往左第一个非逆序化的<code>3</code>。</li><li>在<code>542</code>中取出刚好大于<code>3</code>的数字<code>4</code>，2个交换得到<code>1 4 532</code>。</li><li>将<code>532</code>反转得到自然排序得到<code>1 4 235</code>以实现整个数组的递增。</li></ul></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"> public static void permutation(int[] array)&#123;</span><br><span class="line">    //自然排序数组</span><br><span class="line">    Arrays.parallelSort(array);</span><br><span class="line">    System.out.println(Arrays.toString(array));</span><br><span class="line"></span><br><span class="line">    //循环递增</span><br><span class="line">    while(true)&#123;</span><br><span class="line">        //得到第一个非逆序化的索引，即中间部分。</span><br><span class="line">        int lessIndex = lessIndex(array);</span><br><span class="line"></span><br><span class="line">        //如果全部逆序化则退出。</span><br><span class="line">        if(lessIndex==-1) return;</span><br><span class="line"></span><br><span class="line">        //得到右边已逆序化中刚好大于array[lessIndex]的索引。</span><br><span class="line">        int greaterIndex = greaterIndex(array, lessIndex);</span><br><span class="line"></span><br><span class="line">        //递增</span><br><span class="line">        swap(array,lessIndex,greaterIndex);</span><br><span class="line">        reverse(array,lessIndex+1,array.length-1);</span><br><span class="line"></span><br><span class="line">        System.out.println(Arrays.toString(array));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">public static int lessIndex(int[] array)&#123;</span><br><span class="line">    int lessIndex=-1;</span><br><span class="line">    for(int i=array.length-2;i&gt;=0;i--)&#123;</span><br><span class="line">        if(array[i]&lt;array[i+1])&#123;</span><br><span class="line">            lessIndex=i;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return lessIndex;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static int greaterIndex(int[] array,int lessIndex)&#123;</span><br><span class="line">    int greaterIndex=-1;</span><br><span class="line">    for(int i=array.length-1;i&gt;lessIndex;i--)&#123;</span><br><span class="line">        if(array[i]&gt;array[lessIndex])&#123;</span><br><span class="line">            greaterIndex=i;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return greaterIndex;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void swap(int[] array,int i,int j)&#123;</span><br><span class="line">    int tmp=array[i];</span><br><span class="line">    array[i]=array[j];</span><br><span class="line">    array[j]=tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void reverse(int[] array,int start,int end)&#123;</span><br><span class="line">    for(int i=start,j=end;i&lt;j;i++,j--)&#123;</span><br><span class="line">        swap(array,i,j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>代理</title>
      <link href="/2018/10/12/%E4%BB%A3%E7%90%86/"/>
      <url>/2018/10/12/%E4%BB%A3%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="JDK代理"><a href="#JDK代理" class="headerlink" title="JDK代理"></a>JDK代理</h1><ol><li>JDK代理必须面向接口，因为最后Proxy.newProxyInstance生成的代理继承于Proxy，所以不能通过继承来实现代理。</li><li>Proxy代理的方法必须放在源类的接口里面，因为Proxy实现源类所有的接口。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">interface People&#123;</span><br><span class="line">    String toString();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Data</span><br><span class="line">class Student implements People&#123;</span><br><span class="line">    private String id;</span><br><span class="line">    private String name;</span><br><span class="line">    private int age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>Proxy属于动态代理，PeopleProxy是在运行时通过反射机制动态生成的代理类。</li><li>动态指的是在运行时可以根据所代理的类的不同生成不同的Proxy代理类，简单地说，不管被代理的类怎么变，Proxy代理类都可以不变应万变。</li><li>PeopleProxy通过私有字段InvocationHandler拦截器实现代理，它将通过反射机制拦截PeopleProxy的调用。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class PeopleProxy implements People&#123;</span><br><span class="line">    private InvocationHandler interceptor;</span><br><span class="line"></span><br><span class="line">    private static Method toStringMethod=People.getMethod(&quot;toString&quot;);</span><br><span class="line"></span><br><span class="line">    public String toString()&#123;</span><br><span class="line">        interceptor.invoke(this,toStringMethod,null);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="6"><li>origin是被代理的对象，即源类的实例，它作为拦截器的字段，而不直接包含在Proxy内。</li><li>invoke的参数，proxy是Proxy代理类，如果将proxy作为method.invoke的参数代替origin将出现死循环。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@AllArgsConstructor</span><br><span class="line">class Interceptor implements InvocationHandler &#123;</span><br><span class="line">    private Student origin;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;</span><br><span class="line">        System.out.println(&quot;before invocation...&quot;);</span><br><span class="line"></span><br><span class="line">        Object resultObject=method.invoke(origin,args);</span><br><span class="line"></span><br><span class="line">        return resultObject;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="8"><li>类的唯一是由类加载器加类全限名确定的，所以Proxy.newProxyInstance的第一参数是代理类的加载器，运行如下。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    Student student = new Student();</span><br><span class="line">    Interceptor interceptor = new Interceptor(student);</span><br><span class="line"></span><br><span class="line">    People people=(People)Proxy.newProxyInstance(Student.class.getClassLoader(),Student.class.getInterfaces(),interceptor);</span><br><span class="line"></span><br><span class="line">    System.out.println(people.toString());</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>before invocation…<br>Student(id=null, name=null, age=0)</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>设计模式</title>
      <link href="/2018/10/10/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
      <url>/2018/10/10/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">interface I&#123;</span><br><span class="line">    f();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class C&#123;</span><br><span class="line">    f();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Adapter extends C implements I&#123;&#125;</span><br><span class="line"></span><br><span class="line">public class Main&#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        Adapter adapter=new Adapter();</span><br><span class="line">        f(adapter);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void f(I i)&#123;</span><br><span class="line">        i.f();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>Hello World</title>
      <link href="/2018/10/09/hello-world/"/>
      <url>/2018/10/09/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>Effective Java</title>
      <link href="/2018/10/09/Effective-Java/"/>
      <url>/2018/10/09/Effective-Java/</url>
      
        <content type="html"><![CDATA[<h1 id="创建和销毁对象"><a href="#创建和销毁对象" class="headerlink" title="创建和销毁对象"></a>创建和销毁对象</h1><h2 id="考虑用静态工厂方法代替构造器"><a href="#考虑用静态工厂方法代替构造器" class="headerlink" title="考虑用静态工厂方法代替构造器"></a>考虑用静态工厂方法代替构造器</h2><p><strong>优点</strong></p><ol><li>有名称,能确切地描述正被返回的对象。</li><li>不必在每次调用的时候都创建一个新对象,可以控制实例实现Singleton或者使得不可变类能使用==操作符代替equals方法，从而提升性能。</li><li>可以返回原返回类型的任何子类型对象,可以隐藏底层的实现使API变得简洁。 <ul><li>静态工厂方法是服务提供者框架的基础，服务提供者框架包含3个组件：服务接口、提供者注册API和服务访问API,除此之外还有第4个可选的组件，服务提供者接口，默认是通过反射按照服务类名实例化。</li><li>对于JDBC来说，Connection是服务接口，DriverManager.registerDriver是提供者注册API，DriverManager.getConnection是服务访问API以及Driver就是服务提供者接口。</li></ul></li><li>创建参数化类型实例的时候，可以实现类型推导。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class HashMap&#123;</span><br><span class="line">    public static &lt;K,V&gt; HashMap&lt;K,V&gt; newInstance()&#123;</span><br><span class="line">        return new HashMap&lt;K,V&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Map&lt;String,List&lt;String&gt;&gt; map=HashMap.newIntstance();</span><br></pre></td></tr></table></figure><p><strong>缺点</strong></p><ol><li>类如果不含public或protected的构造器，就不能子类化。</li><li>静态工厂方法和其他静态方法没有区别，在API文档中无法明确标志出来。常用名称：<ul><li>valueOf/of</li><li>getInstance/newInstance</li><li>getType/newType</li></ul></li></ol><h2 id="遇到多个构造器参数时要考虑用构建器"><a href="#遇到多个构造器参数时要考虑用构建器" class="headerlink" title="遇到多个构造器参数时要考虑用构建器"></a>遇到多个构造器参数时要考虑用构建器</h2><p><strong>重叠构造器模式</strong></p><ol><li>当参数过多时，代码会变得难编写，并且较难阅读。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class Student&#123;</span><br><span class="line">    private String id;</span><br><span class="line">    private String name;</span><br><span class="line">    private int age;</span><br><span class="line"></span><br><span class="line">    public Student(String id)&#123;</span><br><span class="line">        this(id,null,0);</span><br><span class="line">    &#125;</span><br><span class="line">    public Student(String id,String name)&#123;</span><br><span class="line">        this(id,name,0);</span><br><span class="line">    &#125;</span><br><span class="line">    public Student(String id,String name,int age)&#123;</span><br><span class="line">        this.id=id;</span><br><span class="line">        this.name=name;</span><br><span class="line">        this.age=age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>JavaBeansm模式</strong></p><ol><li>通过setter设置参数，阅读容易，但构造过程被分割导致JavaBean在构造过程中可能处于不一致的状态。另外，JavaBeans模式也阻止了把类变成不可变的可能。</li></ol><p><strong>Builder模式</strong></p><ol><li>既保证了安全性，也有很好的可读性。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">public class Student&#123;</span><br><span class="line">    private final String id;</span><br><span class="line">    private final String name;</span><br><span class="line">    private final int age;</span><br><span class="line"></span><br><span class="line">    private Student(Builder builder)&#123;</span><br><span class="line">        id=builder.id;</span><br><span class="line">        name=builder.name;</span><br><span class="line">        age=builder.age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static class Builder&#123;</span><br><span class="line">        private String id;</span><br><span class="line">        private String name;</span><br><span class="line">        private int age;</span><br><span class="line"></span><br><span class="line">        public Builder id(String id)&#123;</span><br><span class="line">            this.id=id;return this;</span><br><span class="line">        &#125;</span><br><span class="line">        public Builder name(String name)&#123;</span><br><span class="line">            this.name=name;return this;</span><br><span class="line">        &#125;</span><br><span class="line">        public Builder age(int age)&#123;</span><br><span class="line">            this.age=age;return this;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public Student build()&#123;</span><br><span class="line">            return new Student(this);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Student student=new Student.Builder().id(&quot;id&quot;).name(&quot;name&quot;).age(1).build();</span><br></pre></td></tr></table></figure><h2 id="用私有构造器或者枚举类型强化Singleton属性"><a href="#用私有构造器或者枚举类型强化Singleton属性" class="headerlink" title="用私有构造器或者枚举类型强化Singleton属性"></a>用私有构造器或者枚举类型强化Singleton属性</h2><p><strong>饿汉模式</strong></p><ol><li>没有限制的话，可以通过反射调用私有构造器。</li><li>由于反序列化时会创建一个新的实例，所以可序列化的Singleton类的实例字段必须都是transient。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class Student&#123;</span><br><span class="line">    private static final Student INSTANCE=new Student();</span><br><span class="line"></span><br><span class="line">    private Student()&#123;&#125;</span><br><span class="line">    public static Student getInstance()&#123;return INSTANCE;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>单个元素的枚举类型</strong></p><ol><li>无偿地提供序列化机制，绝对防止多次实例化。</li><li>单元数的枚举类型是实现Singleton的最佳方法。</li></ol><h2 id="通过私有构造器强化不可实例化的能力"><a href="#通过私有构造器强化不可实例化的能力" class="headerlink" title="通过私有构造器强化不可实例化的能力"></a>通过私有构造器强化不可实例化的能力</h2><ol><li>私有构造器不仅不能实例化，还不可以继承，可以防止子类实例化。</li></ol><h2 id="避免创建不必要的对象"><a href="#避免创建不必要的对象" class="headerlink" title="避免创建不必要的对象"></a>避免创建不必要的对象</h2><ol><li>要优先使用基本类型而不是装箱基本类型，要当心无意识的自动装箱。</li><li>适配器除了后被对象之外，没有其他状态信息，所以不需要创建多个适配器实例。</li></ol><h2 id="消除过期的对象引用"><a href="#消除过期的对象引用" class="headerlink" title="消除过期的对象引用"></a>消除过期的对象引用</h2><ol><li>内存泄漏极端情况下会导致磁盘交换，甚至会导致OutOfMemoryError。</li><li>清空对象引用应该是一种例外，而不是一种规范行为。</li><li>只要类是自己管理内存，就应该警惕内存泄漏问题。</li><li>内存泄漏的另一个常见来源是缓存。如果回调没有显式取消注册，它们就会积聚。</li><li>内存泄漏的第三个常见来源是监听器和其他回调。</li></ol><h2 id="避免使用终结方法"><a href="#避免使用终结方法" class="headerlink" title="避免使用终结方法"></a>避免使用终结方法</h2><ol><li>终结方法finalizer通常是不可预测的，也是危险的，一般情况下是不必要的。终结方法的缺点在于不能保证会被及时地执行，而且根本那就补保证它们会被执行。</li><li>如果未被捕获的异常在终结过程中被抛出来，那么异常会被忽略，终结过程也会终止。</li><li>使用终结方法会有非常严重的性能损失。</li><li>普通对象通过本地方法委托给本地对象，当普通对象回收时，GC不会发现本地对等体，如果本地对等体不拥有关键资源，则可以用终结方法回收。</li><li>子类的终结方法不会自动调用超类的终结方法。</li></ol><h1 id="对于所有对象都通用的方法"><a href="#对于所有对象都通用的方法" class="headerlink" title="对于所有对象都通用的方法"></a>对于所有对象都通用的方法</h1><ol><li>Object的非final方法：equals、hashCode、toString、clone和finalize。</li></ol><h2 id="覆盖equals时请遵守通用约定"><a href="#覆盖equals时请遵守通用约定" class="headerlink" title="覆盖equals时请遵守通用约定"></a>覆盖equals时请遵守通用约定</h2><p><strong>满足以下任何一个条件可以不覆盖equals方法</strong></p><ol><li>类的每个实例本质上都是唯一的。</li><li>不关心类是否提供了“逻辑相等”的测试功能。</li><li>超类已经覆盖了equals，从超类继承过来的行为对于子类也是合适的。</li><li>类的私有的或是包级私有的，可以确定它的equals方法永远不会被调用。</li></ol><p><strong>equals方法实现了等价关系</strong></p><ol><li>自反性。对于任何非null的引用值x，x.quals(x)必须返回true。</li><li>对称性。对于任何非null的引用值x和y，当且仅当y.equals(x)返回true时，x.equals(y)必须返回true。</li><li>传递性。对于任何非null的引用值x、y和z，如果x.equals(y)返回true，并且y.equals(z)也返回true，那么x.equals(z)也必须返回true。</li><li>一致性。对于任何非null的引用值x和y，只要equals的比较操作在对象中所用的信息没有被修改，多次调用x.equals(y)就会一致地返回true，或者一致地返回false。</li><li>对于任何非null的引用值x，x.equals(null)必须返回false。</li></ol><p><strong>等价与继承不可兼得</strong></p><ol><li>无法在扩展可实例化的类的同时，既增加新的值组件，同时又保留equals约定。</li><li>getClass可以完全隔离超类和子类，可以解决等价关系，但会导致超类的一些方法不能用于子类，破坏了继承关系。instanceof反之。</li><li>可以用复合代替继承，需要扩展值组件的类可以包含原类，并提供一个获得原类的视图方法。还有就是不混用超类和子类也可以避免问题，这和getClass速途同归。</li><li>抽象类的子类中增加新的值组件，不会违反equals约定。</li></ol><p><strong>高质量equals</strong></p><ol><li>使用==操作符检查“参数是否是对象引用”。性能优化。</li><li>使用isntanceof操作符检查“参数是否为对象的类型或子类”。同时也检查了参数非空。</li><li>把参数转换成正确的类型。</li><li>检查参数中的关键字段是否与该对象中对应的相匹配。float和double需要对NaN和-0.0等进行特殊处理。</li><li>检查等价关系。<ul><li>覆盖equals时总要覆盖hashCode。</li><li>不要企图让equals方法过于智能。</li><li>不要将equals声明中的Object对象替换成其他的类型。重写时参数类型必须是一样的，返回类型可以是子类型。</li></ul></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class Student&#123;</span><br><span class="line">    private String id;</span><br><span class="line">    private String name;</span><br><span class="line">    private int age;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean equals(Object o)&#123;</span><br><span class="line">        if(o==this) return true;</span><br><span class="line">        if(!(o instanceof Student)) return false;</span><br><span class="line">        Student oStudent=(Student)o;</span><br><span class="line">        return Objects.equals(id,oStudent.id)</span><br><span class="line">            &amp;&amp; Objects.equals(name,oStudent.name)</span><br><span class="line">            &amp;&amp; age==oStudent.age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="覆盖equals时总要覆盖hashCode"><a href="#覆盖equals时总要覆盖hashCode" class="headerlink" title="覆盖equals时总要覆盖hashCode"></a>覆盖equals时总要覆盖hashCode</h2><p><strong>Object规范</strong></p><ol><li>默认情况下，Object.hashCoe返回对象的内存地址。</li><li>如果2个对象的根据equals(Object)比较是相等的，那么hashCode方法返回的整数结果必须相等。</li><li>如果2个对象的根据equals(Object)比较是不相等的，那么hashCode方法返回的整数结果是不确定的。<ul><li>散列函数会倾向于为不相等的对象产生不相等的散列码。</li><li>HashMap有一项优化，将散列码缓存起来，如果散列码不匹配，则对象不相等。对于HashMap来说，没有覆盖hashCode的类的所有键都是不相等的。</li></ul></li></ol><p><strong>散列码的计算</strong></p><ol><li>简单的散列函数实现：<ul><li>hash=非零常数值，比如17。</li><li>boolean，f?1:0。</li><li>byte char short int，(int)f。</li><li>long，(int)(f^(f&gt;&gt;&gt;32))。</li><li>float，Float.floatToIntBits(f)。</li><li>double，Double.doubleToLongBits(f)，再从long-&gt;int。</li><li>Object，f==null?0:f.hashCode()。</li><li>Array，把每一个元素当做单独的字段。</li><li>循环计算，hash=31*hash+每一个字段的计算值。</li><li>return hash。</li><li>测试。</li></ul></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class Studnet&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public int hashCode()&#123;</span><br><span class="line">        int hash=17;</span><br><span class="line">        hash=31*hash+id.hashCode();</span><br><span class="line">        hash=31*hash+name.hashCode();</span><br><span class="line">        hash=31*hash+age;</span><br><span class="line">        return hash;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>散列码的计算必须排除equals比较计算中没有用到的任何域。之所以选择31奇素数，如果是偶数的话，乘法溢出会导致信息丢失，因为与2相乘等价于移位运算。而使用素数只是习惯使然，并且31可以很容易用移位和减法代替乘法，31*i==(i&lt;&lt;5)-i。</li><li>如果是不可变类，计算散列码的开销也比较大，可以考虑把散列码缓存在对象内部。如果类的大多数对象会被用做散列键，可以在实例的时候计算散列码，否则可以延迟初始化散列码。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//缓存，延迟初始化。</span><br><span class="line">private volatile int hashCode;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public int hashCode()&#123;</span><br><span class="line">    int hash=hashCode;</span><br><span class="line">    if(hash==0)&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    return hash;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>不要试图从散列码计算中排除掉一个对象的关键部分来提高性能。</li></ol><h2 id="始终要覆盖toString"><a href="#始终要覆盖toString" class="headerlink" title="始终要覆盖toString"></a>始终要覆盖toString</h2><ol><li>默认显示“类名@hashCode”。</li><li>如果指定了格式，最好提供一个相匹配的静态工厂或者构造器，以便对象和字符串之间来回转换。Java类库的很多值类都采用了这种做法，包括BigInteger和BigDecimal和绝大多数的基本类型包装类。</li><li>指定了格式的缺点是必须始终如一地坚持。</li></ol><h2 id="谨慎地覆盖clone"><a href="#谨慎地覆盖clone" class="headerlink" title="谨慎地覆盖clone"></a>谨慎地覆盖clone</h2><ol><li>Object.clone是protected的，如果子类没有实现Cloneable，那么调用clone会抛出CloneNotSuportedException。</li><li>Object.clone是特殊的方法，它会通过反射将当前对象的所有字段进行浅拷贝。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class Student implements Cloneable&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public Student clone() throws CloneNotSupportedException &#123;</span><br><span class="line">        return (Student)super.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>永远不要让客户去做任何类库能够替客户完成的事情。</li><li>如果想要实现深拷贝，可以递归地调用clone方法。</li><li>clone架构与final对象不兼容，final对象无法深拷贝。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Student implements Cloneable&#123;</span><br><span class="line">    private String id=&quot;id&quot;;</span><br><span class="line">    private String name;</span><br><span class="line">    private int age;</span><br><span class="line">    private int[] scores;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Student clone() throws CloneNotSupportedException &#123;</span><br><span class="line">        Student clone = (Student) super.clone();</span><br><span class="line">        clone.scores=scores.clone();</span><br><span class="line">        return clone;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>拷贝构造器或拷贝工厂代替Cloneeable/clone</strong></p><ol><li>另一个实现对象拷贝地好办法是提供一个拷贝构造器或拷贝工厂，拷贝构造器或拷贝工厂唯一的参数类型和返回的类型相同。这2种方法都比Cloneable/clone方法更具有优势。<ul><li>不用实现Cloneable，不用修改clone为public和它的返回类型。</li><li>不会抛出受检异常。</li><li>支持final对象。</li><li>不用类型转换。</li><li>返回类型有更多选择。</li></ul></li></ol><h2 id="考虑实现Comparable接口"><a href="#考虑实现Comparable接口" class="headerlink" title="考虑实现Comparable接口"></a>考虑实现Comparable接口</h2><p><strong>约定</strong></p><ol><li>x.compareTo(y)==-y.compareTo(x)。</li><li>比较关系是可传递的。</li><li>强烈建议(x.compareTo(y)==0)==(x.equals(y))。</li></ol><p><strong>compareTo与equals</strong></p><ol><li>依赖比较关系的类包括有序集合类PriorityQueue、TreeSet和TreeMap，以及工具类Collections和Arrays。</li><li>与equals不同，在跨越不同类的时候，compareTo可以不做比较。</li><li>除却例外，x.compareTo(y)==0和x.equals(y)是一致的。例外如，BigDecimal(“1.0”)和BigDecimal(“1.00”)，通过equals比较是不相等的，而通过compareTo比较是相等的。</li><li>Comparable接口是参数化的，因此compareTo方法不必进行类型检查和类型转换。</li><li>浮点的比较用Float.compare和Double.compare。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public static int compare(double d1, double d2) &#123;</span><br><span class="line">        if (d1 &lt; d2) return -1; </span><br><span class="line">        if (d1 &gt; d2) return 1; </span><br><span class="line"></span><br><span class="line">        long thisBits    = Double.doubleToLongBits(d1);</span><br><span class="line">        long anotherBits = Double.doubleToLongBits(d2);</span><br><span class="line"></span><br><span class="line">        return thisBits == anotherBits ?  0 : (thisBits &lt; anotherBits ? -1 : 1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Student implements Comparable&lt;Student&gt;&#123;</span><br><span class="line">    private String id=&quot;id&quot;;</span><br><span class="line">    private String name;</span><br><span class="line">    private int age;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int compareTo(Student o) &#123;</span><br><span class="line">        int result=id.compareTo(o.id);</span><br><span class="line">        if (result!=0) return result;</span><br><span class="line">        </span><br><span class="line">        result=name.compareTo(o.name);</span><br><span class="line">        if (result!=0) return result;</span><br><span class="line"></span><br><span class="line">        return age-o.age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="类和接口"><a href="#类和接口" class="headerlink" title="类和接口"></a>类和接口</h1><h2 id="使类和成员的可访问性最小化"><a href="#使类和成员的可访问性最小化" class="headerlink" title="使类和成员的可访问性最小化"></a>使类和成员的可访问性最小化</h2><p><strong>封装</strong></p><ol><li>设计良好的模块会隐藏所有的实现细节，把API与实现清晰地隔离开来，这个概念称为信息隐藏或封装，是软件设计的基本原则之一。</li><li>封装可以有效地解除组成系统的各模块之间的耦合关系，使得这些模块可以独立地开发、测试、优化、使用、理解和修改。</li><li>顶层的类和接口只有2种可能的访问级别：包级私有的和公有的。默认是包级私有，作为包的实现的一部分，而公有则作为该包导出的API的一部分。</li><li>成员（字段、方法、嵌套类和嵌套接口）有4种可能的访问级别，按照可访问性递增顺序如下。<ul><li>私有的</li><li>包级私有的</li><li>受保护的（类导出的API）</li><li>公有的（类导出的API）</li></ul></li><li>子类重写的方法的访问级别不允许低于超类中访问级别，确保任何可使用超类的实例的地方也都可以使用子类的实例。</li></ol><p><strong>封装规则</strong></p><ol><li>尽可能地使每个类或者成员不被外界访问。</li><li>如果包级私有的顶层类或接口只是在某一个类的内部被用到，就应该考虑使它成为唯一使用它的那个类的私有嵌套类。</li><li>实例字段决不能是公有的。包含公有可变字段的类不是线程安全的。</li><li>静态字段也不能是公有的，有一种例外情况，假设常量是类抽象的一部分，可以通过public static final来暴露这些常量。很重要的一点是，这些常量要么包含基本类型的值，要么包含指向不可变对象的引用。</li><li>长度非0的数组总是可变的，所有，类具有公有的静态final数组字段，或者返回这种字段的访问方法，这几乎总是错误的，因为客户端能够修改数组中的内容。<ul><li>可以将数组变成私有的，并增加一个公有的不可变列表视图。</li><li>也可以将数组变成私有的，并添加一个公有方法访问数组的一个备份。</li></ul></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">private static final Student[] PRIVATE_STUDENTS=&#123;...&#125;;</span><br><span class="line">public static final List&lt;Student&gt; STUDENTS=Collections.unmodifiableList(Arrays.asList(PRIVATE_STUDENTS));</span><br></pre></td></tr></table></figure><h2 id="在公有类中使用访问方法而非公有域"><a href="#在公有类中使用访问方法而非公有域" class="headerlink" title="在公有类中使用访问方法而非公有域"></a>在公有类中使用访问方法而非公有域</h2><ol><li>公有类永远都不应该暴露可变的字段。</li><li>如果类是包级私有的，或者是私有的嵌套类，因为只是实现的一部分而没有导出API，直接暴露它的字段并没有本质错误。</li></ol><h2 id="使可变性最小化"><a href="#使可变性最小化" class="headerlink" title="使可变性最小化"></a>使可变性最小化</h2><ol><li>Java类库的不可变类：String、基本类型的包装类，BigInteger和BigDecimal。</li></ol><p><strong>不可变类的5条规则</strong></p><ol><li>不要提供任何会修改对象状态的方法。</li><li>保证类不会被扩展。防止子类破坏类的不可变行为，一般做法是使这个类成为final。</li><li>使所有的字段都是final的。</li><li>使所有的字段都成功私有的。</li><li>确保对于任何可变组件的互斥访问。如果类具有指向可变对象的字段，必须确保类的客户端无法获得这些对象的引用。</li></ol><p><strong>不可变</strong></p><ol><li>不可变类的如果需要进行运算，会创建并返回新的实例，这种模式是函数式的做法。与之相对应的是更常见的过程式的或者命令式的做法。</li><li>不可变对象本质上是线程安全的，它们不要求同步。不可变对象可以被自由地共享，影应该鼓励客户端尽可能地重用现有的实例，最简单的办法就是，对于频繁用到的值，为它们提供public static final常量。静态工厂可以进一步把频繁被请求的实例缓存起来。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public static final Complex ZERO=new Complex(0,0);</span><br></pre></td></tr></table></figure><ol start="3"><li>不仅可以共享不可变对象，也可以共享它们的内部信息。</li><li>不可变类真正唯一的缺点是，对于每个不同的值都需要一个单独的对象。解决办法是提供一个公有的可变套配类，比如String的StringBuilder和基本上已经废弃的StringBuffer。</li><li>让不可变的类变成final的另一种做法就是，让类的所有构造器都变成私有的或者包级私有的（在包内同样可以继承），并添加公有的静态工厂。</li><li>除非有令人信服的理由要使字段变成是非final的，否则要使每个字段都是final的，限制它的可变性。不要再构造器或者静态工厂之外再提供公有的初始化方法，除非有令人信服的理由必须这么做。不应该提供重新初始化方法，重用和共享不可兼得。</li></ol><h2 id="复合优先于继承"><a href="#复合优先于继承" class="headerlink" title="复合优先于继承"></a>复合优先于继承</h2><ol><li>在包的内部使用继承是非常安全的，因为子类和超类的实现都处在同一个程序员的控制之下。对于专门为了继承而设计并且具有很好的文档说明的类来说，也是非常安全的。然而，对普通的具体类进行跨越包边界的继承，则是非常危险的。</li><li>继承打破了封装性，子类依赖于其超类中特定功能的实现细节，超类的实现可能会随着发行版本的不同而有所变化，子类可能会遭到破坏因而，子类必须跟着其超类的更新而演变，除非超类是专门为了扩展而设计的，并且具有很好的文档说明。</li></ol><p><strong>继承可能破坏依赖</strong></p><ol><li>超类的方法之间可能存在依赖，如果重写了其中的方法，可能破坏依赖关系。</li><li>超类在后续的发行版本中可能获得新的方法，子类可能无意识地重写了这个方法，这也将破坏依赖关系。</li></ol><p><strong>复合</strong></p><ol><li>复合将现有类作为私有字段实现扩展。新类的实例方法都可以调用被包含的现有类实例的对应的方法，并返回它的结果，这称为转发，新类的方法称为转发方法。</li><li>修饰模式是指每一个包装类实例都把另一个被包装类实例包装起来以增加特性。</li><li>只有当子类真正是超类的子类型时，存在is-a关系时才适合用继承。如果在适合使用复合的地方使用了继承，则会不必要地暴露实现细节和限制在原始的实现上。继承还会把缺陷传播到子类。</li></ol><h2 id="要么为继承为设计，并提供文档说明，要么就禁止继承。"><a href="#要么为继承为设计，并提供文档说明，要么就禁止继承。" class="headerlink" title="要么为继承为设计，并提供文档说明，要么就禁止继承。"></a>要么为继承为设计，并提供文档说明，要么就禁止继承。</h2><ol><li>类的文档必须精确地描述重写每个方法所带来的影响。</li><li>对于为了继承而设计的类，唯一的测试方法就是编写子类。</li><li>构造器决不能调用可被重写的方法。这样会导致子类中重写版本的方法将会在子类的构造器运行之前就先被调用。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class People&#123;</span><br><span class="line">    public People()&#123;</span><br><span class="line">        f();</span><br><span class="line">    &#125;</span><br><span class="line">    public void f()&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Student extends People&#123;</span><br><span class="line">    private String name=&quot;name&quot;;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void f()&#123;</span><br><span class="line">        System.out.println(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Main &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Student student = new Student(); //打印 “null”</span><br><span class="line">        student.f(); //打印 “name&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>如果决定在一个为了继承而设计的类中实现Cloneable或Serializeble接口，应该意识到，clone和readObject方法在行为上非常类似于构造器，不能调用可重写的方法。</li></ol><h2 id="接口优于抽象类"><a href="#接口优于抽象类" class="headerlink" title="接口优于抽象类"></a>接口优于抽象类</h2><ol><li>JDK8开始，接口增加了默认方法和静态方法。</li><li>Java只允许单继承，而接口没有限制。</li><li>现有的类可以很容易被更新，以实现新的接口。</li><li>接口是定义mixin（混合类型）的理想选择。mixin类型表明提供了可供选择的行为，允许任选的功能可被混合到类型的主要功能中。比如Comparable允许类表明它的实例可以与其他的可互相比较的对象进行排序。</li><li>接口允许我们构造非层次结构的类型框架。</li></ol><p><strong>骨架实现与简单实现</strong></p><ol><li>骨架实现类比较简单，在接口中确定哪些方法是最为基本的，其他的方法可以根据它们来实现。这些基本方法将称为骨架实现类的抽象方法，而其他的方法提供具体的实现。骨架实现类是为了继承的目的而设计的。</li><li>简单实现，比如额AbstractMap和SimpleEntry，很像骨架实现，这是因为它实现了接口，并且是为了继承而设计的。但是区别在于它不是抽线的：它是最简单的可能的有效实现。你可以原封不动地使用，也可以看情况将它子类化。</li></ol><h2 id="接口只用于定义类型"><a href="#接口只用于定义类型" class="headerlink" title="接口只用于定义类型"></a>接口只用于定义类型</h2><ol><li>常量接口没有任何方法，只包含静态的final字段。常量接口模式是对接口的不良使用。类在内部使用某些常量，属于实现细节。</li><li>当类或接口的常量能看作枚举类型的成员，就应该用枚举类型。否则，应该使用不可实例化的工具类。</li></ol><h2 id="类层次优于标签类"><a href="#类层次优于标签类" class="headerlink" title="类层次优于标签类"></a>类层次优于标签类</h2><ol><li>标签类，实例有多种风格。缺点，多种风格实现混在一起，破坏了可读性，也让实例承担着属于其他风格不相关的字段。标签类过于冗长、容易出错，并且效率低下。</li></ol><h2 id="用函数对象表示策略"><a href="#用函数对象表示策略" class="headerlink" title="用函数对象表示策略"></a>用函数对象表示策略</h2><ol><li>函数对象可以作为参数，允许函数的调用者通过传入函数对象，来指定自己的行为。这称为策略模式。</li><li>Java中常用函数接口来实现函数对象，</li></ol><h2 id="优先考虑静态成员类"><a href="#优先考虑静态成员类" class="headerlink" title="优先考虑静态成员类"></a>优先考虑静态成员类</h2><ol><li>嵌套类存在的目的应该只是为它的外围类提供服务。嵌套类有4种：静态成员类、非静态成员类、匿名类和局部类。除了第1种外，其他3种都称为内部类,内部类不能有静态成员。</li><li>静态成员类是最简单的一种嵌套类，最好把它看作是普通的类，它可以访问外围类的所有成员，包括私有成员。静态成员类是外围类的一个静态成员，遵守同样的可访问性规则。</li><li>非静态成员类的每个实例都隐含着与外围类的一个外围实例相关联。在非静态成员类的实例方法内部，可以调用外围实例上的方法，或者利用修饰过的this获得外围实例的引用。在没有外围实例的情况下，是不可以创建非静态成员类的实例的。当非静态成员类的实例被创建时，它与外围类实例之间的关联关系就被建立起来，这会增加非静态成员类实例的开销。</li><li>如果声明成员类不要求访问外围实例，就要作为静态成员类。私有静态成员类的一种常见用法是用来代表外围类所代表的对象的组件。</li><li>匿名类在使用的时候同时声明和实例化。当且仅当匿名类出现在非静态的环境种，它才有外围实例。匿名类只有在声明的时候才可以实例化。<ul><li>匿名类的一种常见用法是动态地创建函数对象。</li><li>另一种常见用法是创建过程对象，比如Runnable、Thread或者TimerTask实例。</li><li>第三种常见用法是在静态工厂方法的内部。</li></ul></li><li>局部类是4种嵌套类中用得最少的类，和匿名类一样，只有当局部类是在非静态环境中定义的时候，才有外围实例。</li></ol><h1 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h1><h2 id="请不要在新代码中使用原生态类型"><a href="#请不要在新代码中使用原生态类型" class="headerlink" title="请不要在新代码中使用原生态类型"></a>请不要在新代码中使用原生态类型</h2><ol><li>数组的协变，数组之间和其元素类型有着一致的继承关系。如下，由于编译时只能确定引用的静态类型，fruits的静态类型是Fruit[]，所以可以编译通过。但是运行时可以知道数组的实际类型，所以会出现ArrayStoreException。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Fruit[] fruits=new Apple[10];</span><br><span class="line">fruits[0]=new Fruit();</span><br></pre></td></tr></table></figure><ol start="2"><li>所有泛型都是原生态类型的一个子类型，List<object>和List<string>之间没有继承关系，都是继承于List。</string></object></li><li>可以使用无限制的通配符类型<code>?</code>来代替原生态类型。原生态类型不安全，因为它可以包装所有的泛型子类型，然后擅自帮泛型添加元素，导致泛型在运行时可能会出现类型转换异常。List&lt;?&gt;用来代替List,表示不知道具体类型，所以不能限制存，只能存null，但不影响get。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Apple&gt; apples=new ArrayList&lt;Apple&gt;();</span><br><span class="line">List list=apples;</span><br><span class="line"></span><br><span class="line">//正常，因为泛型擦除，运行时只有List，但是泛型apples被破坏了。</span><br><span class="line">list.add(new Orange()); </span><br><span class="line">list.get(0); //正常，返回Object。</span><br><span class="line">apples.get(0); //运行错误，泛型在运行时会自动进行类型转换。</span><br></pre></td></tr></table></figure><ol start="4"><li>由于类型擦除，在类字面量中只能用原生态类型，而且instanceof操作只能用原生类类型或者?通配符类型可以进行，</li></ol><h2 id="消除非受检警告"><a href="#消除非受检警告" class="headerlink" title="消除非受检警告"></a>消除非受检警告</h2>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>WebSocket</title>
      <link href="/2018/10/08/WebSocket/"/>
      <url>/2018/10/08/WebSocket/</url>
      
        <content type="html"><![CDATA[<h2 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a>WebSocket</h2><p>实现服务器和浏览器全双工通信。<br>使用ws和wss作为URL协议，默认使用80和443端口，HTTP状态码是101。</p><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ol><li>更强的实时性。服务器可以主动向客户端发送数据。</li><li>保持连接状态。创建连接后可以省略部分状态信息。 </li><li>较少的控制开销。协议控制的数据包头部较小。</li><li>更好的压缩效果。</li><li>更好的二进制支持。</li><li>可以支持扩展。</li></ol><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>推送技术所用的技术是轮询，Comet采用长连接实现轮询。</p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>Spring实战</title>
      <link href="/2018/10/08/Spring%E5%AE%9E%E6%88%98/"/>
      <url>/2018/10/08/Spring%E5%AE%9E%E6%88%98/</url>
      
        <content type="html"><![CDATA[<h1 id="Spring实战"><a href="#Spring实战" class="headerlink" title="Spring实战"></a>Spring实战</h1><h2 id="ApplicationContext：基于BeanFactory"><a href="#ApplicationContext：基于BeanFactory" class="headerlink" title="ApplicationContext：基于BeanFactory"></a>ApplicationContext：基于BeanFactory</h2><h2 id="bean的生命周期"><a href="#bean的生命周期" class="headerlink" title="bean的生命周期"></a>bean的生命周期</h2><ol><li>实例化</li><li>注入和Aware接口</li><li>BeanPostProcessor接口</li><li>InitializingBean接口或init-method方法</li><li>BeanPostProcessor接口</li><li>准备就绪和一直驻留ApplicationContext</li><li>DisposableBean接口或destroy-method方法</li></ol><h2 id="装配Bean"><a href="#装配Bean" class="headerlink" title="装配Bean"></a>装配Bean</h2><ul><li>隐式组件扫描和自动装配<ul><li>@Configuration</li><li>@ComponentScan @ComponentScan() @ComponentScan(basePackages=) @ComponentScan(basePackages={}) @ComponentScan(basePackageClasses={}) [类坐在的包]</li><li>@Component @Component()</li><li>@Autowired @Autowired(required=true) [构造器 Setter方法 字段（安全管理必须允许通过反射访问私有字段）]</li></ul></li><li>显式Java<ul><li>@Configuration</li><li>@Bean @Bean(name=)</li></ul></li><li>显式XML</li></ul><h3 id="JavaConfig引用其他配置"><a href="#JavaConfig引用其他配置" class="headerlink" title="JavaConfig引用其他配置"></a>JavaConfig引用其他配置</h3><ul><li>@Import(Class) @Import({})</li><li>@ImportResource(“xml”)</li></ul><h3 id="XML引用其他配置"><a href="#XML引用其他配置" class="headerlink" title="XML引用其他配置"></a>XML引用其他配置</h3><h2 id="高级装配"><a href="#高级装配" class="headerlink" title="高级装配"></a>高级装配</h2><ul><li>运行时值注入<ul><li>占位符 “${}”<ul><li>@PropertySource()</li><li>@Value(占位符) 必须配置PropertySourcesPlaceholderConfigurer</li></ul></li><li>SpEL Spring表达式语言 “#{}” #{3.14} #{‘hello’} #{true}<ol><li>使用bean的ID id.field id.method() ?.[可null]</li><li>调用方法和访问字段 T()[类]</li><li>算术^、关系、逻辑and or not |、条件？：[可判断null true没有表示不变]</li><li>正则表达式匹配 matches</li><li>集合操作[] .?[]过滤 .^[] .$[] .![]投影</li></ol></li></ul></li></ul><h2 id="junit测试"><a href="#junit测试" class="headerlink" title="junit测试"></a>junit测试</h2><ul><li>@RunWith(SpringJUnit4ClassRunner.class) 自动创建应用上下文</li><li>ContextConfiguration(classes=) </li></ul><h2 id="AOP-切面-切点-增强"><a href="#AOP-切面-切点-增强" class="headerlink" title="AOP 切面=切点+增强"></a>AOP 切面=切点+增强</h2><ul><li>EnableAspectJAutoProxy</li><li>@Aspect</li><li>@Pointcut</li></ul><h3 id="切点-选择方法-连接点"><a href="#切点-选择方法-连接点" class="headerlink" title="切点 选择方法(连接点)"></a>切点 选择方法(连接点)</h3><ul><li>execution(<em> pkg.class.method(..)) &amp;&amp; within(pkg.</em>) &amp;&amp; !bean(‘id’)</li><li>execution(* pkg.class.method(int)) &amp;&amp; args(增强参数)</li><li>指示器<ol><li>args()</li><li>@args()</li><li>execution()</li><li>this()</li><li>target()</li><li>@target()</li><li>within()</li><li>@within()</li><li>@annotation</li></ol></li></ul><h4 id="增强"><a href="#增强" class="headerlink" title="增强"></a>增强</h4><ul><li>@Before()</li><li>@After()</li><li>@AfterReturning()</li><li>@AfterThrowing()</li><li>@Around()<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Around()</span><br><span class="line">method(ProceedingJoinPoint jp)&#123;</span><br><span class="line">    ...</span><br><span class="line">    jp.proceed();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Spring标记</title>
      <link href="/2018/10/08/Spring%E6%A0%87%E8%AE%B0/"/>
      <url>/2018/10/08/Spring%E6%A0%87%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="The-IoC-container"><a href="#The-IoC-container" class="headerlink" title="The IoC container"></a>The IoC container</h1><h2 id="Bean-scopes"><a href="#Bean-scopes" class="headerlink" title="Bean scopes"></a>Bean scopes</h2><h3 id="RequestScope"><a href="#RequestScope" class="headerlink" title="@RequestScope"></a>@RequestScope</h3><ul><li>the @RequestScope annotation can be used to assign a component to the request scope.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@RequestScope</span><br><span class="line">@Component</span><br><span class="line">public class LoginAction &#123;</span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="SessionScope"><a href="#SessionScope" class="headerlink" title="@SessionScope"></a>@SessionScope</h3><ul><li>the @SessionScope annotation can be used to assign a component to the session scope.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@SessionScope</span><br><span class="line">@Component</span><br><span class="line">public class UserPreferences &#123;</span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="ApplicationScope"><a href="#ApplicationScope" class="headerlink" title="@ApplicationScope"></a>@ApplicationScope</h3><ul><li>the @ApplicationScope annotation can be used to assign a component to the application scope.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@ApplicationScope</span><br><span class="line">@Component</span><br><span class="line">public class AppPreferences &#123;</span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="Annotation-based-container-configuration"><a href="#Annotation-based-container-configuration" class="headerlink" title="Annotation-based container configuration"></a>Annotation-based container configuration</h2><h3 id="Requried"><a href="#Requried" class="headerlink" title="@Requried"></a>@Requried</h3><ul><li>The @Required annotation applies to bean property setter methods, as in the following example:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class SimpleMovieLister &#123;</span><br><span class="line"></span><br><span class="line">    private MovieFinder movieFinder;</span><br><span class="line"></span><br><span class="line">    @Required</span><br><span class="line">    public void setMovieFinder(MovieFinder movieFinder) &#123;</span><br><span class="line">        this.movieFinder = movieFinder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="Autowired"><a href="#Autowired" class="headerlink" title="@Autowired"></a>@Autowired</h3><ul><li><p>You can apply the @Autowired annotation to constructors:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class MovieRecommender &#123;</span><br><span class="line"></span><br><span class="line">    private final CustomerPreferenceDao customerPreferenceDao;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    public MovieRecommender(CustomerPreferenceDao customerPreferenceDao) &#123;</span><br><span class="line">        this.customerPreferenceDao = customerPreferenceDao;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>As expected, you can also apply the @Autowired annotation to “traditional” setter methods:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class SimpleMovieLister &#123;</span><br><span class="line"></span><br><span class="line">    private MovieFinder movieFinder;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    public void setMovieFinder(MovieFinder movieFinder) &#123;</span><br><span class="line">        this.movieFinder = movieFinder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>You can also apply the annotation to methods with arbitrary names and/or multiple arguments:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class MovieRecommender &#123;</span><br><span class="line"></span><br><span class="line">    private MovieCatalog movieCatalog;</span><br><span class="line"></span><br><span class="line">    private CustomerPreferenceDao customerPreferenceDao;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    public void prepare(MovieCatalog movieCatalog,</span><br><span class="line">            CustomerPreferenceDao customerPreferenceDao) &#123;</span><br><span class="line">        this.movieCatalog = movieCatalog;</span><br><span class="line">        this.customerPreferenceDao = customerPreferenceDao;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>You can apply @Autowired to fields as well and even mix it with constructors:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class MovieRecommender &#123;</span><br><span class="line"></span><br><span class="line">    private final CustomerPreferenceDao customerPreferenceDao;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private MovieCatalog movieCatalog;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    public MovieRecommender(CustomerPreferenceDao customerPreferenceDao) &#123;</span><br><span class="line">        this.customerPreferenceDao = customerPreferenceDao;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>It is also possible to provide all beans of a particular type from the ApplicationContext by adding the annotation to a field or method that expects an array of that type:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class MovieRecommender &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private MovieCatalog[] movieCatalogs;</span><br><span class="line"></span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>The same applies for typed collections:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class MovieRecommender &#123;</span><br><span class="line"></span><br><span class="line">    private Set&lt;MovieCatalog&gt; movieCatalogs;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    public void setMovieCatalogs(Set&lt;MovieCatalog&gt; movieCatalogs) &#123;</span><br><span class="line">        this.movieCatalogs = movieCatalogs;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Even typed Maps can be autowired as long as the expected key type is String. The Map values will contain all beans of the expected type, and the keys will contain the corresponding bean names:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class MovieRecommender &#123;</span><br><span class="line"></span><br><span class="line">    private Map&lt;String, MovieCatalog&gt; movieCatalogs;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    public void setMovieCatalogs(Map&lt;String, MovieCatalog&gt; movieCatalogs) &#123;</span><br><span class="line">        this.movieCatalogs = movieCatalogs;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>By default, the autowiring fails whenever zero candidate beans are available; the default behavior is to treat annotated methods, constructors, and fields as indicating required dependencies. This behavior can be changed as demonstrated below.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class SimpleMovieLister &#123;</span><br><span class="line"></span><br><span class="line">    private MovieFinder movieFinder;</span><br><span class="line"></span><br><span class="line">    @Autowired(required = false)</span><br><span class="line">    public void setMovieFinder(MovieFinder movieFinder) &#123;</span><br><span class="line">        this.movieFinder = movieFinder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Alternatively, you may express the non-required nature of a particular dependency through Java 8’s java.util.Optional:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class SimpleMovieLister &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    public void setMovieFinder(Optional&lt;MovieFinder&gt; movieFinder) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>As of Spring Framework 5.0, you may also use an @Nullable annotation (of any kind in any package, e.g. javax.annotation.Nullable from JSR-305):</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class SimpleMovieLister &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    public void setMovieFinder(@Nullable MovieFinder movieFinder) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>You can also use @Autowired for interfaces that are well-known resolvable dependencies: BeanFactory, ApplicationContext, Environment, ResourceLoader, ApplicationEventPublisher, and MessageSource. These interfaces and their extended interfaces, such as ConfigurableApplicationContext or ResourcePatternResolver, are automatically resolved, with no special setup necessary.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class MovieRecommender &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private ApplicationContext context;</span><br><span class="line"></span><br><span class="line">    public MovieRecommender() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Let’s assume we have the following configuration that defines firstMovieCatalog as the primary MovieCatalog.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class MovieConfiguration &#123;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    @Primary</span><br><span class="line">    public MovieCatalog firstMovieCatalog() &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public MovieCatalog secondMovieCatalog() &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>With such configuration, the following MovieRecommender will be autowired with the firstMovieCatalog.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class MovieRecommender &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private MovieCatalog movieCatalog;</span><br><span class="line"></span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="QUalifier"><a href="#QUalifier" class="headerlink" title="@QUalifier"></a>@QUalifier</h3><ul><li><p>@Primary is an effective way to use autowiring by type with several instances when one primary candidate can be determined. When more control over the selection process is required, Spring’s @Qualifier annotation can be used. You can associate qualifier values with specific arguments, narrowing the set of type matches so that a specific bean is chosen for each argument. In the simplest case, this can be a plain descriptive value:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class MovieRecommender &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    @Qualifier(&quot;main&quot;)</span><br><span class="line">    private MovieCatalog movieCatalog;</span><br><span class="line"></span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>The @Qualifier annotation can also be specified on individual constructor arguments or method parameters:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class MovieRecommender &#123;</span><br><span class="line"></span><br><span class="line">    private MovieCatalog movieCatalog;</span><br><span class="line"></span><br><span class="line">    private CustomerPreferenceDao customerPreferenceDao;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    public void prepare(@Qualifier(&quot;main&quot;)MovieCatalog movieCatalog,</span><br><span class="line">            CustomerPreferenceDao customerPreferenceDao) &#123;</span><br><span class="line">        this.movieCatalog = movieCatalog;</span><br><span class="line">        this.customerPreferenceDao = customerPreferenceDao;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>You can create your own custom qualifier annotations. Simply define an annotation and provide the @Qualifier annotation within your definition:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Target(&#123;ElementType.FIELD, ElementType.PARAMETER&#125;)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Qualifier</span><br><span class="line">public @interface Genre &#123;</span><br><span class="line"></span><br><span class="line">    String value();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Then you can provide the custom qualifier on autowired fields and parameters:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class MovieRecommender &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    @Genre(&quot;Action&quot;)</span><br><span class="line">    private MovieCatalog actionCatalog;</span><br><span class="line"></span><br><span class="line">    private MovieCatalog comedyCatalog;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    public void setComedyCatalog(@Genre(&quot;Comedy&quot;) MovieCatalog comedyCatalog) &#123;</span><br><span class="line">        this.comedyCatalog = comedyCatalog;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>In some cases, it may be sufficient to use an annotation without a value. This may be useful when the annotation serves a more generic purpose and can be applied across several different types of dependencies. For example, you may provide an offline catalog that would be searched when no Internet connection is available. First define the simple annotation:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Target(&#123;ElementType.FIELD, ElementType.PARAMETER&#125;)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Qualifier</span><br><span class="line">public @interface Offline &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Then add the annotation to the field or property to be autowired:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class MovieRecommender &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    @Offline</span><br><span class="line">    private MovieCatalog offlineCatalog;</span><br><span class="line"></span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>You can also define custom qualifier annotations that accept named attributes in addition to or instead of the simple value attribute. If multiple attribute values are then specified on a field or parameter to be autowired, a bean definition must match all such attribute values to be considered an autowire candidate. As an example, consider the following annotation definition:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Target(&#123;ElementType.FIELD, ElementType.PARAMETER&#125;)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Qualifier</span><br><span class="line">public @interface MovieQualifier &#123;</span><br><span class="line"></span><br><span class="line">    String genre();</span><br><span class="line"></span><br><span class="line">    Format format();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>In this case Format is an enum:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public enum Format &#123;</span><br><span class="line">    VHS, DVD, BLURAY</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>The fields to be autowired are annotated with the custom qualifier and include values for both attributes: genre and format.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class MovieRecommender &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    @MovieQualifier(format=Format.VHS, genre=&quot;Action&quot;)</span><br><span class="line">    private MovieCatalog actionVhsCatalog;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    @MovieQualifier(format=Format.VHS, genre=&quot;Comedy&quot;)</span><br><span class="line">    private MovieCatalog comedyVhsCatalog;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    @MovieQualifier(format=Format.DVD, genre=&quot;Action&quot;)</span><br><span class="line">    private MovieCatalog actionDvdCatalog;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    @MovieQualifier(format=Format.BLURAY, genre=&quot;Comedy&quot;)</span><br><span class="line">    private MovieCatalog comedyBluRayCatalog;</span><br><span class="line"></span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="Resource"><a href="#Resource" class="headerlink" title="@Resource"></a>@Resource</h3><ul><li><p>@Resource takes a name attribute, and by default Spring interprets that value as the bean name to be injected. In other words, it follows by-name semantics, as demonstrated in this example:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class SimpleMovieLister &#123;</span><br><span class="line"></span><br><span class="line">    private MovieFinder movieFinder;</span><br><span class="line"></span><br><span class="line">    @Resource(name=&quot;myMovieFinder&quot;)</span><br><span class="line">    public void setMovieFinder(MovieFinder movieFinder) &#123;</span><br><span class="line">        this.movieFinder = movieFinder;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>If no name is specified explicitly, the default name is derived from the field name or setter method. In case of a field, it takes the field name; in case of a setter method, it takes the bean property name. So the following example is going to have the bean with name “movieFinder” injected into its setter method:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class SimpleMovieLister &#123;</span><br><span class="line"></span><br><span class="line">    private MovieFinder movieFinder;</span><br><span class="line"></span><br><span class="line">    @Resource</span><br><span class="line">    public void setMovieFinder(MovieFinder movieFinder) &#123;</span><br><span class="line">        this.movieFinder = movieFinder;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Thus in the following example, the customerPreferenceDao field first looks for a bean named customerPreferenceDao, then falls back to a primary type match for the type CustomerPreferenceDao. The “context” field is injected based on the known resolvable dependency type ApplicationContext.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class MovieRecommender &#123;</span><br><span class="line"></span><br><span class="line">    @Resource</span><br><span class="line">    private CustomerPreferenceDao customerPreferenceDao;</span><br><span class="line"></span><br><span class="line">    @Resource</span><br><span class="line">    private ApplicationContext context;</span><br><span class="line"></span><br><span class="line">    public MovieRecommender() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="PostConstruct-and-PreDestroy"><a href="#PostConstruct-and-PreDestroy" class="headerlink" title="@PostConstruct and @PreDestroy"></a>@PostConstruct and @PreDestroy</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class CachingMovieLister &#123;</span><br><span class="line"></span><br><span class="line">    @PostConstruct</span><br><span class="line">    public void populateMovieCache() &#123;</span><br><span class="line">        // populates the movie cache upon initialization...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @PreDestroy</span><br><span class="line">    public void clearMovieCache() &#123;</span><br><span class="line">        // clears the movie cache upon destruction...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Classpath-scanning-and-managed-components"><a href="#Classpath-scanning-and-managed-components" class="headerlink" title="Classpath scanning and managed components"></a>Classpath scanning and managed components</h2><h3 id="Automatically-detecting-classes-and-registering-bean-definitions"><a href="#Automatically-detecting-classes-and-registering-bean-definitions" class="headerlink" title="Automatically detecting classes and registering bean definitions"></a>Automatically detecting classes and registering bean definitions</h3><ul><li><p>Spring can automatically detect stereotyped classes and register corresponding BeanDefinitions with the ApplicationContext. For example, the following two classes are eligible for such autodetection:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class SimpleMovieLister &#123;</span><br><span class="line"></span><br><span class="line">    private MovieFinder movieFinder;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    public SimpleMovieLister(MovieFinder movieFinder) &#123;</span><br><span class="line">        this.movieFinder = movieFinder;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Repository</span><br><span class="line">public class JpaMovieFinder implements MovieFinder &#123;</span><br><span class="line">    // implementation elided for clarity</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>To autodetect these classes and register the corresponding beans, you need to add @ComponentScan to your @Configuration class, where the basePackages attribute is a common parent package for the two classes. (Alternatively, you can specify a comma/semicolon/space-separated list that includes the parent package of each class.)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@ComponentScan(basePackages = &quot;org.example&quot;)</span><br><span class="line">public class AppConfig  &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>The following example shows the configuration ignoring all @Repository annotations and using “stub” repositories instead.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@ComponentScan(basePackages = &quot;org.example&quot;,</span><br><span class="line">        includeFilters = @Filter(type = FilterType.REGEX, pattern = &quot;.*Stub.*Repository&quot;),</span><br><span class="line">        excludeFilters = @Filter(Repository.class))</span><br><span class="line">public class AppConfig &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="Defining-bean-metadata-within-components"><a href="#Defining-bean-metadata-within-components" class="headerlink" title="Defining bean metadata within components"></a>Defining bean metadata within components</h3><ul><li><p>Spring components can also contribute bean definition metadata to the container. You do this with the same @Bean annotation used to define bean metadata within @Configuration annotated classes. Here is a simple example:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class FactoryMethodComponent &#123;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    @Qualifier(&quot;public&quot;)</span><br><span class="line">    public TestBean publicInstance() &#123;</span><br><span class="line">        return new TestBean(&quot;publicInstance&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void doWork() &#123;</span><br><span class="line">        // Component method implementation omitted</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Autowired fields and methods are supported as previously discussed, with additional support for autowiring of @Bean methods:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class FactoryMethodComponent &#123;</span><br><span class="line"></span><br><span class="line">    private static int i;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    @Qualifier(&quot;public&quot;)</span><br><span class="line">    public TestBean publicInstance() &#123;</span><br><span class="line">        return new TestBean(&quot;publicInstance&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // use of a custom qualifier and autowiring of method parameters</span><br><span class="line">    @Bean</span><br><span class="line">    protected TestBean protectedInstance(</span><br><span class="line">            @Qualifier(&quot;public&quot;) TestBean spouse,</span><br><span class="line">            @Value(&quot;#&#123;privateInstance.age&#125;&quot;) String country) &#123;</span><br><span class="line">        TestBean tb = new TestBean(&quot;protectedInstance&quot;, 1);</span><br><span class="line">        tb.setSpouse(spouse);</span><br><span class="line">        tb.setCountry(country);</span><br><span class="line">        return tb;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    private TestBean privateInstance() &#123;</span><br><span class="line">        return new TestBean(&quot;privateInstance&quot;, i++);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    @RequestScope</span><br><span class="line">    public TestBean requestScopedInstance() &#123;</span><br><span class="line">        return new TestBean(&quot;requestScopedInstance&quot;, 3);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class FactoryMethodComponent &#123;</span><br><span class="line"></span><br><span class="line">    @Bean @Scope(&quot;prototype&quot;)</span><br><span class="line">    public TestBean prototypeInstance(InjectionPoint injectionPoint) &#123;</span><br><span class="line">        return new TestBean(&quot;prototypeInstance for &quot; + injectionPoint.getMember());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Naming-autodetected-components"><a href="#Naming-autodetected-components" class="headerlink" title="Naming autodetected components"></a>Naming autodetected components</h3><ul><li>If such an annotation contains no name value or for any other detected component (such as those discovered by custom filters), the default bean name generator returns the uncapitalized non-qualified class name. For example, if the following component classes were detected, the names would be myMovieLister and movieFinderImpl:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Service(&quot;myMovieLister&quot;)</span><br><span class="line">public class SimpleMovieLister &#123;</span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br><span class="line">@Repository</span><br><span class="line">public class MovieFinderImpl implements MovieFinder &#123;</span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="Providing-a-scope-for-autodetected-components"><a href="#Providing-a-scope-for-autodetected-components" class="headerlink" title="Providing a scope for autodetected components"></a>Providing a scope for autodetected components</h3><ul><li>As with Spring-managed components in general, the default and most common scope for autodetected components is singleton. However, sometimes you need a different scope which can be specified via the @Scope annotation. Simply provide the name of the scope within the annotation:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Scope(&quot;prototype&quot;)</span><br><span class="line">@Repository</span><br><span class="line">public class MovieFinderImpl implements MovieFinder &#123;</span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="Java-based-contiainer-configuration"><a href="#Java-based-contiainer-configuration" class="headerlink" title="Java-based contiainer configuration"></a>Java-based contiainer configuration</h2><h3 id="Bean"><a href="#Bean" class="headerlink" title="@Bean"></a>@Bean</h3><ul><li><p>To declare a bean, simply annotate a method with the @Bean annotation. You use this method to register a bean definition within an ApplicationContext of the type specified as the method’s return value. By default, the bean name will be the same as the method name. The following is a simple example of a @Bean method declaration:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class AppConfig &#123;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public TransferServiceImpl transferService() &#123;</span><br><span class="line">        return new TransferServiceImpl();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>You may also declare your @Bean method with an interface (or base class) return type:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class AppConfig &#123;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public TransferService transferService() &#123;</span><br><span class="line">        return new TransferServiceImpl();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>A @Bean annotated method can have an arbitrary number of parameters describing the dependencies required to build that bean. For instance if our TransferService requires an AccountRepository we can materialize that dependency via a method parameter:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class AppConfig &#123;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public TransferService transferService(AccountRepository accountRepository) &#123;</span><br><span class="line">        return new TransferServiceImpl(accountRepository);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>The @Bean annotation supports specifying arbitrary initialization and destruction callback methods, much like Spring XML’s init-method and destroy-method attributes on the bean element:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public class Foo &#123;</span><br><span class="line"></span><br><span class="line">    public void init() &#123;</span><br><span class="line">        // initialization logic</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Bar &#123;</span><br><span class="line"></span><br><span class="line">    public void cleanup() &#123;</span><br><span class="line">        // destruction logic</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Configuration</span><br><span class="line">public class AppConfig &#123;</span><br><span class="line"></span><br><span class="line">    @Bean(initMethod = &quot;init&quot;)</span><br><span class="line">    public Foo foo() &#123;</span><br><span class="line">        return new Foo();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean(destroyMethod = &quot;cleanup&quot;)</span><br><span class="line">    public Bar bar() &#123;</span><br><span class="line">        return new Bar();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Of course, in the case of Foo above, it would be equally as valid to call the init() method directly during construction:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class AppConfig &#123;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public Foo foo() &#123;</span><br><span class="line">        Foo foo = new Foo();</span><br><span class="line">        foo.init();</span><br><span class="line">        return foo;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>The default scope is singleton, but you can override this with the @Scope annotation:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class MyConfiguration &#123;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    @Scope(&quot;prototype&quot;)</span><br><span class="line">    public Encryptor encryptor() &#123;</span><br><span class="line">        // ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>If you port the scoped proxy example from the XML reference documentation (see preceding link) to our @Bean using Java, it would look like the following:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// an HTTP Session-scoped bean exposed as a proxy</span><br><span class="line">@Bean</span><br><span class="line">@SessionScope</span><br><span class="line">public UserPreferences userPreferences() &#123;</span><br><span class="line">    return new UserPreferences();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Bean</span><br><span class="line">public Service userService() &#123;</span><br><span class="line">    UserService service = new SimpleUserService();</span><br><span class="line">    // a reference to the proxied userPreferences bean</span><br><span class="line">    service.setUserPreferences(userPreferences());</span><br><span class="line">    return service;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>By default, configuration classes use a @Bean method’s name as the name of the resulting bean. This functionality can be overridden, however, with the name attribute.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class AppConfig &#123;</span><br><span class="line"></span><br><span class="line">    @Bean(name = &quot;myFoo&quot;)</span><br><span class="line">    public Foo foo() &#123;</span><br><span class="line">        return new Foo();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>As discussed in Naming beans, it is sometimes desirable to give a single bean multiple names, otherwise known as bean aliasing. The name attribute of the @Bean annotation accepts a String array for this purpose.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class AppConfig &#123;</span><br><span class="line"></span><br><span class="line">    @Bean(name = &#123; &quot;dataSource&quot;, &quot;subsystemA-dataSource&quot;, &quot;subsystemB-dataSource&quot; &#125;)</span><br><span class="line">    public DataSource dataSource() &#123;</span><br><span class="line">        // instantiate, configure and return DataSource bean...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>To add a description to a @Bean the @Description annotation can be used:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class AppConfig &#123;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    @Description(&quot;Provides a basic example of a bean&quot;)</span><br><span class="line">    public Foo foo() &#123;</span><br><span class="line">        return new Foo();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="Using-the-Configuration-annotation"><a href="#Using-the-Configuration-annotation" class="headerlink" title="Using the @Configuration annotation"></a>Using the @Configuration annotation</h3><ul><li>When @Beans have dependencies on one another, expressing that dependency is as simple as having one bean method call another:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class AppConfig &#123;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public Foo foo() &#123;</span><br><span class="line">        return new Foo(bar());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public Bar bar() &#123;</span><br><span class="line">        return new Bar();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="Composing-Java-based-configurations"><a href="#Composing-Java-based-configurations" class="headerlink" title="Composing Java-based configurations"></a>Composing Java-based configurations</h3><ul><li><p>Much as the <import> element is used within Spring XML files to aid in modularizing configurations, the @Import annotation allows for loading @Bean definitions from another configuration class:</import></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class ConfigA &#123;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public A a() &#123;</span><br><span class="line">        return new A();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Configuration</span><br><span class="line">@Import(ConfigA.class)</span><br><span class="line">public class ConfigB &#123;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public B b() &#123;</span><br><span class="line">        return new B();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Fortunately, solving this problem is simple. As we already discussed, @Bean method can have an arbitrary number of parameters describing the bean dependencies. Let’s consider a more real-world scenario with several @Configuration classes, each depending on beans declared in the others:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class ServiceConfig &#123;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public TransferService transferService(AccountRepository accountRepository) &#123;</span><br><span class="line">        return new TransferServiceImpl(accountRepository);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Configuration</span><br><span class="line">public class RepositoryConfig &#123;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public AccountRepository accountRepository(DataSource dataSource) &#123;</span><br><span class="line">        return new JdbcAccountRepository(dataSource);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Configuration</span><br><span class="line">@Import(&#123;ServiceConfig.class, RepositoryConfig.class&#125;)</span><br><span class="line">public class SystemTestConfig &#123;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public DataSource dataSource() &#123;</span><br><span class="line">        // return new DataSource</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    ApplicationContext ctx = new AnnotationConfigApplicationContext(SystemTestConfig.class);</span><br><span class="line">    // everything wires up across configuration classes...</span><br><span class="line">    TransferService transferService = ctx.getBean(TransferService.class);</span><br><span class="line">    transferService.transfer(100.00, &quot;A123&quot;, &quot;C456&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>In cases where this ambiguity is not acceptable and you wish to have direct navigation from within your IDE from one @Configuration class to another, consider autowiring the configuration classes themselves:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class ServiceConfig &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private RepositoryConfig repositoryConfig;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public TransferService transferService() &#123;</span><br><span class="line">        // navigate &apos;through&apos; the config class to the @Bean method!</span><br><span class="line">        return new TransferServiceImpl(repositoryConfig.accountRepository());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Spring事务机制</title>
      <link href="/2018/10/08/Spring%E4%BA%8B%E5%8A%A1%E6%9C%BA%E5%88%B6/"/>
      <url>/2018/10/08/Spring%E4%BA%8B%E5%8A%A1%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="事务机制"><a href="#事务机制" class="headerlink" title="事务机制"></a>事务机制</h1><h2 id="事务的传播行为"><a href="#事务的传播行为" class="headerlink" title="事务的传播行为"></a>事务的传播行为</h2><ul><li>事务方法被另一个事务方法调用时，事务如何传播。</li></ul><ol><li>propagation_required</li></ol><ul><li>如果当前事务存在，加入当前事务。如果不存在事务，开启一个新的事务。</li></ul><ol start="2"><li>propagation_supports</li></ol><ul><li>如果当前事务存在，加入当前事务。如果不存在事务，非事务地执行。</li></ul><ol start="3"><li>propagation_mandatory<br>如果当前事务存在，加入当前事务。如果不存在事务，抛出异常。</li><li>propagation_requires_new</li></ol><ul><li>总是开启一个新的事务，并挂起任何存在的事务。内外层事务互相独立。</li><li>使用JtaTransactionManager作为事务管理器。</li></ul><ol start="5"><li>propagatrion_not_supported</li></ol><ul><li>总是非事务地执行，并挂起任何存在的事务。</li><li>使用JtaTransactionManager作为事务管理器。</li></ul><ol start="6"><li>propagation_never</li></ol><ul><li>总是非事务地执行。如果存在事务，抛出异常。</li></ul><ol start="7"><li>propagation_nested</li></ol><ul><li>类似propation_required。</li><li>内层事务依赖于外层事务。外层事务会回滚内层事务的动作。内层事务不会回滚外层事务。</li></ul><h2 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h2><ul><li>事务受其他并发事务影响的程度。</li></ul><ol><li>isolation_default</li></ol><ul><li>使用后端数据库默认的隔离级别。</li></ul><ol start="2"><li>isolation_read_uncommitted</li></ol><ul><li>允许读取未提交的数据。最低的隔离级别。</li><li>会导致脏读、不可重复读和幻读。</li></ul><ol start="3"><li>isolation_read_committed</li></ol><ul><li>允许读取并发事务已经提交的数据。</li><li>可以防止脏读，会导致不可重复读和幻读。</li></ul><ol start="4"><li>isolation_repeatable_read</li></ol><ul><li>会导致幻读。</li></ul><ol start="5"><li>isolation_serializable</li></ol><ul><li>最高也是最慢的隔离级别。通过锁定事务相关的数据库表来实现。</li></ul><h3 id="并发事务引起的问题"><a href="#并发事务引起的问题" class="headerlink" title="并发事务引起的问题"></a>并发事务引起的问题</h3><ol><li>脏读</li></ol><ul><li>还没提交的修改被其他事务读取了。事务自身没有原子性。</li></ul><ol start="2"><li>不可重复读</li></ol><ul><li>同一事务的多次相同查询得到不同的数据。事务之间没有原子性。</li></ul><ol start="3"><li>幻读</li></ol><ul><li><p>同一事务的多次相同查询记录数不同。事务之间没有原子性。</p></li><li><p>不可重复读和幻读的区别</p><ol><li>不可重复读重点是修改，幻读重点是增加和删除。</li><li>本质原因都是事务之间没有原子性。从控制的角度来看，修改只需锁住满足条件的记录，而增加和删除需要锁住满足条件及其相近的记录。</li></ol></li></ul><h2 id="只读事务"><a href="#只读事务" class="headerlink" title="只读事务"></a>只读事务</h2><ul><li>只读事务可以让数据库进行一些特定的优化。</li></ul><h2 id="事务超时"><a href="#事务超时" class="headerlink" title="事务超时"></a>事务超时</h2><ul><li>在特定事件内事务没有执行完毕就会自动回滚。</li></ul><h2 id="回滚规则"><a href="#回滚规则" class="headerlink" title="回滚规则"></a>回滚规则</h2><ul><li>默认情况下，事务遇到运行期异常才会回滚，而遇到受查型异常不会回滚。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Transactiona(propagation=Propagation.REQUIRES_NEW,isolation=Isolation.READ_COMMITTED,noRollbackFor=&#123;UserAccountException.class&#125;,readOnly=true, timeout=3)</span><br><span class="line">public void f()&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>高性能MySQL</title>
      <link href="/2018/10/08/%E9%AB%98%E6%80%A7%E8%83%BDMySQL/"/>
      <url>/2018/10/08/%E9%AB%98%E6%80%A7%E8%83%BDMySQL/</url>
      
        <content type="html"><![CDATA[<h1 id="MySQL架构"><a href="#MySQL架构" class="headerlink" title="MySQL架构"></a>MySQL架构</h1><h2 id="MySQL逻辑架构"><a href="#MySQL逻辑架构" class="headerlink" title="MySQL逻辑架构"></a>MySQL逻辑架构</h2><ol><li>连接/线程处理</li><li>查询缓存 解析器 优化器</li><li>存储引擎（InnoDB会解析外键定义）</li></ol><h2 id="并发控制"><a href="#并发控制" class="headerlink" title="并发控制"></a>并发控制</h2><ol><li>读写锁，读锁是共享锁，写锁是排他锁。</li><li>锁粒度<ol><li>表锁</li><li>行级锁</li></ol><ul><li>最大程度地支持并发处理，同时也带来了最大的锁开销。</li></ul></li></ol><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><ul><li><p>一组原子性地SQL查询</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">start transaction;</span><br><span class="line">...</span><br><span class="line">commit;</span><br></pre></td></tr></table></figure></li><li><p>事务处理系统具备ACID，A原子性，C一致性，I隔离性，D持久性。</p><ol><li>原子性</li></ol><ul><li>要么全部提交，要么全部回滚。</li></ul><ol start="2"><li>一致性</li></ol><ul><li>从一个一致性状态转换到另一个一致性状态。</li></ul><ol start="3"><li>隔离性</li></ol><ul><li>一个事务的修改在最终提交以前，对其他事务是不可见的。</li></ul><ol start="4"><li>持久性</li></ol><ul><li>一旦事务提交，所做的修改就会永久保存到数据库中。</li></ul></li></ul><h3 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set transaction isolation level read committed;</span><br><span class="line">set session transaction isolation level read committed;</span><br></pre></td></tr></table></figure><ol><li>read uncommitted 未提交读</li></ol><ul><li>事务中的修改，即使没有提交，对其他事务也都是可见的。</li><li>脏读：事务可以读取未提交的数据。</li><li>性能比其他级别不会好太多，却缺乏很多好处，很少使用。</li></ul><ol start="2"><li>read committed 提交读</li></ol><ul><li>事务只能看见已经提交的事务的修改。</li><li>大多数数据库的默认隔离级别，MySQL不是。</li><li>未提交事务就可以读取数据，导致一个事务内2次读取数据可能是不一样的，即保证了可见性却没有原子性。</li></ul><ol start="3"><li>repeatable read 可重复读</li></ol><ul><li>保证同一个事务中多次读取同样的记录的结果是一致的。</li><li>MySQL默认隔离级别。</li><li>不能解决幻读。</li></ul><ol start="4"><li>serializable 可串行化</li></ol><ul><li>最高的隔离级别，强制事务串行执行。</li><li>每一行数据都加锁，导致大量的超时和锁争用问题，很少使用。</li></ul><h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><ul><li>InnoDB处理死锁的方法，将持有最少行级排他锁的事务进行回滚。</li></ul><h3 id="事务日志"><a href="#事务日志" class="headerlink" title="事务日志"></a>事务日志</h3><ul><li>顺序I/O，速度快。</li></ul><h3 id="MySQL中的事务"><a href="#MySQL中的事务" class="headerlink" title="MySQL中的事务"></a>MySQL中的事务</h3><ul><li>事务型存储引擎：InnoDB和NDB Cluster。</li></ul><ol><li>自动提交</li></ol><ul><li>MySQL默认模式，autocommit=1。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">set autocommit=0;</span><br><span class="line">...</span><br><span class="line">commit;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>集合</title>
      <link href="/2018/10/08/%E9%9B%86%E5%90%88/"/>
      <url>/2018/10/08/%E9%9B%86%E5%90%88/</url>
      
        <content type="html"><![CDATA[<h1 id="CopyOnWriteArraySet"><a href="#CopyOnWriteArraySet" class="headerlink" title="CopyOnWriteArraySet"></a>CopyOnWriteArraySet</h1><ul><li>写操作需要复制整个数组，写开销大。</li><li>适合大小保持很小，读操作远多于写操作，需要在遍历期间防止线程间的冲突。</li><li>线程安全的。</li><li>迭代器不支持写操作。</li><li>迭代器速度快，不会和其他线程冲突。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>JavaScript事件绑定与方法调用</title>
      <link href="/2018/10/08/JavaScript%E4%BA%8B%E4%BB%B6%E7%BB%91%E5%AE%9A%E4%B8%8E%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8/"/>
      <url>/2018/10/08/JavaScript%E4%BA%8B%E4%BB%B6%E7%BB%91%E5%AE%9A%E4%B8%8E%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="事件绑定"><a href="#事件绑定" class="headerlink" title="事件绑定"></a>事件绑定</h1><ol><li><p>事件与对象绑定，而不是与引用绑定，如果引用的对象改变，事件也会随着改变。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;h1&gt;h1&lt;/h1&gt;</span><br><span class="line">&lt;button&gt;button&lt;/button&gt;</span><br><span class="line"></span><br><span class="line">$(&apos;button&apos;).click(function()&#123;</span><br><span class="line">    alert(&apos;hello&apos;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">//remove方法会删除对象，然后重新创建，事件丢失。</span><br><span class="line">$(&apos;button&apos;).remove();</span><br><span class="line">$(&apos;h1&apos;).after(&apos;&lt;button&gt;button&lt;/button&gt;&apos;);</span><br><span class="line"></span><br><span class="line">//detach方法不会删除对象，所以调用after方法后也不会重新创建，事件不会丢失。</span><br></pre></td></tr></table></figure></li><li><p>方法调用和对象引用绑定，即动态分派，在运行时动态确定调用的方法。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Redis面试</title>
      <link href="/2018/10/08/Redis%E9%9D%A2%E8%AF%95/"/>
      <url>/2018/10/08/Redis%E9%9D%A2%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<h1 id="Redis作用"><a href="#Redis作用" class="headerlink" title="Redis作用"></a>Redis作用</h1><ol><li>缓存</li><li>list保存最新的数据 队列系统 lpush ltrim</li><li>zset保存权重最大的数据 优先级队列系统 zadd zrevrange zrank</li><li>set数据排重</li><li>清除过期数据</li><li>计数</li><li>subscribe/publish构建实时消息系统</li></ol>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>MyBatis面试</title>
      <link href="/2018/10/08/MyBatis%E9%9D%A2%E8%AF%95/"/>
      <url>/2018/10/08/MyBatis%E9%9D%A2%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<h1 id="MyBatis如何防止注入？"><a href="#MyBatis如何防止注入？" class="headerlink" title="MyBatis如何防止注入？"></a>MyBatis如何防止注入？</h1><ul><li>#{}是预编译处理，${}是字符串替换。</li><li>#{}可以防止SQL注入。</li></ul><h1 id="类的属性和表的字段不一样？"><a href="#类的属性和表的字段不一样？" class="headerlink" title="类的属性和表的字段不一样？"></a>类的属性和表的字段不一样？</h1><ol><li>定义字段的别名为属性名。</li><li>映射属性名和字段名。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;resultMap id=&quot;&quot; type=&quot;&quot;&gt;</span><br><span class="line">    &lt;id property=&quot;&quot; column=&quot;&quot;/&gt;</span><br><span class="line">    &lt;result property=&quot;&quot; column=&quot;&quot;/&gt;</span><br><span class="line">&lt;/resultMap&gt;</span><br></pre></td></tr></table></figure></li></ol><h1 id="获取自动生成的键值？"><a href="#获取自动生成的键值？" class="headerlink" title="获取自动生成的键值？"></a>获取自动生成的键值？</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;insert id=&quot;&quot; parameterType=&quot;&quot;&gt;</span><br><span class="line">    &lt;selectKey keyProperty=&quot;id&quot; order=&quot;AFTER&quot; resultType=&quot;int&quot;&gt;</span><br><span class="line">        select last_insert_id()</span><br><span class="line">    &lt;/selectKey&gt;</span><br><span class="line">    insert into...</span><br><span class="line">&lt;/insert&gt;</span><br></pre></td></tr></table></figure><h1 id="在mapper中传递多个参数？"><a href="#在mapper中传递多个参数？" class="headerlink" title="在mapper中传递多个参数？"></a>在mapper中传递多个参数？</h1><ol><li>使用占位符<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;select id=&quot;&quot; resultMap=&quot;&quot;&gt;</span><br><span class="line">    select * from t where id=#&#123;0&#125; and name=#&#123;1&#125;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public T f(@param(&quot;id&quot;) Integer id,@param(&quot;name&quot;) String name);</span><br><span class="line"></span><br><span class="line">&lt;select id=&quot;f&quot; resultType=&quot;T&quot;&gt;</span><br><span class="line">    select * from t where id=#&#123;id&#125; and name=#&#123;name&#125;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure><ol start="2"><li>使用Map集合参数</li><li>使用Bean参数</li></ol><h1 id="动态标签？"><a href="#动态标签？" class="headerlink" title="动态标签？"></a>动态标签？</h1><ul><li>在Xml映射文件内，已标签的形式编写动态SQL，完成逻辑判断和动态拼接SQL的功能。</li><li>9种标签：<ol><li>trim</li><li>where</li><li>set</li><li>foreach</li><li>if</li><li>choose</li><li>when</li><li>otherwise</li><li>bind</li></ol></li><li>原理：使用OGNL（Object-Graph Navigation Languag）计算表达式，根据表达式的值动态拼接SQL。</li></ul><h1 id="MyBatis不同的Xml映射文件中，id重复？"><a href="#MyBatis不同的Xml映射文件中，id重复？" class="headerlink" title="MyBatis不同的Xml映射文件中，id重复？"></a>MyBatis不同的Xml映射文件中，id重复？</h1><ul><li>定位=namespace+id</li><li>如果有namespace可以重复，如果没有配置namespace会导致覆盖。</li></ul><h1 id="MyBatis是半自动的ORM映射工具？"><a href="#MyBatis是半自动的ORM映射工具？" class="headerlink" title="MyBatis是半自动的ORM映射工具？"></a>MyBatis是半自动的ORM映射工具？</h1><ul><li>Hibernate是全自动ORM映射工具，查询关联对象或关联集合对象时，可以根据对象关系模型直接获取。</li><li>MyBatis则需要手动编写SQL。</li></ul><h1 id="一个Xml映射文件，需要一个Dao接口对应？Dao接口的方法能重载吗？"><a href="#一个Xml映射文件，需要一个Dao接口对应？Dao接口的方法能重载吗？" class="headerlink" title="一个Xml映射文件，需要一个Dao接口对应？Dao接口的方法能重载吗？"></a>一个Xml映射文件，需要一个Dao接口对应？Dao接口的方法能重载吗？</h1><ul><li>Dao接口，即Mapper接口，接口的全限名就是namespace，接口的方法名就是id，接口的参数就是传递给SQL的参数。</li><li>Mapper接口没有实现类，当调用接口方法时，会定位一个MappedStatement。</li><li>Dao接口里的方法不能重载。</li><li>Dao接口的工作原理：JDK动态代理，MyBatis运行时会使用JDK动态代理为Dao接口生成代理proxy对象，代理对象proxy会拦截接口方法，转而执行MappedStatement所代表的SQL。</li></ul><h1 id="接口绑定的实现方式？"><a href="#接口绑定的实现方式？" class="headerlink" title="接口绑定的实现方式？"></a>接口绑定的实现方式？</h1><ol><li>注解绑定</li><li>Xml绑定</li></ol><h1 id="MyBatis是如何分页的？分页插件的原理是什么？"><a href="#MyBatis是如何分页的？分页插件的原理是什么？" class="headerlink" title="MyBatis是如何分页的？分页插件的原理是什么？"></a>MyBatis是如何分页的？分页插件的原理是什么？</h1><ul><li>MyBatis使用RowBounds对象进行分页，RowBounds是针对ResultSet执行的内存分页，而非物理分页。</li><li>可以用SQL实现物理分页，也可以使用分页插件完成物理分页。</li><li>分页插件的基本原理:插件的拦截方法内拦截待执行的SQL，然后重写SQL，添加物理分页语句和物理分页参数。</li></ul><h1 id="MyBatis插件运行原理？"><a href="#MyBatis插件运行原理？" class="headerlink" title="MyBatis插件运行原理？"></a>MyBatis插件运行原理？</h1><ul><li>MyBatis仅可以编写针对ParameterHandler、ResultSetHandler、StatementHandler和Executor这4种接口的插件，MyBatis使用JDK的动态代理，为需要拦截的接口生成代理对象以实现接口方法拦截功能。</li></ul><h1 id="MyBatis延迟加载的实现原理？"><a href="#MyBatis延迟加载的实现原理？" class="headerlink" title="MyBatis延迟加载的实现原理？"></a>MyBatis延迟加载的实现原理？</h1><ul><li>MyBatis仅支持association和collection关联集合对象的延迟加载。</li><li>原理：使用cglib创建目标对象的代理对象，当调用目标方法时，进入拦截器方法，如果当拦截器方法发现字段是null值，就会单独发送事先保存好的查询，然后保存到对象的字段中。</li></ul><h1 id="MyBatis的Executor执行器？"><a href="#MyBatis的Executor执行器？" class="headerlink" title="MyBatis的Executor执行器？"></a>MyBatis的Executor执行器？</h1><ul><li>SimpleExecutor、ReuseExecutor和BatchExecutor</li></ul><ol><li>SimpleExecutor：每次执行一次update或select，开启一个Statement对象，用完立刻关闭Statement对象。</li><li>ReuseExecutor：执行update或select，以SQL作为key查找Statement对象，存在直接使用，不存在则创建，不关闭Statement对象而是在Map&lt;String,Statement&gt;内重复使用。</li><li>BatchExecutor：执行update（JDBC批处理不支持select），将sql添加到批处理中，等待统一执行executeBatch()。</li></ol>]]></content>
      
      
      <categories>
          
          <category> MyBatis </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>JDK8新特性</title>
      <link href="/2018/10/07/JDK8%E6%96%B0%E7%89%B9%E6%80%A7/"/>
      <url>/2018/10/07/JDK8%E6%96%B0%E7%89%B9%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<h1 id="Java语言"><a href="#Java语言" class="headerlink" title="Java语言"></a>Java语言</h1><h2 id="Lambda表达式与Functional接口"><a href="#Lambda表达式与Functional接口" class="headerlink" title="Lambda表达式与Functional接口"></a>Lambda表达式与Functional接口</h2><ul><li>访问局部变量时，会将变量隐式转换成常量。</li><li>接口的静态方法和默认方法不影响函数式接口。</li><li>@<em>FunctionalInterface</em>。</li></ul><h2 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h2><ul><li>方法引用用来支持Lambda简写。</li><li>构造器引用<em>T::new</em>，构造器本质上静态方法。</li><li>静态方法引用<em>T::staticMethod</em>。</li><li>类的任意对象的方法引用<em>T::Method</em>，第一个参数是对象。</li><li>对象的方法引用<em>O::Method</em>。</li></ul><h2 id="接口的静态方法与默认方法"><a href="#接口的静态方法与默认方法" class="headerlink" title="接口的静态方法与默认方法"></a>接口的静态方法与默认方法</h2><ul><li>接口的字段是<em>public static final</em>,接口的方法是<em>public</em>。</li><li>接口的方法新增<em>static</em>与<em>default</em>。</li></ul><h2 id="类型推测机制"><a href="#类型推测机制" class="headerlink" title="类型推测机制"></a>类型推测机制</h2><ul><li>List<t> list=new List&lt;&gt;();</t></li></ul><h2 id="重复注解"><a href="#重复注解" class="headerlink" title="重复注解"></a>重复注解</h2><ul><li>@R<em>epeatable</em>。</li></ul><h2 id="注解类型"><a href="#注解类型" class="headerlink" title="注解类型"></a>注解类型</h2><ul><li>field、constructor、method、parameter、local_variable、package和type(类、接口和enum)。</li></ul><h1 id="Java编译器"><a href="#Java编译器" class="headerlink" title="Java编译器"></a>Java编译器</h1><h2 id="参数名字"><a href="#参数名字" class="headerlink" title="参数名字"></a>参数名字</h2><ul><li>参数名字保存在Java字节码中，<em>javac -parameters</em>。</li></ul><h2 id="Java类库"><a href="#Java类库" class="headerlink" title="Java类库"></a>Java类库</h2><h2 id="Stream"><a href="#Stream" class="headerlink" title="Stream"></a>Stream</h2><ul><li>集合函数式编程</li></ul><h2 id="并行数组"><a href="#并行数组" class="headerlink" title="并行数组"></a>并行数组</h2><ul><li>数组并行处理。</li></ul><h2 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h2><ul><li>ConcurrentHashMap。<ol><li><em>取消段segments</em>，采用transient volatile hashEntry保存数据，实现<em>对每一行数据进行加锁</em>代替原来的段加锁，减少并发冲突。</li><li>数据结构改为<em>数组+单向链表+红黑树</em>。</li></ol></li><li>ForkJoinPool支持共有资源池。</li><li>容量锁StampedLock，代替ReadWriteLock。</li><li>atomic增加：<ol><li>DoubleAccumulator</li><li>DoubleAdder</li><li>LongAccumulator</li><li>LongAdder</li></ol></li></ul><h2 id="Optional"><a href="#Optional" class="headerlink" title="Optional"></a>Optional</h2><h2 id="Date-Time-API"><a href="#Date-Time-API" class="headerlink" title="Date/Time API"></a>Date/Time API</h2><ol><li>Clock</li></ol><ul><li>替换System.currentTimeMillis()和TimeZone.getDefault()。</li></ul><ol start="2"><li>LocaleDate LocalTime LocalDateTime</li></ol><ul><li>无时区。</li></ul><ol start="3"><li>ZonedDateTIme</li><li>Duration</li></ol><ul><li>时间差</li></ul><h2 id="JS引擎"><a href="#JS引擎" class="headerlink" title="JS引擎"></a>JS引擎</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ScriptEngineManager manager = new ScriptEngineManager();</span><br><span class="line">ScriptEngine engine = manager.getEngineByName( &quot;JavaScript&quot; );</span><br><span class="line">engine.eval( &quot;function f() &#123; return 1; &#125;; f() + 1;&quot; );</span><br></pre></td></tr></table></figure><h2 id="Base64"><a href="#Base64" class="headerlink" title="Base64"></a>Base64</h2><ul><li>编码。</li></ul><h1 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h1><h2 id="元空间Metaspace代替永久代PermGen"><a href="#元空间Metaspace代替永久代PermGen" class="headerlink" title="元空间Metaspace代替永久代PermGen"></a>元空间Metaspace代替永久代PermGen</h2><ul><li>字符串和静态变量转移到Java堆。</li><li>元空间使用本地内存而不在JVM中，元空间受本地内存限制，可以用-XX:MetaspaceSize -XX:MaxMetaspaceSize限制。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JDK8 </tag>
            
        </tags>
      
    </entry>
    
  
  
    
    <entry>
      <title></title>
      <link href="/baidu_verify_ysuwxPEgQM.html"/>
      <url>/baidu_verify_ysuwxPEgQM.html</url>
      
        <content type="html"><![CDATA[ysuwxPEgQM]]></content>
      
    </entry>
    
    <entry>
      <title></title>
      <link href="/googlea5bf63acdc3dbd82.html"/>
      <url>/googlea5bf63acdc3dbd82.html</url>
      
        <content type="html"><![CDATA[google-site-verification: googlea5bf63acdc3dbd82.html]]></content>
      
    </entry>
    
    <entry>
      <title>categories</title>
      <link href="/categories/index.html"/>
      <url>/categories/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    <entry>
      <title>tags</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
  
</search>
