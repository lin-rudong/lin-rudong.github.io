<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>数据结构</title>
      <link href="/2018/10/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
      <url>/2018/10/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h1 id="2-3树"><a href="#2-3树" class="headerlink" title="2-3树"></a>2-3树</h1><ol><li>结点可以是2、3结点。</li><li>所有叶子结点在同一层。</li></ol><h1 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h1><ol><li>通过2叉树实现2-3树。</li><li>红链接均为左链接，红链接连接的2个结点组合成3结点，左链接简化实现。</li><li>没有结点同时和2条红链接相连，保证只有2结点和3结点。</li><li>树是完美黑色平衡的，即任何空链接到根节点的路径上的黑链接数量相同。</li></ol><h1 id="B树（m阶）"><a href="#B树（m阶）" class="headerlink" title="B树（m阶）"></a>B树（m阶）</h1><ol><li>根节点至少有2结点。</li><li>所有叶子结点和中间结点都是k结点，m/2&lt;=k&lt;=m，叶子结点必须包含k-1元素保证是k结点。</li><li>所有叶子结点在同一层。</li><li>每个结点中的元素都从小到大排列。</li><li>用处：减少树的深度，可以减少磁盘IO。</li></ol><h1 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h1><ol><li>扩展B树。</li><li>数据保存在叶子结点，其他结点用来索引。中间结点都是k结点，m/2&lt;=k&lt;=m，不同的是，k结点包含k个元素，分别索引k个孩子，表示孩子最大或者最小的元素。</li><li>叶子结点按顺序链接。</li><li>用处：<ul><li>用索引的模式查找，同样大小的磁盘页可以容纳更多的结点元素，进一步减少磁盘IO。</li><li>每次都要查找到叶子结点，性能稳定。</li><li>范围查询方便。</li></ul></li></ol>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>加密算法</title>
      <link href="/2018/10/28/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/"/>
      <url>/2018/10/28/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="对称加密"><a href="#对称加密" class="headerlink" title="对称加密"></a>对称加密</h1><ol><li>DES、3DES、AES、RC4、RC5、RC6。</li></ol><h1 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h1><ol><li>RSA、DSA、ECC。</li></ol><h1 id="Hash算法"><a href="#Hash算法" class="headerlink" title="Hash算法"></a>Hash算法</h1><ol><li>单向算法。</li><li>MD2、MD4、MD5、HAVAL、SHA。</li></ol>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>Linux常用命令</title>
      <link href="/2018/10/27/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
      <url>/2018/10/27/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h1 id="进程类"><a href="#进程类" class="headerlink" title="进程类"></a>进程类</h1><h2 id="top"><a href="#top" class="headerlink" title="top"></a>top</h2><ol><li>实时显示系统中各个进程的资源占用状态，类似于Windows的任务管理器。</li></ol><h2 id="pmap"><a href="#pmap" class="headerlink" title="pmap"></a>pmap</h2><ol><li>查看进程的内存占用情况。</li><li>pmap 1</li></ol><h2 id="ps"><a href="#ps" class="headerlink" title="ps"></a>ps</h2><ol><li>显示进程的相关信息。</li></ol><h1 id="文件类"><a href="#文件类" class="headerlink" title="文件类"></a>文件类</h1><h2 id="grep-Global-Regular-Expression-Print"><a href="#grep-Global-Regular-Expression-Print" class="headerlink" title="grep Global Regular Expression Print"></a>grep Global Regular Expression Print</h2><ol><li>文件中搜索特定的内容，并将含有这些内容的行标准输出。</li><li>grep ‘[a-z]\{2\}’ file</li></ol><h2 id="awk"><a href="#awk" class="headerlink" title="awk"></a>awk</h2><ol><li>把文件逐行的读入，以空位或者tab为默认分隔符将每行切片，切开的部分再进行各种分析处理。</li><li>awk -F ‘:’ ‘{print $1}’ file <ul><li>以:作为分隔符切片，输出每行的第一个切片。</li></ul></li><li>awk ‘{printf(“first:%05d\n”,$1)}’ file<ul><li>可以执行编程语句，有内置变量。</li></ul></li></ol><h2 id="cut"><a href="#cut" class="headerlink" title="cut"></a>cut</h2><ol><li>处理单位为行。</li><li>-b -nb 以字节剪切，n表示不要分割多字节字符。</li><li>-c 以字符剪切。</li><li>-f [-d] 以字段剪切，默认是tab分割字段，d可以自定义分割字符。<br> cut -d ‘:’ -f 2,3 file</li></ol><h2 id="sed-stream-edit"><a href="#sed-stream-edit" class="headerlink" title="sed stream edit"></a>sed stream edit</h2><ol><li>sed ‘/^$/d’ file<ul><li>删除空白行</li></ul></li><li>sed ‘2d’ file<ul><li>删除第2行</li></ul></li><li>sed ‘/^test/‘d file<ul><li>删除开头是test的行</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>大型网站技术架构</title>
      <link href="/2018/10/26/%E5%A4%A7%E5%9E%8B%E7%BD%91%E7%AB%99%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84/"/>
      <url>/2018/10/26/%E5%A4%A7%E5%9E%8B%E7%BD%91%E7%AB%99%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><h2 id="大型网站架构演化"><a href="#大型网站架构演化" class="headerlink" title="大型网站架构演化"></a>大型网站架构演化</h2><h3 id="大型网站软件系统的特点"><a href="#大型网站软件系统的特点" class="headerlink" title="大型网站软件系统的特点"></a>大型网站软件系统的特点</h3><ol><li>高并发，大流量。</li><li>高可用。不间断服务。</li><li>海量数据。</li><li>用户分布广泛，网络情况复杂。</li><li>安全环境恶劣。</li><li>需求快速变更，发布频繁。</li><li>渐进式发展。</li></ol><h3 id="大型网站架构演化发展历程"><a href="#大型网站架构演化发展历程" class="headerlink" title="大型网站架构演化发展历程"></a>大型网站架构演化发展历程</h3><ol><li>初始阶段的网络架构。应用程序、数据库、文件都在同一台应用服务器上。</li><li>应用服务和数据服务分离。3台服务器，应用服务器、数据库服务器和文件服务器。<ul><li>应用服务器需要处理大量的业务逻辑，需要更快CPU资源。</li><li>数据库服务器需要快速磁盘检索和数据缓存，需要更快硬盘和更大内存。</li><li>文件服务器需要存储大量用户上传的文件，需要更大的硬盘。</li></ul></li><li>使用缓存改善网站性能。<ul><li>数据库压力太大导致访问延迟。</li><li>80%的业务访问集中在20%的数据上。</li><li>2种缓存，应用服务器上的本地缓存和分布式缓存服务器的远程缓存。本地缓存速度更快一些，但受内存限制。远程分布式缓存可以使用集群的方式，部署大内存的服务器作为专门的缓存服务器。</li></ul></li><li>使用应用服务器集群改善网站的并发处理能力。<ul><li>使用集群是网站解决高并发、海量数据问题的常用手段。</li><li>通过负载均衡调用服务器，可将访问请求分发到应用服务器集群。</li></ul></li><li>数据库读写分离。<ul><li>使用缓存后仍然有一部分读操作和全部写操作需要访问数据库，这个阶段数据库成为了瓶颈。</li><li>数据库大多都提供主从热备功能，通过配置2台数据库主从关系，可以将一台数据库的数据更新同步到另一台服务器上。网站利用这一功能实现数据库读写分离，主数据库负责写操作，从数据库负责读操作，主数据库会将数据复制到从数据库。</li><li>为了数据库读写分离对应用透明，通常在应用服务器端使用专门的数据访问模块。</li></ul></li><li>使用反向代理和CDN加速网站响应。<ul><li>不同地区的用户访问网站时，速度差别大，导致有的地方访问延迟高。</li><li>CDN（内容分发网络）和反向代理的基本原理都是缓存，区别在于CDN部署在网络提供商的机房，使用户可以从最近的网络提供商机房获取数据；反向代理则部署在网站的中心机房，当用户请求到达中心机房后，首先访问的是反向代理服务器，如果反向代理服务器中缓存着用户请求的资源，就直接返回给用户。</li><li>加快用户访问速度，减轻后端服务器的负载压力。</li></ul></li><li>使用分布式文件系统和分布式数据库系统。<ul><li>数据库拆分手段是业务分库。</li></ul></li><li>使用NoSQL和搜索引擎。<ul><li>数据存储和检索需要越来越复杂，采用非关系数据库技术如NoSQL服务器和非关系数据库查询技术如搜索引擎服务器。</li><li>应用服务器通过一个统一的数据访问模块来访问，分布式缓存服务器、分布式文件服务器、分布式数据库服务器、搜索引擎服务器和NoSQL服务器。</li></ul></li><li>业务拆分。<ul><li>不同业务应用服务器通过消息队列服务器进行数据分发。</li></ul></li><li>分布式服务。<ul><li>随着业务拆分越来越小，存储系统越来越庞大，部署维护越来越难，导致数据库连接资源不足。</li><li>每一个应用系统都需要执行很多相同的业务操作，比如用户管理、商品管理等，可以将这些共用的业务提取出来，独立部署。由这些可复用的业务连接数据库，提供共用业务服务，而应用系统只需要管理用户界面，通过分布式服务器调用共用服务完成具体业务操作。</li></ul></li></ol><p><img src="/images/大型网站架构.png" alt=""></p><h3 id="大型网站架构演化的价值观"><a href="#大型网站架构演化的价值观" class="headerlink" title="大型网站架构演化的价值观"></a>大型网站架构演化的价值观</h3><ol><li>大型网站架构技术的核心价值是随网站所需灵活应对。大型网站不是从无到有，而是能够随小型网站业务逐步发展，润物细无声。</li><li>驱动大型网站技术发展的主要力量是网站的业务发展。</li></ol><h3 id="网站架构设计误区"><a href="#网站架构设计误区" class="headerlink" title="网站架构设计误区"></a>网站架构设计误区</h3><ol><li>一味追随大公司的解决方案。</li><li>为了技术而技术。</li><li>企图用技术解决所有问题。</li></ol><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ol><li>许多小型网站已经慢慢不需要再经历大型网站经历过的架构演化之路就可以逐步发展壮大，因为可以搭建在大型网站提供的云计算服务基础之上，所需要的一切技术资源：网络、计算、存储都可以按需购买。</li></ol><h2 id="大型网站架构模式"><a href="#大型网站架构模式" class="headerlink" title="大型网站架构模式"></a>大型网站架构模式</h2><ol><li>模式描述了一个不断重复的问题机该问题解决方案的核心，让你可以一直使用该方案而不必做重复工作。</li></ol><h3 id="网站架构模式"><a href="#网站架构模式" class="headerlink" title="网站架构模式"></a>网站架构模式</h3><ol><li>分层。<ul><li>应用层。负责具体业务和视图展示，如网站首页及搜索输入和结果展示。</li><li>服务层。为应用层提供服务支持，如用户管理服务，购物车服务等。</li><li>数据层。提供数据存储访问服务，如数据库、缓存、文件、搜索引擎等。</li><li>在开发中，严格遵循分层架构的约束，禁止跨层次的调用，比如应用层直接调用数据层，及逆向调用，比如数据层调用服务层。</li><li>应用层还可以再细分为视图层（美工负责）和业务逻辑层（工程师负责）；服务层也可以再细分为逻辑处理层和数据接口层。</li></ul></li><li>分割。<ul><li>在比如在应用层，将不同业务进行分割，例如将购物、论坛、搜索、广告分割成不同的应用。如果规模庞大业务复杂，购物业务还可以进一步分割成机票酒店业务、3C业务、小商品业务等。</li></ul></li><li>分布式。<ul><li>分布式意味着服务调用必须通过网络，这可能会对性能造成比较严重的影响。</li><li>服务器越多，服务器宕机的概率也就越大，一台服务器宕机可能造成很多应用不能访问，可用性降低。</li><li>数据在分布式的环境中需要保持数据一致性。</li><li>分布式导致网站依赖错综复杂，开发管理维护困难。</li></ul></li><li>集群。<ul><li>对于用户访问集中的模块，比如首页，还需要将分布式独立部署的服务器集群化，即多台服务器部署相同应用构成一个集群，通过负载均衡设备共同对外提供服务。</li><li>一个应用由多态服务器提供，当某台服务器发生故障时，负载均衡设备会将请求转发到集群中其他服务器上，使服务器故障不影响用户使用，提供系统的可用性。</li></ul></li><li>缓存。<ul><li>缓存就是将数据存放在距离计算最近的位置以加快处理速度。</li><li>使用缓存的2个前提条件：一是数据访问热点不均衡，某些数据会被更频繁的访问，这些数据应该放在缓存中。二是数据在某个时间内有效，不会很快过期，否则会失效脏读。</li><li>缓存可以加快数据访问速度，可以减轻后端负载压力，这一点对网站数据库架构至关重要，网站数据库几乎都是按照有缓存的前提进行负载能力设计的。</li></ul></li><li>异步。<ul><li>单一服务器内部可通过多线程共享内存队列的方法实现异步，在分布式系统中，多个服务器集群通过分布式消息队列实现异步，分布式消息队列可以看作内存队列的分布式部署。</li><li>异步架构是典型的生产者消费者模式，2者不存在直接调用。<ol><li>冗余。</li></ol></li><li>为了保证可用性，就需要一定程度的服务器冗余运行，数据冗余备份。</li><li>访问和负载很小的服务也必须部署至少2台服务器构成一个集群，通过冗余提高服务高可用。数据库除了定期备份，存档保存，实现冷备份外，为了保证在线业务高可用，还需要对数据库进行主从分离，实时同步实现热备份。</li><li>为了防止不可抗力，大型网站会在全球范围内部署灾备数据中心。</li></ul></li><li>自动化。<ul><li>自动化架构设计主要集中在发布运维方面。</li><li>发布过程自动化可有效减少故障，发布过程包括，自动化代码管理，自动化测试，自动化安全检测，自动化部署。</li><li>维护过程，自动化监控（对服务器进行心跳检测，监控关键数据指标），自动化报警，自动化失效转移（失效隔离），自动化失效回复，自动化降级（当超出网站最大处理能力时，拒绝部分请求关闭不重要的服务），自动化分配资源。</li></ul></li><li>安全。<ul><li>密码，手机校验码进行身份认证。</li><li>登录、交易等重要操作对网络通信进行加密，敏感数据也进行加密处理。</li><li>防止机器人攻击，使用验证码。</li><li>对常见的XSS攻击、SQL注入，进行编码转换等响应处理。</li><li>对于垃圾信息、敏感信息进行过滤。</li><li>对交易转账等重要操作进行风险控制。</li></ul></li></ol><p><strong>分布式方案</strong></p><ol><li>分布式应用和服务：将分层和分割后的应用和服务模块分布式部署。提高网站性能和并发行，加快开发和发布速度，还可以复用共同的服务，便于业务功能扩展。</li><li>分布式静态资源：网站的静态资源如JS、CSS，图片等资源独立分布式部署，并采用独立的域名，动静分离。可以减轻应用服务器的负载压力，独立域名加快浏览器并发加载的速度。</li><li>分布式数据和存储：除了传统的关系数据库进行分布式部署外，为网站应用而生的NoSQL几乎都是分布式的。</li><li>分布式计算：严格老说，应用、服务和数据都是计算，网站除了要处理这些在线业务外，还有一部分用户没有直观感受的后台业务处理，包括搜索引擎的索引构建、数据仓库的数据分析统计等。这些业务的计算规模非常庞大，目前普遍使用Hadoop以及MapReduce分布式计算框架进行此类批处理计算，其特点是移动计算而不是移动数据，将计算程序分发到数据所在的位置以加速计算和分布式计算。</li><li>此外，还有分布式配置、分布式锁和分布式文件。  </li></ol><p><strong>缓存设计</strong></p><ol><li>CDN：内容分发网络，部署在距离终端用户最近的网络服务商，缓存静态资源热点内容。</li><li>反向代理：网站前端架构的一部分，缓存静态资源热点内容。</li><li>本地缓存：在应用服务器本地缓存着热点数据，可以直接访问无需访问数据库。</li><li>分布式缓存：远程分布式缓存集群。</li></ol><p><strong>异步消息队列的特性</strong></p><ol><li>提高系统可用性。消费者服务器故障，数据可以在消息队列服务器中存储，生产者继续处理业务请求，系统整体表现无故障。</li><li>加快网站响应速度。生产者不用等待消费者处理就可以返回。</li><li>消除并发访问高峰。消息队列可以存储突然增加的访问请求数据，等待消费者服务器处理。</li></ol><h3 id="架构模式在新浪微博的应用"><a href="#架构模式在新浪微博的应用" class="headerlink" title="架构模式在新浪微博的应用"></a>架构模式在新浪微博的应用</h3><ol><li>异步推拉结合的模式。用户发表微博后系统将微博写入消息队列后立即返回，用户响应迅速，消息队列消费者任务将微博推送给所有当前在线粉丝的订阅列表中，非在线用户登录后再根据关注列表拉取微博订阅列表。</li><li>多级缓存策略。热门微博和明星用户的微博缓存在所有的微博服务器上，在线用户的微博和近期微博缓存在分布式缓存集群中，对于微博操作中常见的刷操作，几乎全部都是缓存访问操作。</li><li>多个数据中心。为了提高系统的可用性和性能，多个数据中心可以让用户就近访问最近的数据中心，改善系统性能，同时也是数据冗余复制的灾备中心，所有的数据通过远程消息系统在不同的数据中心之间同步，提高系统可用性。</li></ol><h2 id="大型网站核心架构要素"><a href="#大型网站核心架构要素" class="headerlink" title="大型网站核心架构要素"></a>大型网站核心架构要素</h2><h3 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h3><ol><li>浏览器端，通过浏览器缓存、使用页面压缩、合理布局页面、减少Cookie传输改善性能。</li><li>CDN，将网站静态内容分发至离用户最近的网络服务商机房，使用户通过最短访问路径获取数据。可以在网站机房部署反向代理服务器，缓存热点文件，加快请求响应速度，减轻应用服务器负载压力。</li><li>在应用服务器端，可以使用服务器本地缓存和分布式缓存，通过缓存在内存中的热点数据处理用户请求，加快请求处理过程，减轻数据库负载压力。</li><li>可以通过异步操作将用户请求发送至消息队列等待后续任何处理，而当前请求直接返回响应给用户。</li><li>在网站有很多用户高并发请求的情况下，可以将多台应用服务器组成一个而集群共同对外服务，提供整体处理能力，改善性能。</li><li>在代码层面，也可以通过使用多线程、改善内存管理等手段优化性能。</li><li>在数据库服务器端，索引、缓存、SQL优化等性能优化手段都已经比较成熟。而方兴未艾的NoSQL数据库通过优化数据模型、存储结构、伸缩特性等手段在性能方面的优势也日趋明显。</li></ol><h3 id="可用性"><a href="#可用性" class="headerlink" title="可用性"></a>可用性</h3><ol><li>网站高可用的主要手段是冗余。</li><li>对于应用服务器而言，多台应用服务器通过负载均衡设备组成一个集群共同对外提供服务，任何一台服务器宕机，只需把请求切换到其他服务器，但是一个前提条件是应用服务器上不能保存请求的会话信息，否则会导致会话丢失，即使转发到其他服务器也无法完成业务。</li></ol><h3 id="伸缩性"><a href="#伸缩性" class="headerlink" title="伸缩性"></a>伸缩性</h3><ol><li>衡量架构伸缩性的主要标准就是是否可以用多台服务器构建集群，是否容易向集群中添加新的服务器。</li><li>对于应用服务器集群，只要服务器上不保存数据，所有服务器都是对等的，通过使用合适的负载均衡设备就可以向集群中不断加入服务器。</li><li>对于缓存服务器集群，加入新的服务器可能会导致缓存路由失效，需要改进缓存路由算法保证缓存数据的可访问性。</li><li>关系数据库虽然支持数据复制，主从热等机制，但是很难做到大规模集群的可伸缩性，因此关系数据库的集群伸缩性方案必须在数据库之外实现，通过路由分区等手段将部署有多个数据库的服务器组成一个集群。</li><li>至于大部分NoSQL数据库产品，由于其先天就是为海量数据而生，因此其对伸缩性的支持通常都非常好，可以做到在较少运维参与的情况下实现集群规模的线性伸缩。</li></ol><h3 id="扩展性"><a href="#扩展性" class="headerlink" title="扩展性"></a>扩展性</h3><ol><li>衡量网站架构扩展性好坏的主要标准就是在网站增加新的业务产品时，是否可以实现对现有产品透明无影响，无需要任何改动或者很少改动既有业务功能就可以上线新产品。不同产品之间是否很少耦合。</li><li>网站可扩展架构的主要手段是事件驱动架构和分布式服务。</li><li>事件驱动架构在网站通常利用消息队列实现，将用户请求和其他业务事件构造成消息发送到消息队列，消费者从消息队列中获取消息进行处理。通过这种方式将消息产生和消息处理分离开来，可以透明地增加新消息生产者任务或者新的消息消费者任务。</li><li>分布式服务则是将业务和可复用服务分离开来，通过分布式服务框架调用。新增产品可以通过调用可复用的服务实现自身的业务逻辑，而对现有产品没有任何影响。</li><li>大型网站为了保持市场地位，还会吸引第三方开发者，调用网站服务。</li></ol><h3 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h3><h1 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h1><h2 id="瞬时响应：网站的高性能架构"><a href="#瞬时响应：网站的高性能架构" class="headerlink" title="瞬时响应：网站的高性能架构"></a>瞬时响应：网站的高性能架构</h2><h3 id="网站性能测试"><a href="#网站性能测试" class="headerlink" title="网站性能测试"></a>网站性能测试</h3><p><strong>性能优化手段</strong></p><ol><li>前端架构优化手段，通过优化页面HTML样式、利用浏览器端的并发和异步特性、调整浏览器缓存策略、使用CDN服务、反向代理等手段，使浏览器尽快地显示用户感兴趣的内容、尽可能近地获取页面内容。</li><li>后端架构优化手段，使用缓存加速数据读取、使用集群提高吞吐能力，使用异步消息加快请求响应及实现削峰，使用代码优化手段改善程序性能。</li><li>基础设施优化手段，建设优化骨干网、使用高性价比定制服务器、利用虚拟机技术优化资源利用。</li></ol><p><strong>性能测试指标</strong></p><ol><li>响应时间。</li><li>并发数。</li><li>吞吐量。HPS每秒HTTP请求数，QPS每秒查询数，TPS每秒事务数。吞吐量随着并发数增大，先是增加然后下降到系统崩溃0。</li><li>性能计数器。包括System Load、对象与线程数、内存使用、CPU使用、磁盘与网络I/O等指标，也是系统监控的重要参数。<ul><li>System Load系统负载，指当前正在被CPU执行和等待被CPU执行的进程数目总和，是反映系统忙闲程度的重要指标。理想情况是所有CPU都在使用，没有进程在等待处理，所有Load的理想值是CPU的数目。在Linux用top命令查看。</li></ul></li></ol><p><strong>性能测试方法</strong></p><ol><li>性能测试。目标性能。系统最佳运行点，响应时间较短。</li><li>负载测试。最大负载点。</li><li>压力测试。</li><li>稳定性测试。</li></ol><p><strong>性能优化策略</strong></p><ol><li>性能分析。分析影响性能的主要因素是磁盘、内存、CPU还是网络。</li><li>性能优化。Web前端性能优化、应用服务器性能优化、存储服务器性能优化。</li></ol><h3 id="Web前端性能优化"><a href="#Web前端性能优化" class="headerlink" title="Web前端性能优化"></a>Web前端性能优化</h3><ol><li>主要优化手段有优化浏览器访问、使用反向代理、CND。</li></ol><p><strong>浏览器访问优化</strong></p><ol><li>减少http请求。<ul><li>减少http的主要手段是合并CSS、合并JavaScrpt、合并图片。</li></ul></li><li>使用浏览器缓存。<ul><li>静态资源文件通过设置Cache-Control和Expires属性，设定浏览器缓存，缓存时间可以很长。</li><li>如果静态资源文件变化，可以通过改变文件名实现，即更新文件为不是更新文件内容。</li><li>更新静态资源的时候，应该一个文件一个文件逐步更新，并有一定的间隔，降低峰值。</li></ul></li><li>启用压缩。<ul><li>压缩可以减少通信传输的数据量，但会增加服务器和浏览器的压力，如果通信带宽良好，而服务器资源不足的情况要权衡考虑。</li></ul></li><li>减少Cookie传输。<ul><li>Cookie包含在每次请求和响应中，应尽量减少Cookie中传输的数据量。</li><li>对于某些静态资源的访问，如CSS、JavaScript等，发送Cookie是没有意义的，可以考虑静态资源使用独立域名访问，避免请求静态资源时发送Cookie。</li></ul></li><li>CSS放在页面最上面、JavaScript放在页面最下面。<ul><li>浏览器会再下载完全部CSS之后才对整个页面进行渲染，因此最好的做法是将CSS放在页面最上面。JavaScript执行可能会阻塞页面，所以一般JavaScript放在页面最下面，除非页面解析时需要用到JavaScript。</li></ul></li></ol><p><strong>CDN加速</strong></p><ol><li>本质是一个缓存，做到网络访问第一跳就能获取数据。缓存静态资源，如图片、文件、CSS、JavaScript、静态网页。</li></ol><p><strong>反向代理</strong></p><ol><li>传统代理服务器位于浏览器一侧，代理浏览器将HTTP请求发送到互联网上，而反向代理服务器位于网站机房一侧，代理网站Web服务器接收HTTP请求。</li><li>和传统代理服务器可以保护浏览器一样，反向代理服务器也具有保护网站安全的作用。</li><li>可以将静态内容缓存在反向代理服务器上，也可以把热点动态内容也缓存在代理服务器上，如果动态内容有变化，通过内部通知机制通知反向代理缓存失效，反向代理会加载最新的动态内容再次缓存起来。</li></ol><h3 id="应用服务器性能优化"><a href="#应用服务器性能优化" class="headerlink" title="应用服务器性能优化"></a>应用服务器性能优化</h3><ol><li>优化手段主要有缓存、集群、异步。</li></ol><p><strong>分布式缓存</strong></p><ol><li>网站性能优化第一定律：优先考虑使用缓存优化性能。分布式体现在不同的缓存服务器缓存的范围数据不同，而集群体现在功能的延申性，多台缓存服务器共同提供缓存功能，且可以通过增加服务器到集群扩容。</li><li>缓存的基本原理，将数据存储在相对较高访问速度的存储介质中。一方面缓存可以减少数据访问的时间，另一方面缓存可以避免重复计算。<ul><li>缓存的本质是一个内存Hash表，数据缓存以一对Key、Value的形式存储在内存Hash表中，Hash表数据读写的时间复杂度是O(1)。</li><li>缓存主要用来存放读写比很高，很少变化的数据。根据二八定律，80%的访问落在20%的数据上，所以缓存热点数据可以很好地改善系统性能。</li></ul></li><li>合理使用缓存。<ul><li>频换修改的数据不适合缓存。没有热点访问也不适合缓存。</li><li>一般会对缓存的数据设置失效时间，一旦超过失效时间就要从数据库中重新加载，因此应用要容忍一定时间的数据不一致。还有一种策略是数据更新时立即更新缓存，这会带来更多的系统开销和事务一致性问题。</li><li>缓存可用性。有的网站通过缓存热备来提高缓存可用性，但这有违缓存的初衷，缓存不应该被当做一个可靠的数据源来使用。通过分布式缓存服务器集群，将缓存数据分布到集群多台服务器可在一定程度上改善缓存的可用性，当一台缓存服务器宕机的时候，只有部分缓存数据丢失，重新加载这部分数据不会对数据库产生很大影响。</li><li>缓存预热。缓存中存放的是热点数据，热点数据又是缓存系统利用LRU（最近最少使用）对不断访问的数据筛选淘汰，这个过程需要花费较长的时间。新启动的缓存系统没有数据，最好在缓存系统启动时就把热点数据加载好。</li><li>缓存穿透。如果因为不恰当的业务、或者恶意攻击持续高并发地请求某个不存在的数据，由于缓存没有保存该数据，所有的请求都会落到数据库上。一个简单的对策是将不存在的数据也缓存起来，value值为null。</li></ul></li><li>分布式缓存架构。<ul><li>JBoss Cache为代表的需要更新同步的分布式缓存。JBoss Cache分布式缓存在集群中所有服务器中保存相同的缓存数据，当集群中的某台服务器有缓存数据更新的时候，会通知集群中其他机器更新缓存数据。通常会将应用程序和缓存部署在同一台服务器上，这样会受限于内存，而且同步带来的代价也很大。因而这种方案更多见于企业应用系统中，大型网站很少使用。</li><li>Memcached为代表的不互相通信的分布式缓存。缓存与应用分离部署，应用程序通过一致性Hash等路由算法选择缓存服务器远程访问缓存数据。</li></ul></li><li>Memcached。<ul><li>简单的通信协议，需要考虑通信协议和通信序列化协议。Memcached使用TCP协议通信（UDP也支持），序列化协议则是基于文本的自定义协议，以命令关键字开头，后面是一组命令操作数。</li><li>丰富的客户端程序。Java、C/C++/C#、Python、PHP、Ruby、Perl等主流的网站编程语言都支持。</li><li>高性能的网络通信。服务端通信模块基于Libevent，支持事件出发的网络通信程序库。</li><li>高效的内存管理。内存管理中一个令人头痛的问题是内存碎片管理。Memcached使用固定空间分配，这会浪费空间，但是避免内存碎片管理提高了效率。</li><li>互不通信的服务器集群架构。客户端路由算法一致性Hash是数据存储伸缩性架构设计的经典范式。正是集群内服务器互不通信使得集群可以做到几乎无限制的线性伸缩。很多NoSQL在数据持久化、支持复杂数据结构、性能上由于Memcached。</li></ul></li></ol><p><strong>异步操作</strong></p><ol><li>使用消息队列将调用异步化，可改善网站的扩展性，还可以改善网站系统的性能。</li><li>消息队列可以削峰填谷，任何可以晚点做的事情都应该晚点再做。</li></ol><p><strong>使用集群</strong></p><ol><li>使用负载均衡技术为一个应用构建一个由多台服务器组成的服务器集群，将分并访问请求分发到多台服务器上处理。</li></ol><p><strong>代码优化</strong></p><ol><li>多线程。使用多线程的2个原因，IO阻塞和多CPU。<ul><li>启动线程数=任务执行时间/（任务执行时间-IO等待时间）*CPU内核数。</li><li>线程安全的主要手段有：将对象设计为无状态对象，使用局部对象，并发访问资源时使用锁。</li></ul></li><li>资源复用。<ul><li>要尽量减少那些开销很大的系统资源的创建和销毁，比如数据库连接、线程、网络通信连接和复杂对象。</li><li>资源复用的主要有2种模式，单例和对象池。数据库连接使用的连接池就属于对象池，多线程使用的线程池也属于对象池。</li></ul></li><li>数据结构。</li><li>垃圾回收。<ul><li>当Eden区空间已满，就触发一次Young GC，将未失效的对象复制到From区；当Eden区空间再次用完，触发一次Yound GC，将Eden和From区的对象复制到To区；下一次则是将Eden和To区复制到From，依次类推。</li><li>进入年老代的3种情况：长期存活的对象进入年老代（年龄大于阈值，或者如果Suivivor中相同年龄的对象总和大于Suivivor的一半，年龄&gt;=该年龄的对象进入年老代）；大对象直接进入年老代；Minor GC后如果存活对象太多Survivor空间不够的话，超出的部分会进入年老代。</li><li>CMS GC：Minor GC发生前，判断是否安全，即年老代是否能容纳年轻代所有对象，如果安全则直接进行Minor GC；如果不安全的，且不允许担保失败，则改为Full GC；如果不安全且允许担保失败，尝试进行Minor GC，失败出现promotion failure则改为Full GC。如果在CMS GC并发标记和并发清除时，业务线程的执行导致进入年老代的对象没有空间容纳，出现concurrent mode failure，这时改用stop the world的Serial Old GC。</li><li>发生Full GC（表示年老代stop the world）的5种情况：System.gc()调用；年老代空间不足，执行后仍不足OutOfMemoryError；永久代空间不足；MinorGC发生前，判断年老代是否能容纳历来晋升平均大小，不能改为Full GC；CMS GC。</li></ul></li></ol><h3 id="存储性能优化"><a href="#存储性能优化" class="headerlink" title="存储性能优化"></a>存储性能优化</h3><ol><li>机械硬盘和固态硬盘。</li><li>B+树和LSM树。<ul><li>由于磁盘访问时都是随机的，而机械硬盘在数据随机访问时性能较差，传统数据库使用B+树，在每次数据访问都需要多次访问磁盘影响性能。</li><li>目前许多NoSQL使用LSM树，LSM的写操作都在内存中进行，并且都会创建一个新记录，这些数据在内存中仍然还是一棵排序树，当数据量超过阈值后，会将这棵排序树和磁盘上的排序树合并。读操作时，会先在内存中的排序树查找，没有再从磁盘上的排序树查找。</li><li>当访问以写操作为主，而读操作则集中在最近写入的数据时，使用LSM树可极大程度地减少磁盘的访问次数。</li><li>LSM和B+树不是独有的，而且随着SSD硬盘技术的成熟，数据库使用的情况可能会改变。但目前是NoSQL多使用LSM，而关系数据库使用B+树，且SSD硬盘价格贵。</li></ul></li><li>RAID和HDFS。<ul><li>RAID（廉价磁盘冗余阵列），多块磁盘通过使用RAID技术，实现数据在多块磁盘上的并发读写和数据备份，改善访问延迟和提高可用性。多用于关系数据库。</li><li>RAID0只分数据不冗余，读写快，但是可用性低。RAID1，2块磁盘2份数据。RAID10，多块磁盘2份数据。RAID3，1块做记录校验，保证1块磁盘损坏得到恢复，但是校验磁盘容易损坏。RAID5，记录校验螺旋式地写入所有磁盘中。RAID6，保证2块磁盘损坏也能得到恢复，用2块磁盘螺旋式记录校验。</li><li>HDFS（Hadoop分布式文件系统），系统在整个存储集群上进行数据并发读写和备份，可以看作在集群规模上实现了类似的RAID的功能。当对文件进行处理计算时，通过MapReduce并发计算任务框架，可以启动多个计算子任务，同时读取文件的多个Block块，并发处理。</li><li>HDFA中有2种重要的服务器角色，NameNode和DataNode。NameNode只部署一个实例，提供元数据服务，相当于操作系统中的FAT，管理文件名的Block分配，维护整个文件系统的目录树结构。应用程序需要写文件时，NameNode会按照一定的负载均衡策略分配数据块。</li></ul></li></ol><h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><ol><li>分布式的方案可以改善网站并发特性，但是分布式不可避免地带来架构复杂、网络通信延迟。这样会缩短高并发访问响应延迟的同时，却延长了低并发访问响应延迟。</li></ol><h2 id="万无一失：网站的高可用架构"><a href="#万无一失：网站的高可用架构" class="headerlink" title="万无一失：网站的高可用架构"></a>万无一失：网站的高可用架构</h2><h3 id="高可用的网站架构"><a href="#高可用的网站架构" class="headerlink" title="高可用的网站架构"></a>高可用的网站架构</h3><ol><li>高可用架构的主要目的是保证服务器硬件故障时服务依然可以可用、数据依然保存并能够被访问。</li><li>高可用架构的主要手段是数据和服务的冗余备份及失效转移。</li><li>应用层主要负责具体业务逻辑处理，服务层负责提供可复用的服务，数据层负责数据的存储与访问。中小型网站通常将应用层和服务层部署在一起，而数据层则另外部署。</li><li>应用层可能会分为多个应用，而服务层则是共同的复用业务，如注册登录服务、Session管理服务、账号管理服务等，至于数据层包括数据库服务、文件服务、缓存服务和搜索服务。</li><li>应用层的服务器为了应对高并发的访问请求，会通过负载均衡设备将一组服务器组成一个集群共同对外提供服务，当负载均衡设备通过心跳检测等手段监控到某台应用服务器不可用时，就将其从集群列表中剔除。</li><li>服务层也是通过集群方式实现高可用，当被应用层通过分布式服务调用框架访问时，框架会在应用层客户端程序中实现软件负载均衡，并通过服务注册中心对提供服务的服务器进行心跳检测。</li><li>数据层服务器因为存储着数据比较特殊，为了保障服务器宕机时数据不丢失，需要对数据冗余备份。</li></ol><h3 id="高可用的应用"><a href="#高可用的应用" class="headerlink" title="高可用的应用"></a>高可用的应用</h3><ol><li>应用层主要处理网站应用的业务逻辑，有时也称做业务逻辑层，应用的一个显著特点是应用的无状态性。无状态是指不保存业务的上下文信息，多个服务器之间完全对等。</li><li>通过负载均衡进行无状态服务的失效转移。</li><li>应用服务器集群的Session管理。<ul><li>Session复制。所有集群同步不适合规模大的。</li><li>Session绑定。负载均衡通过Hash算法将源自统一IP或者Cookie分发到同一台服务器，没有备份可用性低。</li><li>利用Cookie记录Session。缺点是受Cookie大小限制，能记录的信息有限，每次请求响应都需要传输Cookie，影响性能。但是简单易用、可用性高、伸缩性好，许多网站或多或少使用Cookie记录Session。</li><li>Session服务器集群，这种解决方案事实上是将应用服务器的状态分离，分成无状态的应用服务器和有状态的Session服务器。对于有状态的Session服务器，一种简单的方法是利用分布式缓存、数据库等，在这些产品的基础上进行包装。如果业务场景对Session管理与比较高的要求，比如利用Session服务集成单点登录、用户服务等，则需要开发专门的Session服务管理平台。</li></ul></li></ol><h3 id="高可用的服务"><a href="#高可用的服务" class="headerlink" title="高可用的服务"></a>高可用的服务</h3><ol><li>可复用的服务和应用一样，也是无状态的服务，因此可以使用负载均衡。</li><li>分级管理。运维上将服务器进行分级管理，核心应用和服务优先使用更好的硬件。服务部署也要进行必要的隔离，避免故障的连锁反应。</li><li>超时设置。一旦超时可选择重试或者转移。</li><li>异步调用。需要确认服务调用成功或者得到服务调用结果才能进行下一步操作的应用，即存在时序关系，不适合异步调用。</li><li>服务降级。高并发时，拒绝低优先级应用的调用，或者关闭功能。</li><li>幂等性设计。</li></ol><h3 id="高可用的数据"><a href="#高可用的数据" class="headerlink" title="高可用的数据"></a>高可用的数据</h3><ol><li>数据存储服务器上保存的数据不同，不能任意切换到集群中其他的机器上，主要手段是数据备份和失效转移机制。</li><li>缓存服务不是数据存储服务，不应该提高缓存服务本身的高可用，因为单机宕机引用的缓存数据丢失比例和数据库负载压力变化都较小。</li><li>CAP原理认为，一个提供数据服务的存储系统无法同时满足一致性、可用性和分区耐受性。规模大的网站必须使用分布式集群，所以通常会选择A可用性和伸缩性P，而在某种程度上放弃一致性C。数据一致性：数据强一致、数据用户一致、数据最终一致，一般通过纠错和校验机制达到数据用户一致。</li><li>数据备份。冷备简单廉价，缺点是不能保证数据最终一致，可能导致永久丢失，也不能保证数据可用性。<ul><li>热备分为2种：异步热备和同步热备，异步指的是应用程序只保证主存储服务器写操作成功，然后主存储服务器再同步到从存储服务器，同步则是应用程序向多台存储服务器进行写操作，因为是并发操作，所以只是最慢的存储服务器的响应延迟而不是总和。</li><li>同步机制可以实现读写分离改善性能。</li></ul></li><li>失效转移。<ul><li>失效确认，通过心跳检测和应用程序访问失败报告。</li><li>访问转移。</li><li>数据恢复。</li></ul></li></ol><h3 id="高可用网站的软件质量保证"><a href="#高可用网站的软件质量保证" class="headerlink" title="高可用网站的软件质量保证"></a>高可用网站的软件质量保证</h3><ol><li>网站发布。每次关闭的服务器都是集群中的一小部分，因此整个发布过程不影响用户使用。</li><li>自动化测试。使用Selenium自动测试工具或者脚本和自己的自动测试工具。</li><li>预发布验证。预发布服务器是一种特殊用途的服务器，和正式服务器的唯一不同就是没有配置再负载均衡，外部用户无法访问。</li><li>代码版本控制。Git。</li><li>自动化发布。</li><li>灰度发布。每天只发布一部分服务器，方便回滚。</li></ol><h3 id="网站运行监控"><a href="#网站运行监控" class="headerlink" title="网站运行监控"></a>网站运行监控</h3><ol><li>不允许没有监控的系统上线。</li><li>监控数据采集。<ul><li>用户行为日志收集。服务器端日志收集，客户端浏览器日志收集。</li><li>服务器性能监控。如系统Load、磁盘IO、内存占用、网络IO。</li><li>运行数据报告。业务场景相关的技术和业务指标，比如缓存命中率，平均响应延迟时间、每分钟发送邮件数目、待处理的任务总数等。</li></ul></li><li>监控管理。<ul><li>系统报警。</li><li>失效转移。</li><li>自动优雅降低。</li></ul></li></ol><h2 id="永无止境：网站的伸缩性架构"><a href="#永无止境：网站的伸缩性架构" class="headerlink" title="永无止境：网站的伸缩性架构"></a>永无止境：网站的伸缩性架构</h2>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>正则表达式</title>
      <link href="/2018/10/25/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
      <url>/2018/10/25/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<ol><li>(?:a|b)和(a|b)的区别，(?:a|b)是非获取匹配，消耗字符，受限制即不能用matcher.group(1)匹配a|b，其他和(a|b)一样。(?:(a|b))和(a|b)效果相同，所有的非获取匹配都可以用括号转换成获取匹配，但不改变字符的消耗属性。</li><li>正向预查 <ul><li>a(?=b)匹配abcd，正向匹配预查，非获取匹配b，但是不消耗b，下一次匹配字符从b即matcher.end开始。</li><li>a(?!b)，正向不匹配预查。</li><li>(?=[a-d])匹配abcd，相当于[位置](?=[a-d])，每次匹配位置即字符间隙。</li></ul></li><li>反向预查<ul><li>(?&lt;=a)b匹配abcd，反向匹配预查，非获取匹配a，但是不消耗a，哪怕上之前匹配过a依然可以继续匹配。</li><li>(?&lt;!a)b，反向不匹配预查。</li><li><ul><li>(?&lt;=[a-d])匹配abcd，相当于(?&lt;=[a-d])[位置]，每次匹配位置即字符间隙。</li></ul></li></ul></li><li>\\1，匹配第1个分组，常用于重复匹配。<ul><li>[a-z]{2}，匹配2个字母。</li><li>[a-z]\\1，匹配2个相同的字母。</li></ul></li><li>\\G，匹配上一次的end。<ul><li>分割字符串为相同的字符串 (?&lt;=\\G.{n})</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 正则表达式 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Java并发编程实战</title>
      <link href="/2018/10/25/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/"/>
      <url>/2018/10/25/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><h2 id="并发的原因"><a href="#并发的原因" class="headerlink" title="并发的原因"></a>并发的原因</h2><ol><li>资源利用率。在某些情况下，程序必须等待某个外部操作执行完成，例如IO，而在等待时程序无法执行其他任何工作。如果在等待的同时可以运行另一个程序，可以提高资源的利用率。</li><li>公平性。不同的用户和程序对于计算机上的资源用着同等的使用权，可以通过时间分片实现。</li><li>便利性。在执行多个任务时，应该编写多个程序，每个程序执行一个任务并在必须时互相通信，这比编写一个程序来执行所有任务更容易实现。</li></ol><h2 id="线程的优势"><a href="#线程的优势" class="headerlink" title="线程的优势"></a>线程的优势</h2><ol><li>发挥多处理器的强大能力。</li><li>建模的简单性。</li><li>异步事件的简化处理。</li><li>响应更灵敏的用户界面。</li></ol><h2 id="线程带来的风险"><a href="#线程带来的风险" class="headerlink" title="线程带来的风险"></a>线程带来的风险</h2><ol><li>安全性问题。数据共享简化线程间通信的同时，也带来了巨大的风险。</li><li>活跃性问题。活跃性是指某个操作无法继续执行下去，比如死锁。</li><li>性能问题。</li></ol><h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><h2 id="线程安全性"><a href="#线程安全性" class="headerlink" title="线程安全性"></a>线程安全性</h2><p><strong>多线程数据访问出错修复方法</strong></p><ol><li>不共享变量。</li><li>将变量修改为不可变。</li><li>访问变量时使用同步。</li></ol><h3 id="线程安全性-1"><a href="#线程安全性-1" class="headerlink" title="线程安全性"></a>线程安全性</h3><ol><li>无状态对象一定是线程安全的。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class MyServlet implements Servlet&#123;</span><br><span class="line">    public void service(ServletRequest request,ServletResponse response)&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h3><ol><li>竞态条件，由于执行时序而出现不正确的结果。最常见的竞态条件是，先检查后执行。</li><li>复合操作，java.util.concurrent.atomic包含的原子变量类的访问操作都是原子的。</li></ol><h3 id="加锁机制"><a href="#加锁机制" class="headerlink" title="加锁机制"></a>加锁机制</h3><ol><li>内置锁，Java提供同步代码块来支持原子性，同步代码块包括2部分，1个作为锁的对象引用，1个作为由这个锁保护的代码块。synchronized修饰的方法就是一种横跨整个方法体的同步代码块，该同步代码块的锁就是方法调用所在的对象，静态的则是以Class对象作为锁。</li><li>Java的内置锁相当于互斥锁。由于每次只能有一个线程执行同步代码块，所以会以原子方式执行，即一组语句作为一个不可分割的单元被执行。</li><li>Java的内置锁是可以重入的，重入意味着获取锁的操作粒度是线程而不是调用。子类的覆盖方法也会获得父类锁，重入可以避免这种死锁发生。</li></ol><h3 id="用锁来保护状态"><a href="#用锁来保护状态" class="headerlink" title="用锁来保护状态"></a>用锁来保护状态</h3><ol><li>如果用同步来协调对某个变量的访问，那么在访问这个变量地所有位置上都需要使用同步。</li><li>只有被多个线程同时访问的可变数据才需要通过锁来保护。</li></ol><h3 id="活跃性与性能"><a href="#活跃性与性能" class="headerlink" title="活跃性与性能"></a>活跃性与性能</h3><ol><li>当执行时间较长的计算或者可能无法快速完成的操作时，一定不要持有锁。</li></ol><h2 id="对象的共享"><a href="#对象的共享" class="headerlink" title="对象的共享"></a>对象的共享</h2><h3 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h3><ol><li>通常，我们无法确保执行读操作的线程能适时地看到其他线程写入的值。</li><li>编译器可能会对操作的执行顺序进行重排序优化，这种重排序只能保证在单线程中有正确的结果。</li><li>非volatile类型的64位数值变量double和long的读写操作会分解成2个32位操作，不是原子操作，这可能读取到某个值的高32位和另一个值的低32位。</li><li>加锁的含义不仅仅局限于互斥行为，还包括内存可见性。</li><li>volatile变量操作不会和其他内存操作一起重排序，volatile变量会同步到主内存，所以读取volatile变量时总会返回最新写入的值。</li></ol><p><strong>使用volatile变量必须满足以下所有条件</strong></p><ol><li>访问变量时不需要加锁。</li><li>对变量的写入操作不依赖变量的当前值，或者你能确保只有单个线程更新变量的值。</li><li>该变量不会与其他状态变量一起纳入不变性条件中。</li></ol><h3 id="发布与逸出"><a href="#发布与逸出" class="headerlink" title="发布与逸出"></a>发布与逸出</h3><ol><li>发布一个对象是指对象能够在当前作用域之外的代码中使用。多线程发布会破坏封装性，使得程序难以维持不变性条件，比如，对象构造完成之前就发布该对象。逸出是指当某个不应该发布的对象被发布。</li><li>使用工厂方法来防止this引用在构造过程中逸出。</li></ol><h3 id="线程封闭"><a href="#线程封闭" class="headerlink" title="线程封闭"></a>线程封闭</h3><ol><li>线程封闭是指仅在单线程内访问数据，不共享数据就不需要同步。</li><li>Swing的对象都不是线程安全的，应保证只有事件线程才能访问对象，使用单线程子系统的另一个原因是为了避免死锁。</li></ol><p><strong>线程封闭的3种方式</strong></p><ol><li>Ad-hoc线程封闭是指维护线程封闭性的职责完全由程序实现来承担，Ad-hoc线程封闭是非常脆弱的，因为没有任何一种语言特性能将对象封闭到目标线程上，所以在程序中尽量少用它。在可能的情况下，应该使用更强的线程封闭技术，比如栈封闭或者ThreadLocal类。当决定使用线程封闭技术时，通常是因为要将某个特定的子系统实现为一个单线程子系统。</li><li>栈封闭是指只能通过局部变量才能访问对象。</li><li>维持线程封闭性的一种更规范方法是使用ThreadLocal，通常用于防止对可变的单实例变量或全局变量进行共享。概念上看，可以将Thread Local<t>视为包含Map&lt;Thread,T&gt;，其中保存了特定与该线程的值，不过实现上是将特定于线程的值保存在Thread对象中，当线程结束后这些值会被GC回收。</t></li></ol><h3 id="不变性"><a href="#不变性" class="headerlink" title="不变性"></a>不变性</h3><ol><li>对象创建以后其状态就不能修改。</li><li>对象的所有字段都是final类型。</li><li>对象被正确创建。在对象的创建期间，this引用没有逸出。</li></ol><h3 id="安全发布"><a href="#安全发布" class="headerlink" title="安全发布"></a>安全发布</h3><p><strong>初始化安全性</strong></p><ol><li>要安全地发布一个对象，对象的引用以及对象的状态必须同时对其他线程可见。即使某个对象的引用对其他线程是可见的，也并不意味着对象状态对于其他线程一定是可见的。</li><li>不可变对象有一种特殊的初始化安全性保证，发布不可变对象的引用时即使没有同步，也仍然可以安全地访问对象。这种保证还将延申到被正确创建对象中的所有final类型的字段，在没有额外同步的情况下，也可以安全地访问final类型的字段，但不能保证可以访问final类型字段的状态。</li><li>最简单和最安全的方式是使用静态初始化器，静态初始化器由JVM在类的初始化阶段执行，由于JVM内部存在着同步机制，所以可以被安全地发布。</li><li>将一个键或者值放入并发安全容器中，可以安全地将它发布给任何从这些容器中访问它的线程。</li></ol><p><strong>安全发布方式</strong></p><ol><li>在静态初始化函数中初始化一个对象引用。</li><li>将对象的引用保存到volatile类型的字段或者AtomicReferance对象中。</li><li>将对象的引用保存到某个正确构造对象的final类型字段中。</li><li>将对象的引用保存到一个由锁保护的字段中。</li></ol><p><strong>发布需求取决于可变性</strong></p><ol><li>不可变对象可以通过任意机制来发布。</li><li>事实不可变对象必须通过安全方式来发布。</li><li>可变对象必须通过安全方式来发布，并且必须是线程安全的或者由某个锁保护起来。</li></ol><p><strong>安全地共享对象</strong></p><ol><li>线程封闭。</li><li>只读共享。</li><li>线程安全共享。</li><li>保护对象。</li></ol><h2 id="对象的组合"><a href="#对象的组合" class="headerlink" title="对象的组合"></a>对象的组合</h2><h3 id="设计线程安全的类"><a href="#设计线程安全的类" class="headerlink" title="设计线程安全的类"></a>设计线程安全的类</h3><p><strong>3个基本要素</strong></p><ol><li>找出构成对象状态的所有变量。</li><li>找出约束状态变量的不变性条件。</li><li>建立对象状态的并发访问管理策略。</li></ol>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>编程题总结</title>
      <link href="/2018/10/24/%E7%AC%94%E8%AF%95/%E7%BC%96%E7%A8%8B%E9%A2%98%E6%80%BB%E7%BB%93/"/>
      <url>/2018/10/24/%E7%AC%94%E8%AF%95/%E7%BC%96%E7%A8%8B%E9%A2%98%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="Bug"><a href="#Bug" class="headerlink" title="Bug"></a>Bug</h1><ol><li>分析样例后，直接采用样例数字进行计算，忘记转换成输入变量。</li><li>int溢出，用long。</li></ol><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><ol><li>数据结构+算法。</li><li>不要生搬硬套算法，从解题过程入手，自然而然地应用算法。</li></ol><h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><ol><li>最优子结构，简单的直接通过决策分解成多个子问题的组成，复杂的需要根据子问题的最优解推导。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 笔试 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>算法</title>
      <link href="/2018/10/23/%E7%AE%97%E6%B3%95/"/>
      <url>/2018/10/23/%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="图"><a href="#图" class="headerlink" title="图"></a>图</h1>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>C/C++</title>
      <link href="/2018/10/22/C/"/>
      <url>/2018/10/22/C/</url>
      
        <content type="html"><![CDATA[<h1 id="malloc-free和new-delete的区别"><a href="#malloc-free和new-delete的区别" class="headerlink" title="malloc/free和new/delete的区别"></a>malloc/free和new/delete的区别</h1><ol><li>malloc/free成对使用，是C语言的函数。new/delete和new[]/delete[]也是成对使用，是C++语言的操作符。</li><li>new会先调用构造函数，delete会先调用析构函数，而malloc和free不会。</li></ol><h1 id="C-的const"><a href="#C-的const" class="headerlink" title="C++的const"></a>C++的const</h1><ol><li>常量的指针也必须是指向常量的指针，而变量的指针没有限制。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>* p=<span class="number">1</span>; <span class="comment">//表示指针指向常量。</span></span><br><span class="line"><span class="keyword">int</span>* <span class="keyword">const</span> p=<span class="number">1</span>; <span class="comment">//表示指针是常量。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> a=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span>* ap=&amp;a; <span class="comment">//出错，const int*不能转成int*。</span></span><br><span class="line"><span class="keyword">int</span> b=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>* bp=&amp;b; <span class="comment">//正常，int*可以转成const int*。</span></span><br></pre></td></tr></table></figure><h1 id="C和C-的const的区别"><a href="#C和C-的const的区别" class="headerlink" title="C和C++的const的区别"></a>C和C++的const的区别</h1><ol><li>作用域不同。C的全局const作用域是整个程序，C++的全局const作用域是当前文件。</li><li>在ANSI标准下，C的const表示只读变量，C++表示的是常量。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> size=<span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> <span class="built_in">array</span>[size]; <span class="comment">//在ANSI标准的C中是错误的，size是变量，虽然是只读。在C++中是正确的。</span></span><br></pre></td></tr></table></figure><ol start="3"><li>C++的const作用范围广，可以作用于函数。</li></ol>]]></content>
      
      
      <categories>
          
          <category> C/C++ </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>JSP</title>
      <link href="/2018/10/19/JSP/"/>
      <url>/2018/10/19/JSP/</url>
      
        <content type="html"><![CDATA[<h1 id="JSP的内置对象"><a href="#JSP的内置对象" class="headerlink" title="JSP的内置对象"></a>JSP的内置对象</h1><ol><li>io对象：request、response、out</li><li>通信控制对象：pageContext、session、application</li><li>Servlet对象：page、config</li><li>错误处理对象：exception</li></ol>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Java</title>
      <link href="/2018/10/18/Java%E9%9D%A2%E8%AF%95/"/>
      <url>/2018/10/18/Java%E9%9D%A2%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<p>#类加载</p><h2 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h2><ol><li>加载。类加载器加载。</li><li>验证（链接）。检查字节码。</li><li>准备（链接）。类变量分配内存并默认初始化。</li><li>解析（链接）。解析符号链接，链接到方法区的引用上去。</li><li>初始化。超类初始化、类初始化。</li></ol><h2 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h2><ol><li>引导类加载器。C++语言实现，加载JVM自身需要的类。没有父类加载器。</li><li>扩展类加载器。加载扩展库。父类加载器为null，表示引导类加载器。</li><li>系统类加载器（AppClassLoader）。程序中默认的类加载器。父类加载器为ExtClassLoader。</li></ol><h2 id="双亲委派模式"><a href="#双亲委派模式" class="headerlink" title="双亲委派模式"></a>双亲委派模式</h2><ol><li>除了引导类加载器外的类加载器都要有自己的父类加载器。通过复合而非继承实现父子关系。</li><li>当类加载器收到类加载请求，会先把请求委托给父加载器去执行，依次递归。如果父类加载器无法完成加载任务，子加载器才会尝试去加载。</li></ol><h2 id="双亲委派模式优势"><a href="#双亲委派模式优势" class="headerlink" title="双亲委派模式优势"></a>双亲委派模式优势</h2><ol><li>Java类随着它的类加载器一起具备了一种带有优先级的层次关系，通过这种层次关系可以避免类的重复加载。</li><li>安全方面，保证了Java的核心类不会被随意替换。另外java.lang包的类系统类加载器没有权限加载，所以不能自定义该包的类。</li></ol><h2 id="Class对象唯一的条件"><a href="#Class对象唯一的条件" class="headerlink" title="Class对象唯一的条件"></a>Class对象唯一的条件</h2><ol><li>类全限名相同。</li><li>加载类的类加载器实例对象相同。</li></ol><h2 id="显示加载"><a href="#显示加载" class="headerlink" title="显示加载"></a>显示加载</h2><ol><li>Class.forName()。</li><li>this.getClass().getClassLoader().loadClass()。</li></ol><h2 id="自定义类加载器的优势"><a href="#自定义类加载器的优势" class="headerlink" title="自定义类加载器的优势"></a>自定义类加载器的优势</h2><ol><li>可以加载特定路径下的类。</li><li>在加载前添加额外操作。比如class文件通过网络加密传输时，需要解密后才能加载。</li><li>实现热部署功能。</li></ol><h2 id="双亲委派模型的破坏者"><a href="#双亲委派模型的破坏者" class="headerlink" title="双亲委派模型的破坏者"></a>双亲委派模型的破坏者</h2><ol><li>服务提供者接口SPI由Java核心库提供，是由引导类加载器加载的，当提供第三方实现的时候，SPI的类加载器即引导类加载器在双亲委派中无法委派系统类加载器。</li><li>引导类加载器可以委派线程上下文类加载器ContextClassLoader加载。</li></ol><h1 id="JVM框架"><a href="#JVM框架" class="headerlink" title="JVM框架"></a>JVM框架</h1><h2 id="JVM三个子系统"><a href="#JVM三个子系统" class="headerlink" title="JVM三个子系统"></a>JVM三个子系统</h2><ol><li>类加载系统</li><li>运行时数据区</li><li>执行引擎</li></ol><h2 id="运行时数据区"><a href="#运行时数据区" class="headerlink" title="运行时数据区"></a>运行时数据区</h2><ol><li>PC寄存器。</li><li>栈。</li><li>本地方法栈。</li><li>堆。</li><li>方法区。</li></ol><h2 id="执行引擎"><a href="#执行引擎" class="headerlink" title="执行引擎"></a>执行引擎</h2><ol><li>解释器。</li><li>JIT编译器。</li><li>垃圾收集器。</li></ol><h1 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h1><ol><li>多个线程循环等待被占用的资源导致的无限期僵持现象。</li></ol><h2 id="死锁的4个必要条件"><a href="#死锁的4个必要条件" class="headerlink" title="死锁的4个必要条件"></a>死锁的4个必要条件</h2><ol><li>互斥条件。资源只能独占不能共享。</li><li>不可抢占条件。资源未使用完毕，其他申请者不能强行夺取。</li><li>占有且申请条件。进程至少已经占有一个资源，并且又申请新的资源。</li><li>循环等待条件。存在一个进程等待序列。</li></ol><h2 id="死锁预防（静态策略）"><a href="#死锁预防（静态策略）" class="headerlink" title="死锁预防（静态策略）"></a>死锁预防（静态策略）</h2><ol><li>打破互斥条件。独占属性由资源自身决定，无实用价值。</li><li>打破不可抢占条件。实现困难，会降低系统性能。</li><li>打破占有且申请条件。实行资源预先分配策略，即进程在运行前一次性向系统申请所需要的全部资源，如果不满足则不分配任何资源。<ul><li>进程执行时是动态的，一般执行之前很难知道它所需要的全部资源。</li><li>资源利用率低。</li><li>降低了进程的并发性。</li></ul></li><li>打破循环等待条件。实行资源有序分配策略，使进程申请占用资源时不会形成环路。比前面的预先分配的资源利用率要高。<ul><li>对系统的所有资源合理编号也是件困难事。</li><li>为了遵循按编号申请的次序，暂不使用的资源也需要提前申请，增加了进程对资源的占用时间。</li></ul></li></ol><h2 id="死锁避免（动态策略）"><a href="#死锁避免（动态策略）" class="headerlink" title="死锁避免（动态策略）"></a>死锁避免（动态策略）</h2><ol><li>银行家算法。从当前状态出发，逐个检查能完成工作的客户，假定完成工作后归还全部贷款，再继续检查下一个客户，知道所有客户完成即找到一个安全序列。<ul><li>寻找安全序列增加了系统开销。</li><li>算法只能保证所有客户的需求，不能保证实时客户的快速响应。</li><li>算法要求客户数保持固定不变。</li></ul></li></ol><h2 id="死锁检测与恢复"><a href="#死锁检测与恢复" class="headerlink" title="死锁检测与恢复"></a>死锁检测与恢复</h2><ol><li>死锁预防避免比较困难，开销比较大。一般采用检查和恢复措施。</li><li>死锁检测通过资源和进程的分配表以及等待表，判断是否由环路。</li><li>死锁恢复一般的办法是撤销环路中代价最小的进程。</li></ol><h1 id="堆栈"><a href="#堆栈" class="headerlink" title="堆栈"></a>堆栈</h1><ol><li>栈存基本类型和引用类型变量，堆存对象。</li><li>栈的栈帧随方法的调用而产生，随方法的结束而回收，堆由GC回收管理。</li><li>栈是线程私有的，堆是共享的。</li></ol><h1 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h1><ol><li>性能上，占用的系统资源更少，能支持更多的并发连接，特别是静态小文件。</li><li>功能上，不仅是一个网页服务器，还可以作为反向代理负载均衡及缓存服务器使用。负载均衡，通过负载均衡算法将报文请求均衡分配给多个提供相同服务的后台服务器。普通代理是内网用户通过设备访问外网，而反向代理是外网用户通过设备访问内网。</li><li>配置上，简单、方便、灵活。</li></ol><h1 id="外排序"><a href="#外排序" class="headerlink" title="外排序"></a>外排序</h1><ol><li>当大于内存的数据需要排序时，将数据分成多个文件，对每个文件用内排序排序，然后从排好序的每个文件中取出前面的部分进行归并排序，结果存入新的文件，依次循环。</li></ol>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>MySQL</title>
      <link href="/2018/10/17/MySQL/"/>
      <url>/2018/10/17/MySQL/</url>
      
        <content type="html"><![CDATA[<h1 id="模糊查询"><a href="#模糊查询" class="headerlink" title="模糊查询"></a>模糊查询</h1><p><strong>LIKE或NOT LIKE</strong></p><ol><li>%：0个或多个字符。</li><li>_：1个字符。</li><li>[]：括号内字符中的1个字符。</li><li>[^]：不在括号内字符中的1个字符。</li><li>\：转义。</li></ol><p><strong>REGEXP或NOT REGEXP</strong></p><h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><ol><li>普通索引</li><li>唯一索引</li><li>主键索引</li><li>组合索引</li></ol><p><strong>索引限制</strong></p><ol><li>避免全表扫描，在where和order by涉及的列上建立索引。</li><li>or条件中的每个列必须都加上索引才能生效，否则失效，使用union代替。</li><li>组合索引必须使用第1个才会生效，否则失效。</li><li>LIKE查询不能是%开头，否则失效。</li><li>条件的列不能进行运算，否则失效。</li><li>not in和in会导致全表扫描，用between等代替。</li><li><p>is null和is not null会导致失效，不要设置默认值null。</p></li><li><p>如果创建了索引(a,b,c)，实际等同于创建了索引(a)、索引(a,b)和索引(a,b,c)。</p></li><li>索引不会包含有NULL值得列，组合索引只有要一列含有NULL值就无效。</li><li>对字符串索引时限制长度。</li><li>VARCHAR是变长的，可以节约空间，但更新数据时可能产生碎片。</li><li>ENUM类型代替字符串类型，数据实际存储为整型。</li></ol>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>全排列</title>
      <link href="/2018/10/13/%E5%85%A8%E6%8E%92%E5%88%97/"/>
      <url>/2018/10/13/%E5%85%A8%E6%8E%92%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h1 id="递归交换"><a href="#递归交换" class="headerlink" title="递归交换"></a>递归交换</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public static void permutation(int[] array)&#123;</span><br><span class="line">    permutation(array,0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void permutation(int[] array,int index)&#123;</span><br><span class="line">    if(index==array.length-1) &#123;</span><br><span class="line">        System.out.println(Arrays.toString(array));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //第2次交换保证permutation方法不会打乱array</span><br><span class="line">    for(int i=index;i&lt;array.length;i++)&#123;</span><br><span class="line">        swap(array,index,i);</span><br><span class="line">        permutation(array,index+1);</span><br><span class="line">        swap(array,index,i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void swap(int[] array,int i,int j)&#123;</span><br><span class="line">    int t=array[i];</span><br><span class="line">    array[i]=array[j];</span><br><span class="line">    array[j]=t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="字典排序"><a href="#字典排序" class="headerlink" title="字典排序"></a>字典排序</h1><ol><li>首先数组必须先自然排序，然后按照字典顺序递增，比如排序后的数组为array={1,2,3,4,5}，其递增如下。</li></ol><blockquote><p>1 2 3 4 5<br>1 2 3 5 4<br>1 2 4 3 5<br>1 2 4 5 3<br>1 2 5 3 4<br>1 2 5 4 3<br>1 3 2 4 5<br>…<br>1 3 5 4 2<br>1 4 2 3 5<br>…<br>5 4 3 2 1</p></blockquote><ol start="2"><li>数组从<code>12345</code>逐渐递增到<code>54321</code>。<ul><li>从<code>1 3 542</code>递增到<code>1 4 235</code>作为例子可以看到。</li><li>把<code>1 3 542</code>分为3部分，右边是已逆序化的<code>542</code>，中间是从右往左第一个非逆序化的<code>3</code>。</li><li>在<code>542</code>中取出刚好大于<code>3</code>的数字<code>4</code>，2个交换得到<code>1 4 532</code>。</li><li>将<code>532</code>反转得到自然排序得到<code>1 4 235</code>以实现整个数组的递增。</li></ul></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"> public static void permutation(int[] array)&#123;</span><br><span class="line">    //自然排序数组</span><br><span class="line">    Arrays.parallelSort(array);</span><br><span class="line">    System.out.println(Arrays.toString(array));</span><br><span class="line"></span><br><span class="line">    //循环递增</span><br><span class="line">    while(true)&#123;</span><br><span class="line">        //得到第一个非逆序化的索引，即中间部分。</span><br><span class="line">        int lessIndex = lessIndex(array);</span><br><span class="line"></span><br><span class="line">        //如果全部逆序化则退出。</span><br><span class="line">        if(lessIndex==-1) return;</span><br><span class="line"></span><br><span class="line">        //得到右边已逆序化中刚好大于array[lessIndex]的索引。</span><br><span class="line">        int greaterIndex = greaterIndex(array, lessIndex);</span><br><span class="line"></span><br><span class="line">        //递增</span><br><span class="line">        swap(array,lessIndex,greaterIndex);</span><br><span class="line">        reverse(array,lessIndex+1,array.length-1);</span><br><span class="line"></span><br><span class="line">        System.out.println(Arrays.toString(array));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">public static int lessIndex(int[] array)&#123;</span><br><span class="line">    int lessIndex=-1;</span><br><span class="line">    for(int i=array.length-2;i&gt;=0;i--)&#123;</span><br><span class="line">        if(array[i]&lt;array[i+1])&#123;</span><br><span class="line">            lessIndex=i;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return lessIndex;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static int greaterIndex(int[] array,int lessIndex)&#123;</span><br><span class="line">    int greaterIndex=-1;</span><br><span class="line">    for(int i=array.length-1;i&gt;lessIndex;i--)&#123;</span><br><span class="line">        if(array[i]&gt;array[lessIndex])&#123;</span><br><span class="line">            greaterIndex=i;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return greaterIndex;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void swap(int[] array,int i,int j)&#123;</span><br><span class="line">    int tmp=array[i];</span><br><span class="line">    array[i]=array[j];</span><br><span class="line">    array[j]=tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void reverse(int[] array,int start,int end)&#123;</span><br><span class="line">    for(int i=start,j=end;i&lt;j;i++,j--)&#123;</span><br><span class="line">        swap(array,i,j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>代理</title>
      <link href="/2018/10/12/%E4%BB%A3%E7%90%86/"/>
      <url>/2018/10/12/%E4%BB%A3%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="JDK代理"><a href="#JDK代理" class="headerlink" title="JDK代理"></a>JDK代理</h1><ol><li>JDK代理必须面向接口，因为最后Proxy.newProxyInstance生成的代理继承于Proxy，所以不能通过继承来实现代理。</li><li>Proxy代理的方法必须放在源类的接口里面，因为Proxy实现源类所有的接口。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">interface People&#123;</span><br><span class="line">    String toString();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Data</span><br><span class="line">class Student implements People&#123;</span><br><span class="line">    private String id;</span><br><span class="line">    private String name;</span><br><span class="line">    private int age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>Proxy属于动态代理，PeopleProxy是在运行时通过反射机制动态生成的代理类。</li><li>动态指的是在运行时可以根据所代理的类的不同生成不同的Proxy代理类，简单地说，不管被代理的类怎么变，Proxy代理类都可以不变应万变。</li><li>PeopleProxy通过私有字段InvocationHandler拦截器实现代理，它将通过反射机制拦截PeopleProxy的调用。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class PeopleProxy implements People&#123;</span><br><span class="line">    private InvocationHandler interceptor;</span><br><span class="line"></span><br><span class="line">    private static Method toStringMethod=People.getMethod(&quot;toString&quot;);</span><br><span class="line"></span><br><span class="line">    public String toString()&#123;</span><br><span class="line">        interceptor.invoke(this,toStringMethod,null);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="6"><li>origin是被代理的对象，即源类的实例，它作为拦截器的字段，而不直接包含在Proxy内。</li><li>invoke的参数，proxy是Proxy代理类，如果将proxy作为method.invoke的参数代替origin将出现死循环。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@AllArgsConstructor</span><br><span class="line">class Interceptor implements InvocationHandler &#123;</span><br><span class="line">    private Student origin;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;</span><br><span class="line">        System.out.println(&quot;before invocation...&quot;);</span><br><span class="line"></span><br><span class="line">        Object resultObject=method.invoke(origin,args);</span><br><span class="line"></span><br><span class="line">        return resultObject;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="8"><li>类的唯一是由类加载器加类全限名确定的，所以Proxy.newProxyInstance的第一参数是代理类的加载器，运行如下。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    Student student = new Student();</span><br><span class="line">    Interceptor interceptor = new Interceptor(student);</span><br><span class="line"></span><br><span class="line">    People people=(People)Proxy.newProxyInstance(Student.class.getClassLoader(),Student.class.getInterfaces(),interceptor);</span><br><span class="line"></span><br><span class="line">    System.out.println(people.toString());</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>before invocation…<br>Student(id=null, name=null, age=0)</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>设计模式</title>
      <link href="/2018/10/10/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
      <url>/2018/10/10/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">interface I&#123;</span><br><span class="line">    f();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class C&#123;</span><br><span class="line">    f();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Adapter extends C implements I&#123;&#125;</span><br><span class="line"></span><br><span class="line">public class Main&#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        Adapter adapter=new Adapter();</span><br><span class="line">        f(adapter);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void f(I i)&#123;</span><br><span class="line">        i.f();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>Effective Java</title>
      <link href="/2018/10/09/Effective-Java/"/>
      <url>/2018/10/09/Effective-Java/</url>
      
        <content type="html"><![CDATA[<h1 id="创建和销毁对象"><a href="#创建和销毁对象" class="headerlink" title="创建和销毁对象"></a>创建和销毁对象</h1><h2 id="考虑用静态工厂方法代替构造器"><a href="#考虑用静态工厂方法代替构造器" class="headerlink" title="考虑用静态工厂方法代替构造器"></a>考虑用静态工厂方法代替构造器</h2><p><strong>优点</strong></p><ol><li>有名称,能确切地描述正被返回的对象。</li><li>不必在每次调用的时候都创建一个新对象,可以控制实例实现Singleton或者使得不可变类能使用==操作符代替equals方法，从而提升性能。</li><li>可以返回原返回类型的任何子类型对象,可以隐藏底层的实现使API变得简洁。 <ul><li>静态工厂方法是服务提供者框架的基础，服务提供者框架包含3个组件：服务接口、提供者注册API和服务访问API,除此之外还有第4个可选的组件，服务提供者接口，默认是通过反射按照服务类名实例化。</li><li>对于JDBC来说，Connection是服务接口，DriverManager.registerDriver是提供者注册API，DriverManager.getConnection是服务访问API以及Driver就是服务提供者接口。</li></ul></li><li>创建参数化类型实例的时候，可以实现类型推导。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMap</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;K,V&gt; <span class="function">HashMap&lt;K,V&gt; <span class="title">newInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> HashMap&lt;K,V&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Map&lt;String,List&lt;String&gt;&gt; map=HashMap.newIntstance();</span><br></pre></td></tr></table></figure><p><strong>缺点</strong></p><ol><li>类如果不含public或protected的构造器，就不能子类化。</li><li>静态工厂方法和其他静态方法没有区别，在API文档中无法明确标志出来。常用名称：<ul><li>valueOf/of</li><li>getInstance/newInstance</li><li>getType/newType</li></ul></li></ol><h2 id="遇到多个构造器参数时要考虑用构建器"><a href="#遇到多个构造器参数时要考虑用构建器" class="headerlink" title="遇到多个构造器参数时要考虑用构建器"></a>遇到多个构造器参数时要考虑用构建器</h2><p><strong>重叠构造器模式</strong></p><ol><li>当参数过多时，代码会变得难编写，并且较难阅读。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String id)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(id,<span class="keyword">null</span>,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String id,String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(id,name,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String id,String name,<span class="keyword">int</span> age)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id=id;</span><br><span class="line">        <span class="keyword">this</span>.name=name;</span><br><span class="line">        <span class="keyword">this</span>.age=age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>JavaBeansm模式</strong></p><ol><li>通过setter设置参数，阅读容易，但构造过程被分割导致JavaBean在构造过程中可能处于不一致的状态。另外，JavaBeans模式也阻止了把类变成不可变的可能。</li></ol><p><strong>Builder模式</strong></p><ol><li>既保证了安全性，也有很好的可读性。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String id;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Student</span><span class="params">(Builder builder)</span></span>&#123;</span><br><span class="line">        id=builder.id;</span><br><span class="line">        name=builder.name;</span><br><span class="line">        age=builder.age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String id;</span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Builder <span class="title">id</span><span class="params">(String id)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.id=id;<span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> Builder <span class="title">name</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.name=name;<span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> Builder <span class="title">age</span><span class="params">(<span class="keyword">int</span> age)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.age=age;<span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Student <span class="title">build</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Student(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Student student=<span class="keyword">new</span> Student.Builder().id(<span class="string">"id"</span>).name(<span class="string">"name"</span>).age(<span class="number">1</span>).build();</span><br></pre></td></tr></table></figure><h2 id="用私有构造器或者枚举类型强化Singleton属性"><a href="#用私有构造器或者枚举类型强化Singleton属性" class="headerlink" title="用私有构造器或者枚举类型强化Singleton属性"></a>用私有构造器或者枚举类型强化Singleton属性</h2><p><strong>饿汉模式</strong></p><ol><li>没有限制的话，可以通过反射调用私有构造器。</li><li>由于反序列化时会创建一个新的实例，所以可序列化的Singleton类的实例字段必须都是transient。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Student INSTANCE=<span class="keyword">new</span> Student();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Student</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Student <span class="title">getInstance</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> INSTANCE;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>单个元素的枚举类型</strong></p><ol><li>无偿地提供序列化机制，绝对防止多次实例化。</li><li>单元数的枚举类型是实现Singleton的最佳方法。</li></ol><h2 id="通过私有构造器强化不可实例化的能力"><a href="#通过私有构造器强化不可实例化的能力" class="headerlink" title="通过私有构造器强化不可实例化的能力"></a>通过私有构造器强化不可实例化的能力</h2><ol><li>私有构造器不仅不能实例化，还不可以继承，可以防止子类实例化。</li></ol><h2 id="避免创建不必要的对象"><a href="#避免创建不必要的对象" class="headerlink" title="避免创建不必要的对象"></a>避免创建不必要的对象</h2><ol><li>要优先使用基本类型而不是装箱基本类型，要当心无意识的自动装箱。</li><li>适配器除了后被对象之外，没有其他状态信息，所以不需要创建多个适配器实例。</li></ol><h2 id="消除过期的对象引用"><a href="#消除过期的对象引用" class="headerlink" title="消除过期的对象引用"></a>消除过期的对象引用</h2><ol><li>内存泄漏极端情况下会导致磁盘交换，甚至会导致OutOfMemoryError。</li><li>清空对象引用应该是一种例外，而不是一种规范行为。</li><li>只要类是自己管理内存，就应该警惕内存泄漏问题。</li><li>内存泄漏的另一个常见来源是缓存。如果回调没有显式取消注册，它们就会积聚。</li><li>内存泄漏的第三个常见来源是监听器和其他回调。</li></ol><h2 id="避免使用终结方法"><a href="#避免使用终结方法" class="headerlink" title="避免使用终结方法"></a>避免使用终结方法</h2><ol><li>终结方法finalizer通常是不可预测的，也是危险的，一般情况下是不必要的。终结方法的缺点在于不能保证会被及时地执行，而且根本那就补保证它们会被执行。</li><li>如果未被捕获的异常在终结过程中被抛出来，那么异常会被忽略，终结过程也会终止。</li><li>使用终结方法会有非常严重的性能损失。</li><li>普通对象通过本地方法委托给本地对象，当普通对象回收时，GC不会发现本地对等体，如果本地对等体不拥有关键资源，则可以用终结方法回收。</li><li>子类的终结方法不会自动调用超类的终结方法。</li></ol><h1 id="对于所有对象都通用的方法"><a href="#对于所有对象都通用的方法" class="headerlink" title="对于所有对象都通用的方法"></a>对于所有对象都通用的方法</h1><ol><li>Object的非final方法：equals、hashCode、toString、clone和finalize。</li></ol><h2 id="覆盖equals时请遵守通用约定"><a href="#覆盖equals时请遵守通用约定" class="headerlink" title="覆盖equals时请遵守通用约定"></a>覆盖equals时请遵守通用约定</h2><p><strong>满足以下任何一个条件可以不覆盖equals方法</strong></p><ol><li>类的每个实例本质上都是唯一的。</li><li>不关心类是否提供了“逻辑相等”的测试功能。</li><li>超类已经覆盖了equals，从超类继承过来的行为对于子类也是合适的。</li><li>类的私有的或是包级私有的，可以确定它的equals方法永远不会被调用。</li></ol><p><strong>equals方法实现了等价关系</strong></p><ol><li>自反性。对于任何非null的引用值x，x.quals(x)必须返回true。</li><li>对称性。对于任何非null的引用值x和y，当且仅当y.equals(x)返回true时，x.equals(y)必须返回true。</li><li>传递性。对于任何非null的引用值x、y和z，如果x.equals(y)返回true，并且y.equals(z)也返回true，那么x.equals(z)也必须返回true。</li><li>一致性。对于任何非null的引用值x和y，只要equals的比较操作在对象中所用的信息没有被修改，多次调用x.equals(y)就会一致地返回true，或者一致地返回false。</li><li>对于任何非null的引用值x，x.equals(null)必须返回false。</li></ol><p><strong>等价与继承不可兼得</strong></p><ol><li>无法在扩展可实例化的类的同时，既增加新的值组件，同时又保留equals约定。</li><li>getClass可以完全隔离超类和子类，可以解决等价关系，但会导致超类的一些方法不能用于子类，破坏了继承关系。instanceof反之。</li><li>可以用复合代替继承，需要扩展值组件的类可以包含原类，并提供一个获得原类的视图方法。还有就是不混用超类和子类也可以避免问题，这和getClass速途同归。</li><li>抽象类的子类中增加新的值组件，不会违反equals约定。</li></ol><p><strong>高质量equals</strong></p><ol><li>使用==操作符检查“参数是否是对象引用”。性能优化。</li><li>使用isntanceof操作符检查“参数是否为对象的类型或子类”。同时也检查了参数非空。</li><li>把参数转换成正确的类型。</li><li>检查参数中的关键字段是否与该对象中对应的相匹配。float和double需要对NaN和-0.0等进行特殊处理。</li><li>检查等价关系。<ul><li>覆盖equals时总要覆盖hashCode。</li><li>不要企图让equals方法过于智能。</li><li>不要将equals声明中的Object对象替换成其他的类型。重写时参数类型必须是一样的，返回类型可以是子类型。</li></ul></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(o==<span class="keyword">this</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(!(o <span class="keyword">instanceof</span> Student)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        Student oStudent=(Student)o;</span><br><span class="line">        <span class="keyword">return</span> Objects.equals(id,oStudent.id)</span><br><span class="line">            &amp;&amp; Objects.equals(name,oStudent.name)</span><br><span class="line">            &amp;&amp; age==oStudent.age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="覆盖equals时总要覆盖hashCode"><a href="#覆盖equals时总要覆盖hashCode" class="headerlink" title="覆盖equals时总要覆盖hashCode"></a>覆盖equals时总要覆盖hashCode</h2><p><strong>Object规范</strong></p><ol><li>默认情况下，Object.hashCoe返回对象的内存地址。</li><li>如果2个对象的根据equals(Object)比较是相等的，那么hashCode方法返回的整数结果必须相等。</li><li>如果2个对象的根据equals(Object)比较是不相等的，那么hashCode方法返回的整数结果是不确定的。<ul><li>散列函数会倾向于为不相等的对象产生不相等的散列码。</li><li>HashMap有一项优化，将散列码缓存起来，如果散列码不匹配，则对象不相等。对于HashMap来说，没有覆盖hashCode的类的所有键都是不相等的。</li></ul></li></ol><p><strong>散列码的计算</strong></p><ol><li>简单的散列函数实现：<ul><li>hash=非零常数值，比如17。</li><li>boolean，f?1:0。</li><li>byte char short int，(int)f。</li><li>long，(int)(f^(f&gt;&gt;&gt;32))。</li><li>float，Float.floatToIntBits(f)。</li><li>double，Double.doubleToLongBits(f)，再从long-&gt;int。</li><li>Object，f==null?0:f.hashCode()。</li><li>Array，把每一个元素当做单独的字段。</li><li>循环计算，hash=31*hash+每一个字段的计算值。</li><li>return hash。</li><li>测试。</li></ul></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Studnet</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> hash=<span class="number">17</span>;</span><br><span class="line">        hash=<span class="number">31</span>*hash+id.hashCode();</span><br><span class="line">        hash=<span class="number">31</span>*hash+name.hashCode();</span><br><span class="line">        hash=<span class="number">31</span>*hash+age;</span><br><span class="line">        <span class="keyword">return</span> hash;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>散列码的计算必须排除equals比较计算中没有用到的任何域。之所以选择31奇素数，如果是偶数的话，乘法溢出会导致信息丢失，因为与2相乘等价于移位运算。而使用素数只是习惯使然，并且31可以很容易用移位和减法代替乘法，31*i==(i&lt;&lt;5)-i。</li><li>如果是不可变类，计算散列码的开销也比较大，可以考虑把散列码缓存在对象内部。如果类的大多数对象会被用做散列键，可以在实例的时候计算散列码，否则可以延迟初始化散列码。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//缓存，延迟初始化。</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> hashCode;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> hash=hashCode;</span><br><span class="line">    <span class="keyword">if</span>(hash==<span class="number">0</span>)&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> hash;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>不要试图从散列码计算中排除掉一个对象的关键部分来提高性能。</li></ol><h2 id="始终要覆盖toString"><a href="#始终要覆盖toString" class="headerlink" title="始终要覆盖toString"></a>始终要覆盖toString</h2><ol><li>默认显示“类名@hashCode”。</li><li>如果指定了格式，最好提供一个相匹配的静态工厂或者构造器，以便对象和字符串之间来回转换。Java类库的很多值类都采用了这种做法，包括BigInteger和BigDecimal和绝大多数的基本类型包装类。</li><li>指定了格式的缺点是必须始终如一地坚持。</li></ol><h2 id="谨慎地覆盖clone"><a href="#谨慎地覆盖clone" class="headerlink" title="谨慎地覆盖clone"></a>谨慎地覆盖clone</h2><ol><li>Object.clone是protected的，如果子类没有实现Cloneable，那么调用clone会抛出CloneNotSuportedException。</li><li>Object.clone是特殊的方法，它会通过反射将当前对象的所有字段进行浅拷贝。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Cloneable</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Student <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (Student)<span class="keyword">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>永远不要让客户去做任何类库能够替客户完成的事情。</li><li>如果想要实现深拷贝，可以递归地调用clone方法。</li><li>clone架构与final对象不兼容，final对象无法深拷贝。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Cloneable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String id=<span class="string">"id"</span>;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] scores;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Student <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        Student clone = (Student) <span class="keyword">super</span>.clone();</span><br><span class="line">        clone.scores=scores.clone();</span><br><span class="line">        <span class="keyword">return</span> clone;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>拷贝构造器或拷贝工厂代替Cloneeable/clone</strong></p><ol><li>另一个实现对象拷贝地好办法是提供一个拷贝构造器或拷贝工厂，拷贝构造器或拷贝工厂唯一的参数类型和返回的类型相同。这2种方法都比Cloneable/clone方法更具有优势。<ul><li>不用实现Cloneable，不用修改clone为public和它的返回类型。</li><li>不会抛出受检异常。</li><li>支持final对象。</li><li>不用类型转换。</li><li>返回类型有更多选择。</li></ul></li></ol><h2 id="考虑实现Comparable接口"><a href="#考虑实现Comparable接口" class="headerlink" title="考虑实现Comparable接口"></a>考虑实现Comparable接口</h2><p><strong>约定</strong></p><ol><li>x.compareTo(y)==-y.compareTo(x)。</li><li>比较关系是可传递的。</li><li>强烈建议(x.compareTo(y)==0)==(x.equals(y))。</li></ol><p><strong>compareTo与equals</strong></p><ol><li>依赖比较关系的类包括有序集合类PriorityQueue、TreeSet和TreeMap，以及工具类Collections和Arrays。</li><li>与equals不同，在跨越不同类的时候，compareTo可以不做比较。</li><li>除却例外，x.compareTo(y)==0和x.equals(y)是一致的。例外如，BigDecimal(“1.0”)和BigDecimal(“1.00”)，通过equals比较是不相等的，而通过compareTo比较是相等的。</li><li>Comparable接口是参数化的，因此compareTo方法不必进行类型检查和类型转换。</li><li>浮点的比较用Float.compare和Double.compare。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">double</span> d1, <span class="keyword">double</span> d2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (d1 &lt; d2) <span class="keyword">return</span> -<span class="number">1</span>; </span><br><span class="line">        <span class="keyword">if</span> (d1 &gt; d2) <span class="keyword">return</span> <span class="number">1</span>; </span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> thisBits    = Double.doubleToLongBits(d1);</span><br><span class="line">        <span class="keyword">long</span> anotherBits = Double.doubleToLongBits(d2);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> thisBits == anotherBits ?  <span class="number">0</span> : (thisBits &lt; anotherBits ? -<span class="number">1</span> : <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Student</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String id=<span class="string">"id"</span>;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Student o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result=id.compareTo(o.id);</span><br><span class="line">        <span class="keyword">if</span> (result!=<span class="number">0</span>) <span class="keyword">return</span> result;</span><br><span class="line">        </span><br><span class="line">        result=name.compareTo(o.name);</span><br><span class="line">        <span class="keyword">if</span> (result!=<span class="number">0</span>) <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> age-o.age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="类和接口"><a href="#类和接口" class="headerlink" title="类和接口"></a>类和接口</h1><h2 id="使类和成员的可访问性最小化"><a href="#使类和成员的可访问性最小化" class="headerlink" title="使类和成员的可访问性最小化"></a>使类和成员的可访问性最小化</h2><p><strong>封装</strong></p><ol><li>设计良好的模块会隐藏所有的实现细节，把API与实现清晰地隔离开来，这个概念称为信息隐藏或封装，是软件设计的基本原则之一。</li><li>封装可以有效地解除组成系统的各模块之间的耦合关系，使得这些模块可以独立地开发、测试、优化、使用、理解和修改。</li><li>顶层的类和接口只有2种可能的访问级别：包级私有的和公有的。默认是包级私有，作为包的实现的一部分，而公有则作为该包导出的API的一部分。</li><li>成员（字段、方法、嵌套类和嵌套接口）有4种可能的访问级别，按照可访问性递增顺序如下。<ul><li>私有的</li><li>包级私有的</li><li>受保护的（类导出的API）</li><li>公有的（类导出的API）</li></ul></li><li>子类重写的方法的访问级别不允许低于超类中访问级别，确保任何可使用超类的实例的地方也都可以使用子类的实例。</li></ol><p><strong>封装规则</strong></p><ol><li>尽可能地使每个类或者成员不被外界访问。</li><li>如果包级私有的顶层类或接口只是在某一个类的内部被用到，就应该考虑使它成为唯一使用它的那个类的私有嵌套类。</li><li>实例字段决不能是公有的。包含公有可变字段的类不是线程安全的。</li><li>静态字段也不能是公有的，有一种例外情况，假设常量是类抽象的一部分，可以通过public static final来暴露这些常量。很重要的一点是，这些常量要么包含基本类型的值，要么包含指向不可变对象的引用。</li><li>长度非0的数组总是可变的，所有，类具有公有的静态final数组字段，或者返回这种字段的访问方法，这几乎总是错误的，因为客户端能够修改数组中的内容。<ul><li>可以将数组变成私有的，并增加一个公有的不可变列表视图。</li><li>也可以将数组变成私有的，并添加一个公有方法访问数组的一个备份。</li></ul></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Student[] PRIVATE_STUDENTS=&#123;...&#125;;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> List&lt;Student&gt; STUDENTS=Collections.unmodifiableList(Arrays.asList(PRIVATE_STUDENTS));</span><br></pre></td></tr></table></figure><h2 id="在公有类中使用访问方法而非公有域"><a href="#在公有类中使用访问方法而非公有域" class="headerlink" title="在公有类中使用访问方法而非公有域"></a>在公有类中使用访问方法而非公有域</h2><ol><li>公有类永远都不应该暴露可变的字段。</li><li>如果类是包级私有的，或者是私有的嵌套类，因为只是实现的一部分而没有导出API，直接暴露它的字段并没有本质错误。</li></ol><h2 id="使可变性最小化"><a href="#使可变性最小化" class="headerlink" title="使可变性最小化"></a>使可变性最小化</h2><ol><li>Java类库的不可变类：String、基本类型的包装类，BigInteger和BigDecimal。</li></ol><p><strong>不可变类的5条规则</strong></p><ol><li>不要提供任何会修改对象状态的方法。</li><li>保证类不会被扩展。防止子类破坏类的不可变行为，一般做法是使这个类成为final。</li><li>使所有的字段都是final的。</li><li>使所有的字段都成功私有的。</li><li>确保对于任何可变组件的互斥访问。如果类具有指向可变对象的字段，必须确保类的客户端无法获得这些对象的引用。</li></ol><p><strong>不可变</strong></p><ol><li>不可变类的如果需要进行运算，会创建并返回新的实例，这种模式是函数式的做法。与之相对应的是更常见的过程式的或者命令式的做法。</li><li>不可变对象本质上是线程安全的，它们不要求同步。不可变对象可以被自由地共享，影应该鼓励客户端尽可能地重用现有的实例，最简单的办法就是，对于频繁用到的值，为它们提供public static final常量。静态工厂可以进一步把频繁被请求的实例缓存起来。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Complex ZERO=<span class="keyword">new</span> Complex(<span class="number">0</span>,<span class="number">0</span>);</span><br></pre></td></tr></table></figure><ol start="3"><li>不仅可以共享不可变对象，也可以共享它们的内部信息。</li><li>不可变类真正唯一的缺点是，对于每个不同的值都需要一个单独的对象。解决办法是提供一个公有的可变套配类，比如String的StringBuilder和基本上已经废弃的StringBuffer。</li><li>让不可变的类变成final的另一种做法就是，让类的所有构造器都变成私有的或者包级私有的（在包内同样可以继承），并添加公有的静态工厂。</li><li>除非有令人信服的理由要使字段变成是非final的，否则要使每个字段都是final的，限制它的可变性。不要再构造器或者静态工厂之外再提供公有的初始化方法，除非有令人信服的理由必须这么做。不应该提供重新初始化方法，重用和共享不可兼得。</li></ol><h2 id="复合优先于继承"><a href="#复合优先于继承" class="headerlink" title="复合优先于继承"></a>复合优先于继承</h2><ol><li>在包的内部使用继承是非常安全的，因为子类和超类的实现都处在同一个程序员的控制之下。对于专门为了继承而设计并且具有很好的文档说明的类来说，也是非常安全的。然而，对普通的具体类进行跨越包边界的继承，则是非常危险的。</li><li>继承打破了封装性，子类依赖于其超类中特定功能的实现细节，超类的实现可能会随着发行版本的不同而有所变化，子类可能会遭到破坏因而，子类必须跟着其超类的更新而演变，除非超类是专门为了扩展而设计的，并且具有很好的文档说明。</li></ol><p><strong>继承可能破坏依赖</strong></p><ol><li>超类的方法之间可能存在依赖，如果重写了其中的方法，可能破坏依赖关系。</li><li>超类在后续的发行版本中可能获得新的方法，子类可能无意识地重写了这个方法，这也将破坏依赖关系。</li></ol><p><strong>复合</strong></p><ol><li>复合将现有类作为私有字段实现扩展。新类的实例方法都可以调用被包含的现有类实例的对应的方法，并返回它的结果，这称为转发，新类的方法称为转发方法。</li><li>修饰模式是指每一个包装类实例都把另一个被包装类实例包装起来以增加特性。</li><li>只有当子类真正是超类的子类型时，存在is-a关系时才适合用继承。如果在适合使用复合的地方使用了继承，则会不必要地暴露实现细节和限制在原始的实现上。继承还会把缺陷传播到子类。</li></ol><h2 id="要么为继承为设计，并提供文档说明，要么就禁止继承。"><a href="#要么为继承为设计，并提供文档说明，要么就禁止继承。" class="headerlink" title="要么为继承为设计，并提供文档说明，要么就禁止继承。"></a>要么为继承为设计，并提供文档说明，要么就禁止继承。</h2><ol><li>类的文档必须精确地描述重写每个方法所带来的影响。</li><li>对于为了继承而设计的类，唯一的测试方法就是编写子类。</li><li>构造器决不能调用可被重写的方法。这样会导致子类中重写版本的方法将会在子类的构造器运行之前就先被调用。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">People</span><span class="params">()</span></span>&#123;</span><br><span class="line">        f();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">People</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name=<span class="string">"name"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Student student = <span class="keyword">new</span> Student(); <span class="comment">//打印 “null”</span></span><br><span class="line">        student.f(); <span class="comment">//打印 “name";</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>如果决定在一个为了继承而设计的类中实现Cloneable或Serializeble接口，应该意识到，clone和readObject方法在行为上非常类似于构造器，不能调用可重写的方法。</li></ol><h2 id="接口优于抽象类"><a href="#接口优于抽象类" class="headerlink" title="接口优于抽象类"></a>接口优于抽象类</h2><ol><li>JDK8开始，接口增加了默认方法和静态方法。</li><li>Java只允许单继承，而接口没有限制。</li><li>现有的类可以很容易被更新，以实现新的接口。</li><li>接口是定义mixin（混合类型）的理想选择。mixin类型表明提供了可供选择的行为，允许任选的功能可被混合到类型的主要功能中。比如Comparable允许类表明它的实例可以与其他的可互相比较的对象进行排序。</li><li>接口允许我们构造非层次结构的类型框架。</li></ol><p><strong>骨架实现与简单实现</strong></p><ol><li>骨架实现类比较简单，在接口中确定哪些方法是最为基本的，其他的方法可以根据它们来实现。这些基本方法将称为骨架实现类的抽象方法，而其他的方法提供具体的实现。骨架实现类是为了继承的目的而设计的。</li><li>简单实现，比如额AbstractMap和SimpleEntry，很像骨架实现，这是因为它实现了接口，并且是为了继承而设计的。但是区别在于它不是抽线的：它是最简单的可能的有效实现。你可以原封不动地使用，也可以看情况将它子类化。</li></ol><h2 id="接口只用于定义类型"><a href="#接口只用于定义类型" class="headerlink" title="接口只用于定义类型"></a>接口只用于定义类型</h2><ol><li>常量接口没有任何方法，只包含静态的final字段。常量接口模式是对接口的不良使用。类在内部使用某些常量，属于实现细节。</li><li>当类或接口的常量能看作枚举类型的成员，就应该用枚举类型。否则，应该使用不可实例化的工具类。</li></ol><h2 id="类层次优于标签类"><a href="#类层次优于标签类" class="headerlink" title="类层次优于标签类"></a>类层次优于标签类</h2><ol><li>标签类，实例有多种风格。缺点，多种风格实现混在一起，破坏了可读性，也让实例承担着属于其他风格不相关的字段。标签类过于冗长、容易出错，并且效率低下。</li></ol><h2 id="用函数对象表示策略"><a href="#用函数对象表示策略" class="headerlink" title="用函数对象表示策略"></a>用函数对象表示策略</h2><ol><li>函数对象可以作为参数，允许函数的调用者通过传入函数对象，来指定自己的行为。这称为策略模式。</li><li>Java中常用函数接口来实现函数对象，</li></ol><h2 id="优先考虑静态成员类"><a href="#优先考虑静态成员类" class="headerlink" title="优先考虑静态成员类"></a>优先考虑静态成员类</h2><ol><li>嵌套类存在的目的应该只是为它的外围类提供服务。嵌套类有4种：静态成员类、非静态成员类、匿名类和局部类。除了第1种外，其他3种都称为内部类,内部类不能有静态成员。</li><li>静态成员类是最简单的一种嵌套类，最好把它看作是普通的类，它可以访问外围类的所有成员，包括私有成员。静态成员类是外围类的一个静态成员，遵守同样的可访问性规则。</li><li>非静态成员类的每个实例都隐含着与外围类的一个外围实例相关联。在非静态成员类的实例方法内部，可以调用外围实例上的方法，或者利用修饰过的this获得外围实例的引用。在没有外围实例的情况下，是不可以创建非静态成员类的实例的。当非静态成员类的实例被创建时，它与外围类实例之间的关联关系就被建立起来，这会增加非静态成员类实例的开销。</li><li>如果声明成员类不要求访问外围实例，就要作为静态成员类。私有静态成员类的一种常见用法是用来代表外围类所代表的对象的组件。</li><li>匿名类在使用的时候同时声明和实例化。当且仅当匿名类出现在非静态的环境种，它才有外围实例。匿名类只有在声明的时候才可以实例化。<ul><li>匿名类的一种常见用法是动态地创建函数对象。</li><li>另一种常见用法是创建过程对象，比如Runnable、Thread或者TimerTask实例。</li><li>第三种常见用法是在静态工厂方法的内部。</li></ul></li><li>局部类是4种嵌套类中用得最少的类，和匿名类一样，只有当局部类是在非静态环境中定义的时候，才有外围实例。</li></ol><h1 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h1><h2 id="请不要在新代码中使用原生态类型"><a href="#请不要在新代码中使用原生态类型" class="headerlink" title="请不要在新代码中使用原生态类型"></a>请不要在新代码中使用原生态类型</h2><ol><li>数组的协变，数组之间和其元素类型有着一致的继承关系。如下，由于编译时只能确定引用的静态类型，fruits的静态类型是Fruit[]，所以可以编译通过。但是运行时可以知道数组的实际类型，所以会出现ArrayStoreException。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Fruit[] fruits=<span class="keyword">new</span> Apple[<span class="number">10</span>];</span><br><span class="line">fruits[<span class="number">0</span>]=<span class="keyword">new</span> Fruit();</span><br></pre></td></tr></table></figure><ol start="2"><li>所有泛型都是原生态类型的一个子类型，List<object>和List<string>之间没有继承关系，都是继承于List。</string></object></li><li>可以使用无限制的通配符类型<code>?</code>来代替原生态类型。原生态类型不安全，因为它可以包装所有的泛型子类型，然后擅自帮泛型添加元素，导致泛型在运行时可能会出现类型转换异常。List&lt;?&gt;用来代替List,表示不知道具体类型，所以不能限制存，只能存null，但不影响get。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Apple&gt; apples=<span class="keyword">new</span> ArrayList&lt;Apple&gt;();</span><br><span class="line">List list=apples;</span><br><span class="line"></span><br><span class="line"><span class="comment">//正常，因为泛型擦除，运行时只有List，但是泛型apples被破坏了。</span></span><br><span class="line">list.add(<span class="keyword">new</span> Orange()); </span><br><span class="line">list.get(<span class="number">0</span>); <span class="comment">//正常，返回Object。</span></span><br><span class="line">apples.get(<span class="number">0</span>); <span class="comment">//运行错误，泛型在运行时会自动进行类型转换。</span></span><br></pre></td></tr></table></figure><ol start="4"><li>由于类型擦除，在类字面量中只能用原生态类型，而且instanceof操作只能用原生类类型或者?通配符类型可以进行，</li></ol><h2 id="消除非受检警告"><a href="#消除非受检警告" class="headerlink" title="消除非受检警告"></a>消除非受检警告</h2><ol><li>如果无法消除警告，同时可以证明引起警告的代码是类型安全的，可以用@SuppressWarnings(“unchecked”)注解来禁止这条警告。每当使用注解时，都要添加一条注解。</li></ol><h2 id="列表优先于数组"><a href="#列表优先于数组" class="headerlink" title="列表优先于数组"></a>列表优先于数组</h2><p><strong>创建泛型数组是非法的</strong></p><ol><li>数组是协变的，就是数组和元素保持一致的继承性，因为继承性只能将类型检验延迟到运行时。相反泛型是不可变的，在编译时便可以进行类型检验，从而保证运行时的自动类型转换顺利进行。数组协变存在缺陷，因为类型检查应该在编译时进行的，防止运行时出现异常。</li><li>数组是具体化的，运行时有实际类型，而泛型通过擦除，运行时没有元素类型信息。</li><li>泛型数组不是类型安全的，如果创建泛型数组，泛型的类型擦除会让数组不能保存泛型的元素类型，从而可能导致运行时数组的类型检查失效，另外数组协变可以避过泛型的编译时类型检查，导致泛型在运行时的自动类型转换异常。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt;[] stringLists=<span class="keyword">new</span> List&lt;String&gt;[<span class="number">1</span>];</span><br><span class="line">Object[] objects=stringLists;</span><br><span class="line">objects[<span class="number">0</span>]=<span class="keyword">new</span> List&lt;Integer&gt;();</span><br><span class="line">stringLists[<span class="number">0</span>].get(<span class="number">0</span>);</span><br></pre></td></tr></table></figure><ol start="4"><li>List<e>和List<string>类似的类型是不可具体化的类型，在运行时不包含元素的类型信息，唯一可具体化的参数化类型是无限制的通配符类型。</string></e></li></ol><h2 id="优先考虑泛型"><a href="#优先考虑泛型" class="headerlink" title="优先考虑泛型"></a>优先考虑泛型</h2><ol><li>可以绕过创建泛型数组的禁令，先创建Object[]，然后转换成泛型数组。这种用法是合法的，但不是类型安全的。</li><li>将字段的类型改为Object[]，而获取元素时转换类型。更安全但是可能很繁琐，所以第1条更常用。</li></ol><h2 id="优先考虑泛型方法"><a href="#优先考虑泛型方法" class="headerlink" title="优先考虑泛型方法"></a>优先考虑泛型方法</h2><ol><li>泛型方法无需明确指定类型参数的值，可以通过类型推导确定。</li><li>类型限制，在声明定义时使用，作用是限制参数的类型。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Comparable&lt;T&gt;&gt; <span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(List&lt;T&gt; list)</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure><h2 id="利用有限制通配符来提升API的灵活性"><a href="#利用有限制通配符来提升API的灵活性" class="headerlink" title="利用有限制通配符来提升API的灵活性"></a>利用有限制通配符来提升API的灵活性</h2><ol><li>为了获得最大限度的灵活性，要在表示生产者或者消费者的输入参数上使用通配符类型。如果某个输入参数既是生产者又是消费者，就不能用通配符。PECS表示producer-extends，consumer-super。</li><li>不要用通配符类型作为返回类型，因为它会强制用户在客户端代码使用通配符类型，通配符对于类的用户应该是无形的。</li></ol><h2 id="优先考虑类型安全的异构容器"><a href="#优先考虑类型安全的异构容器" class="headerlink" title="优先考虑类型安全的异构容器"></a>优先考虑类型安全的异构容器</h2><ol><li>Map&lt;Class&lt;?&gt;,Object&gt;</li></ol><h1 id="枚举和注解"><a href="#枚举和注解" class="headerlink" title="枚举和注解"></a>枚举和注解</h1><h2 id="用enum代替int常量"><a href="#用enum代替int常量" class="headerlink" title="用enum代替int常量"></a>用enum代替int常量</h2><ol><li>Java枚举本质上是int值，基本思想是通过public static final字段为每个枚举常量导出实例的类。因为没有可以访问的构造器，所以枚举类型是真正的final，并且不能创建枚举类型的实例。</li><li>策略枚举，把策略选择作为枚举的一个私有的嵌套枚举，可以为上层的枚举选择策略，然后根据策略选择所做的操作委托给策略枚举。</li></ol><h2 id="用实例字段代替序数"><a href="#用实例字段代替序数" class="headerlink" title="用实例字段代替序数"></a>用实例字段代替序数</h2><ol><li>永远不要根据枚举的序数导出与它关联的值，而是要将它保存在一个实例字段中。</li></ol><h2 id="用EnumSet代替位字段"><a href="#用EnumSet代替位字段" class="headerlink" title="用EnumSet代替位字段"></a>用EnumSet代替位字段</h2><ol><li>位字段，能用OR位运算将多个常量合并表示集合的字段。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Text</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> BOLD=<span class="number">1</span> &lt;&lt; <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ITALIC=<span class="number">1</span> &lt;&lt; <span class="number">1</span>;</span><br><span class="line">    ... </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>EnumSet底层的枚举类型元素小于或等于64，那么整个EnumSet是用1个long来表示的。EnumSet的方法是采用位算法实现的。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Text</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">enum</span> Style&#123;</span><br><span class="line">        BOLD,ITATIC,...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">applyStyles</span><span class="params">(Set&lt;Style&gt; styles)</span></span></span><br><span class="line"><span class="function">&#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">text.<span class="title">applyStyles</span><span class="params">(EnumSet.of(Style.BOLD,style.ITALIC)</span>)</span>;</span><br></pre></td></tr></table></figure><h2 id="用EnumMap代替序数索引"><a href="#用EnumMap代替序数索引" class="headerlink" title="用EnumMap代替序数索引"></a>用EnumMap代替序数索引</h2><ol><li>最好不要用序数来索引数组，而要使用EnumMap。EnumMap比较简短、清楚，也更加安全。</li></ol><h2 id="用接口模拟可伸缩的枚举"><a href="#用接口模拟可伸缩的枚举" class="headerlink" title="用接口模拟可伸缩的枚举"></a>用接口模拟可伸缩的枚举</h2><ol><li>枚举不可以继承类，但是可以实现接口。枚举的构造函数不可以是public，因为枚举不可以通过构造函数实例化。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Operation</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">apply</span><span class="params">(<span class="keyword">double</span> x,<span class="keyword">double</span> y)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> BasicOperation implements Operation&#123;</span><br><span class="line">    PLUS(<span class="string">"+"</span>)&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">apply</span><span class="params">(<span class="keyword">double</span> x,<span class="keyword">double</span> y)</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> x+y;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String symbol;</span><br><span class="line">    BasicOperation(String symbol)&#123;</span><br><span class="line">        <span class="keyword">this</span>.symbol=symbol;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>虽然无法编写可扩展的枚举类型，却可以通过编写接口以及实现该接口的基础枚举类型，对它进行模拟。</li></ol><h2 id="注解优先于命名模式"><a href="#注解优先于命名模式" class="headerlink" title="注解优先于命名模式"></a>注解优先于命名模式</h2><ol><li>以前是用命名模式表明程序元素需要通过某种工具或框架进行特殊处理，比如测试方法名称要以test作为开头。<ul><li>如果文字拼错没有任何提示。</li><li>无法确保它们只用于相应的程序元素上。</li><li>没有提供将参数值与程序元素关联起来的好方法。</li></ul></li><li>有了注解，就完全没有理由再使用命名模式。大多数程序员都不必定义注解类型，但是所有的程序员都应该使用Java平台所提供的预定义的注解类型。</li></ol><h2 id="坚持使用Override注解"><a href="#坚持使用Override注解" class="headerlink" title="坚持使用Override注解"></a>坚持使用Override注解</h2><h2 id="用标记接口定义类型"><a href="#用标记接口定义类型" class="headerlink" title="用标记接口定义类型"></a>用标记接口定义类型</h2><ol><li>标记接口是没有包含方法声明的接口。</li><li>如果没有实现Serializable标记接口，ObjectOutputStream.write(Object)方法将会失败。</li><li>如果标记是应用到任何程序元素而不是类或者接口，就必须使用注解。如果需要作为相关方法的参数，那么优先使用接口，它可以为你提供编译时类型检查。</li></ol><h1 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h1><h2 id="检查参数的有效性"><a href="#检查参数的有效性" class="headerlink" title="检查参数的有效性"></a>检查参数的有效性</h2><ol><li>在文档中指明参数的限制，用Javadoc的@throws说明会抛出的异常，这些异常通常是IllegalArgumentException、IndexOutOfBoundsException或NullPointerException，并且在方法体的开头处检查参数。</li><li>对于未被导出的方法，即private和包级私有的方法，作为包的创建者，你应该确保只将有效的参数值传递进来。因此，这些方法应该用断言来检查它们的参数。如果没有将-ea标记传递给Java解释器，那么它们不会起作用，本质上也不会有成本开销。</li><li>有的参数，方法本身用到，却被保存起来供以后使用，检验这类参数的有效性尤为重要，比如构造器。</li></ol><h2 id="必要时进行保护性拷贝"><a href="#必要时进行保护性拷贝" class="headerlink" title="必要时进行保护性拷贝"></a>必要时进行保护性拷贝</h2><ol><li>Java是安全的语言，它对于缓冲区溢出、数组越界、非法指针以及其他的内存破坏错误都自动免疫。</li><li>对于构造器的每个可变参数进行保护性拷贝是必要的，使用备份作为实例字段，而不使用原始的对象。这时不应该检查原始参数的有效性，应该检查备份的有效性。<ul><li>如果参数是非final的，clone方法可能返回有专门处于恶意而设计的不可信子类。</li></ul></li><li>返回可变内部字段时考虑保护性拷贝。</li><li>如果不能容忍对象进入数据结构后发生变化，就要考虑保护性拷贝。</li><li>世事无绝对，如果信任客户端的话，也可以不用保护性拷贝。</li></ol><h2 id="谨慎设计方法签名"><a href="#谨慎设计方法签名" class="headerlink" title="谨慎设计方法签名"></a>谨慎设计方法签名</h2><ol><li>谨慎地选择方法的名称。</li><li>不要过于追求提供便利的方法。对于类和接口所支持的每个动作，都提供一个功能齐全的方法，只有当一项操作被经常用到的时候，才考虑为它提供快捷方式。</li><li>避免过长的参数列表。参数小于等于4个最好。<ul><li>正交分解方法。</li><li>创建分解类，一般位静态成员类，用来保存参数的分组。</li><li>结合前2种方法的特征，对象构建和方法调用都可以采用Builder方法，可以考虑定义一个对象来表示方法的所有参数。</li></ul></li><li>对于参数类型，要优先使用接口而不是类。解耦，容易扩展，支持更多实现。</li><li>对于boolean参数，要优先使用2个元素的枚举类型。它使代码更易阅读和编写，也使以后更易扩展。</li></ol><h2 id="慎用重载"><a href="#慎用重载" class="headerlink" title="慎用重载"></a>慎用重载</h2><ol><li>重载方法是在编译时做出决定的，由参数的静态类型决定，即静态分派，并且由所有参数决定，即静态多分派。</li><li>覆盖方法是在运行时做出决定的，由调用者的实际类型决定的，即动态分配，并且只由调用者单独决定，即动态单分派。</li><li>安全而保守的策略是，永远不要导出2个具有相同参数数目的重载方法。次之就是保证相同数目的参数的类型有明显的不同，即不能互相转换,这时需要注意基本类型和对应的包装类型。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list=<span class="keyword">new</span> ArrayList&lt;&gt;(Arrays.asList(<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">0</span>));</span><br><span class="line">list.remove(<span class="number">0</span>); <span class="comment">//index</span></span><br><span class="line">list.remove((Integer) <span class="number">0</span>); <span class="comment">//Object</span></span><br><span class="line"></span><br><span class="line">Set&lt;Integer&gt; set=<span class="keyword">new</span> HashSet&lt;&gt;(Arrays.asList(<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">0</span>));</span><br><span class="line">set.remove(<span class="number">0</span>); <span class="comment">//Object</span></span><br></pre></td></tr></table></figure><ol start="4"><li>如果2个重载方法在同样的参数上被调用时，它们执行相同的功能，返回相同的结果，重载就不会带来危害。这时候，更具体化的重载方法会把调用转发给更一般化的重载方法。</li></ol><h2 id="慎用可变参数"><a href="#慎用可变参数" class="headerlink" title="慎用可变参数"></a>慎用可变参数</h2><ol><li>可变参数方法接受0个或者多个指定类型的参数，会将这些参数转变成数组，0个参数时也会转变成数组，而不会是null。</li><li>没有参数时的检查只能在运行时，可以通过2个参数，1个是指定类型的参数，1个是可变参数，限制没有参数的发生。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">min</span><span class="params">(<span class="keyword">int</span> firstArg,<span class="keyword">int</span>... remainingArgs)</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>提供常用的重载方法可以提高可变参数的性能。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> a1)</span></span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> a1,<span class="keyword">int</span> a2)</span></span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> a1,<span class="keyword">int</span> a2,<span class="keyword">int</span> a3)</span></span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> a1,<span class="keyword">int</span> a2,<span class="keyword">int</span> a3,<span class="keyword">int</span> ...rest)</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure><h2 id="返回0长度的数组或者集合，而不是null。"><a href="#返回0长度的数组或者集合，而不是null。" class="headerlink" title="返回0长度的数组或者集合，而不是null。"></a>返回0长度的数组或者集合，而不是null。</h2><ol><li>0长度数组是不可变的，所以很可能被自由共享。</li><li>toArray数组参数的长度为0，指明所期望的返回类型，因为不能创建泛型数组，而可以通过参数创建具体的数组。如果toArray的数组参数的长度够长，则不会创建数组，采用数组参数并返回数组参数。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list= Arrays.asList(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line">Integer[] array=list.toArray(<span class="keyword">new</span> Integer[<span class="number">0</span>]);</span><br></pre></td></tr></table></figure><h2 id="为所有导出的API元素编写文档注释"><a href="#为所有导出的API元素编写文档注释" class="headerlink" title="为所有导出的API元素编写文档注释"></a>为所有导出的API元素编写文档注释</h2><ol><li>Javadoc利用特殊格式的文档注释，可以根据源代码自动产生API文档。</li><li>在每个被导出的类、接口、构造器、方法和字段声明之前增加一个文档注释。如果类是可序列化的，也应该对它的序列化形式编写文档。为了维护代码，还应该为没有导出的元素编写文档注释。</li><li>文档应该列举处方法的所有前提条件和后置条件。除此之外，还需要描述副作用，最后，也应该描述线程安全性。<ul><li>前提条件是指为了能够调用方法，必须满足的条件。由@param和@throws标签描述。</li><li>后置条件是指调用成功完成了后，哪些条件必须要满足。</li></ul></li><li>方法的每个参数都有1个@param标签，和1个@return标签，除非返回类型是void，对于抛出的异常，无论是受检还是非受检异常，都要1个@throws。</li><li>当为泛型类型编写文档时，要为所有的类型参数编写类型参数。当为枚举类型编写文档时，要确保在文档中说明常量，以及类型，还有任何公有的方法。为注解类型编写文档时，要确保在文档中说明所欲成员，以及类型本身。</li><li>包级私有的文档注释放在package-info.java的文件中。</li><li>Javadoc具有继承方法注释的能力，接口的文档注释优先于超类的。</li><li>在文档注释内部出现任何HTML标签都是允许的，但是HTML元字符必须要经过转义。</li></ol><h1 id="通用程序设计"><a href="#通用程序设计" class="headerlink" title="通用程序设计"></a>通用程序设计</h1><h2 id="将局部变量的作用域最小化"><a href="#将局部变量的作用域最小化" class="headerlink" title="将局部变量的作用域最小化"></a>将局部变量的作用域最小化</h2><ol><li>要使局部变量的作用域最小化，最有力的办法就是在第一次使用它的地方声明。</li><li>几乎每个局部变量的声明都应该包含一个初始化表达式。如果还没有足够的信息对一个变量进行有意义的初始化，就应该推迟这个声明。try例外。</li><li>循环中提供了特殊的机会来将变量的作用域最小化。如果循环终止之后不再需要循环变量的内容，for循环就优先于while循环。</li><li>最后一种将局部变量的作用域最小化的方法是使方法小而集中。</li></ol><h2 id="for-each循环优先于传统的for循环"><a href="#for-each循环优先于传统的for循环" class="headerlink" title="for-each循环优先于传统的for循环"></a>for-each循环优先于传统的for循环</h2><h2 id="了解和使用类库"><a href="#了解和使用类库" class="headerlink" title="了解和使用类库"></a>了解和使用类库</h2><ol><li>必须熟悉java.lang、java.util，一定程度上java.io也需要。java.util包种的集合框架和并发工具更是重要。</li><li>不要重复造轮子。</li></ol><h2 id="如果需要精确的答案，请避免使用float和double。"><a href="#如果需要精确的答案，请避免使用float和double。" class="headerlink" title="如果需要精确的答案，请避免使用float和double。"></a>如果需要精确的答案，请避免使用float和double。</h2><ol><li>float和double不适合货币计算，应该用BigDecimal，也可以用int和long用来表示以分做单位的货币。</li></ol><h2 id="基本类型优先于装箱基本类型"><a href="#基本类型优先于装箱基本类型" class="headerlink" title="基本类型优先于装箱基本类型"></a>基本类型优先于装箱基本类型</h2><ol><li>装箱基本类型默认值为null，如果null拆箱会抛出NullPointerException。</li><li>==运算符对2个装箱基本类型不会自动拆箱。</li></ol><h2 id="如果其他类型更适合，则尽量避免使用字符串。"><a href="#如果其他类型更适合，则尽量避免使用字符串。" class="headerlink" title="如果其他类型更适合，则尽量避免使用字符串。"></a>如果其他类型更适合，则尽量避免使用字符串。</h2><ol><li>字符串不适合代替其他的值类型。</li><li>字符串不适合代替枚举类型，枚举类型比字符串更加适合用来表示枚举类型的常量。</li><li>字符串不适合代替聚集类型。如果有多个组件，用类更合适。</li></ol><h2 id="当心字符串连接的性能"><a href="#当心字符串连接的性能" class="headerlink" title="当心字符串连接的性能"></a>当心字符串连接的性能</h2><ol><li>用StringBuilder或者字符数组可以提高性能。</li></ol><h2 id="通过接口引用对象"><a href="#通过接口引用对象" class="headerlink" title="通过接口引用对象"></a>通过接口引用对象</h2><h2 id="接口优先于反射机制"><a href="#接口优先于反射机制" class="headerlink" title="接口优先于反射机制"></a>接口优先于反射机制</h2><ol><li>java.lang.reflect反射机制提供了通过程序来访问已加载的类的信息的能力。给定一个Class实例，可以获得Constructor、Method和Field实例，通过它们可以访问底层对等体。</li><li>反射机制允许一个类使用另一个在编译时不存在的类。<ul><li>丧失了编译时类型检查的好处，在运行时可能会失败。</li><li>执行反射访问所需要的代码非常笨拙和冗长。</li><li>性能损失。</li></ul></li><li>普通应用程序在运行时不应该以反射方式访问对象。</li><li>对于有些程序，它们必须用到在编译时无法获取的类，但是在编译时存在适当的接口或者超类，就可以以反射的方式创建实例，然后通过它们的接口或者超类，以正常的方式访问这些实例。如果构造器不带参数，甚至不需要使用java.lang.reflect包，Class.newInstance方法就提供了所需的功能。</li></ol><h2 id="谨慎地使用本地方法"><a href="#谨慎地使用本地方法" class="headerlink" title="谨慎地使用本地方法"></a>谨慎地使用本地方法</h2><ol><li>本地方法是指本地程序设计语言，比如C或C++。<ul><li>提供访问特定于平台的机制，比如访问注册表和文件锁。</li><li>提供访问遗留代码库的能力，从而可以访问遗留数据。</li><li>可以提高系统性能。</li></ul></li><li>使用本地方法来提高性能的做法不值得提倡。因为JVM变得越来越快。而且很多本来本地方法才有的特性，Java也在不断完善。</li></ol><h2 id="谨慎地进行优化"><a href="#谨慎地进行优化" class="headerlink" title="谨慎地进行优化"></a>谨慎地进行优化</h2><ol><li>很多计算上的过失都被错误地归咎于效率。</li><li>不要去计较效率上的一些小小的得失。</li><li>在没有绝对清晰的优化方案之前，不要进行优化。</li><li>不要因为性能而牺牲合理的结构，要努力编写好的程序而不是快的程序，好的结构可以优化程序。</li><li>努力避免那些限制性能的设计决策。当一个系统设计完成之后，其中最难以更改的组件是那些指定了模块之间交互关系以及模块和外界交互关系的组件。主要是API、线路层协议以及永久数据格式。</li></ol><h2 id="遵守普遍接受的命名惯例"><a href="#遵守普遍接受的命名惯例" class="headerlink" title="遵守普遍接受的命名惯例"></a>遵守普遍接受的命名惯例</h2><ol><li>包的名称，可以包括小写字母和数字，很少使用数字。包的组成部分应该比较简短，通常不超过8个字符，鼓励使用有意义的缩写形式。虽然Java语言并没有支持包层次，但是包在设计的时候还是要按照层次结构划分。</li><li>类、接口、枚举和注解的名称，用驼峰形式，应该尽量避免用缩写。</li><li>方法和字段的名称，用小驼峰形式，也应该尽量避免用缩写。</li><li>常量的名称，用大写字母和下划线。</li><li>局部变量名称，和字段相似，只不过它允许缩写。</li><li>类型参数，T表示任意的类型，E表示集合的元素类型，K和V表示映射的键和值类型，X表示异常。任意类型的序列可以是T、U、V或者T1、T2、T3。</li><li>转换类型toType，返回视图asType，返回跟对象同值得基本类型的方法typeValue。</li></ol><h1 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h1><h2 id="只针对异常的情况才使用异常"><a href="#只针对异常的情况才使用异常" class="headerlink" title="只针对异常的情况才使用异常"></a>只针对异常的情况才使用异常</h2><ol><li>异常应该只用于异常的情况下，它们永远不应该用于正常的控制流。</li></ol><h2 id="对可恢复的情况使用受检异常，对编程错误使用运行时异常。"><a href="#对可恢复的情况使用受检异常，对编程错误使用运行时异常。" class="headerlink" title="对可恢复的情况使用受检异常，对编程错误使用运行时异常。"></a>对可恢复的情况使用受检异常，对编程错误使用运行时异常。</h2><ol><li>3种抛出结构：受检异常，运行时异常和错误。受检异常必须捕获处理。</li><li>运行时异常和错误，属于未受检异常，一般是不可恢复的情况，继续执行下去也是有害无益，所以不需要也不应该捕获。</li><li>运行时异常用来表明编程错误。自定义的未受检异常都应该继承RuntimeException。</li></ol><h2 id="避免不必要地使用受检的异常"><a href="#避免不必要地使用受检的异常" class="headerlink" title="避免不必要地使用受检的异常"></a>避免不必要地使用受检的异常</h2><h2 id="优先使用标准的异常"><a href="#优先使用标准的异常" class="headerlink" title="优先使用标准的异常"></a>优先使用标准的异常</h2><ol><li>最经常被重用的异常是IllegalArgumentException。另一个经常被重用的异常是IllegalStateException，因为接收对象的状态而使调用非法，比如对象被正确初始化之前就被使用。</li><li>所有的方法调用错误都可以归结于非法参数和非法状态，但还有一些更具体的异常，比如NullPointerException和IndexOutOfBoundsException。</li><li>ConcurrentModificationException，如果对象被设计成专门用于单线程或者于外部同步机制配合使用，一旦发现它正在或已经被并发地修改，抛出这个异常。</li><li>UnsupportedOperationException，如果对象不支持所请求的操作，就会抛出这个异常。</li><li>ArithmeticException和NumberFormatException。</li></ol><h2 id="抛出与抽象相对应的异常"><a href="#抛出与抽象相对应的异常" class="headerlink" title="抛出与抽象相对应的异常"></a>抛出与抽象相对应的异常</h2><ol><li>异常转译，高层的实现应该捕获底层的异常，同时抛出可以按照高层抽象进行解释的异常。</li><li>异常链，底层的异常作为原因被传到高层的异常，高层的异常提高访问方法来获得底层的异常。</li></ol><h2 id="每个方法抛出的异常都要有文档"><a href="#每个方法抛出的异常都要有文档" class="headerlink" title="每个方法抛出的异常都要有文档"></a>每个方法抛出的异常都要有文档</h2><h2 id="在细节消息中包含能捕获失败的信息"><a href="#在细节消息中包含能捕获失败的信息" class="headerlink" title="在细节消息中包含能捕获失败的信息"></a>在细节消息中包含能捕获失败的信息</h2><h2 id="努力使失败保持原子性"><a href="#努力使失败保持原子性" class="headerlink" title="努力使失败保持原子性"></a>努力使失败保持原子性</h2><ol><li>失败原子性，失败的方法调用应该使对象保持在被调用之前的状态。</li></ol><h2 id="不要忽略异常"><a href="#不要忽略异常" class="headerlink" title="不要忽略异常"></a>不要忽略异常</h2><h1 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h1><h2 id="同步访问共享的可变数据"><a href="#同步访问共享的可变数据" class="headerlink" title="同步访问共享的可变数据"></a>同步访问共享的可变数据</h2><ol><li>同步不仅可以阻止一个线程看到对象处于不一致的状态之中，它还可以保证进入同步方法或者同步代码块的每个线程，都看到由同一个锁保护的之前所有的修改效果。</li><li>语言规范保证读写变量是原子的，除非这个变量的类型为long或double，但是不保证一个线程写入的值对于另一个线程将是可见的。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//没有同步，done没有线程可见性。</span></span><br><span class="line"><span class="keyword">while</span>(!done)</span><br><span class="line">    i++;</span><br><span class="line"></span><br><span class="line"><span class="comment">//JVM优化。</span></span><br><span class="line"><span class="keyword">if</span>(!done)</span><br><span class="line">    <span class="keyword">while</span>(<span class="keyword">true</span>)</span><br><span class="line">        i++;</span><br></pre></td></tr></table></figure><ol start="3"><li>当多个线程共享可变数据的时候，每个读或者写数据的线程都必须执行同步，保证原子性和可见性。</li><li>活性失败，程序无法前进。安全性失败，程序会计算出错误的结果。</li></ol><h2 id="避免过度同步"><a href="#避免过度同步" class="headerlink" title="避免过度同步"></a>避免过度同步</h2><ol><li>同步区域内部，不要调用设计成要被覆盖的方法，或者是由客户端以函数对象的形式提供的方法。这些方法是外来的，调用它可能会导致死锁，异常或者数据损坏。比如，foreach遍历集合的时候，不可以同时修改集合，否则会发生ConcurrentModificationException。</li><li>Java的锁是可重入锁，可能会将活性失败变成安全性失败。</li><li>CopyOnWriteArrayList可以在foreach遍历集合的同时修改。通过重新拷贝整个底层数组来实现所有的写操作，由于内部数组永远不改动，因此迭代不需要锁定。</li><li>开放调用，在同步区域之外调用外来方法。这样可以避免死锁，也可以减少同步时间提高并发性。</li><li>通常，你应该在同步区域内做尽可能少的工作。</li></ol><h2 id="executor和task优先于线程"><a href="#executor和task优先于线程" class="headerlink" title="executor和task优先于线程"></a>executor和task优先于线程</h2><ol><li>小程序或者轻载服务器使用Executors.newCachedThreadPool，大负载服务器最好使用Executors.newFixedThreadPool，如果想最大限度地控制线程池使用ThreadPoolExecutor。</li><li>ScheduledThreadPoolExecutor用来代替Timer。</li></ol><h2 id="并发工具优先于wait和notify"><a href="#并发工具优先于wait和notify" class="headerlink" title="并发工具优先于wait和notify"></a>并发工具优先于wait和notify</h2><ol><li>java.util.concurrent中的高级工具分成3类：执行器，并发集合和同步器。</li><li>优先使用ConcurrentHashMap，而不是使用Collections.synchronizedMap或者Hashtable。只要用并发Map替换老式的同步Map，就可以提升并发应用程序的性能。</li><li>大多数ExecurotService实现包括ThreadPoolExecutor都使用BlockingQueue的生产者-消费者队列。</li><li>同步器的作用是使线程能够等待另一个线程，允许它们协调动作。最常用的同步器是CountDownLatch和Semaphone，较不常用的是CyclicBarrier和Exchanger。</li><li>不应该是使用wait和notify，如若不可避免，也应该在条件循环中调用wait方法，nofity和notifyAll可以唤醒等待线程，保守的建议是你总是应该使用notifyAll。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(!condition)</span><br><span class="line">    wait(); <span class="comment">//释放锁，加入等待队列。继续执行需要唤醒和锁，而且还需要再判断条件，因为很可能被nofifyAll过度唤醒。</span></span><br></pre></td></tr></table></figure><h2 id="线程安全性的文档化"><a href="#线程安全性的文档化" class="headerlink" title="线程安全性的文档化"></a>线程安全性的文档化</h2><ol><li>线程安全性的级别：<ul><li>不可变的immutable，实例是不变的，不需要外部的同步，例如String、Long和BigInteger。</li><li>无条件的线程安全unconditionally thread-safe，实例是可变的，但是类有着足够的内部通古比，不需要外部的同步，比如Random、ConcurrentHashMap。</li><li>有条件的线程安全conditionally thread-safe，与无条件的区别是有些方法为进行安全的并发使用而需要外部同步，例如Collections.synchronized包装的集合，它们的迭代器要求外部同步。</li><li>非线程安全not thread-safe，例如ArrayList和HashMap。</li><li>线程对立thread-hostile，即使有外部同步，也不能并发使用，线程对立的根源通常在于，没有同步地修改静态数据。</li></ul></li><li>公有可访问锁对象允许客户端同步地执行一个方法调用序列，但可能导致拒绝服务攻击。</li></ol><h2 id="慎用延迟初始化"><a href="#慎用延迟初始化" class="headerlink" title="慎用延迟初始化"></a>慎用延迟初始化</h2><ol><li>大多数的字段应该正常地进行初始化，除非了为了达到性能目标，或者为了破坏有害地初始化循环。</li><li>如果出于性能的考虑而需要对静态字段使用延迟初始化，就使用lazy initialization holder class模式，可以保证类要到被用到的时候才会被初始化。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">FieldHolder</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> FieldType field=<span class="keyword">new</span> FieldType();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//不需要同步</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> FieldType <span class="title">getField</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> FieldHolder.field;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>如果出于性能的考虑而需要对实例字段使用延迟初始化，就使用双重检查模式。静态字段也可以用这个模式，但不如上面介绍的模式好。如果可以接受重复初始化的实例字段，也可以考虑使用单重检查模式，而不需要同步。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> FieldType field;</span><br><span class="line"></span><br><span class="line"><span class="function">FiledType <span class="title">getField</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(field==<span class="keyword">null</span>)&#123; <span class="comment">//同步性能提升</span></span><br><span class="line">        <span class="keyword">synchronized</span>(<span class="keyword">this</span>)&#123; <span class="comment">//同步</span></span><br><span class="line">            <span class="keyword">if</span>(field==<span class="keyword">null</span>)&#123; <span class="comment">//延迟初始化</span></span><br><span class="line">                field=<span class="keyword">new</span> FieldType();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> field;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="不要依赖于线程调度器"><a href="#不要依赖于线程调度器" class="headerlink" title="不要依赖于线程调度器"></a>不要依赖于线程调度器</h2><ol><li>线程优先级是Java平台上最不可移植的特征了。</li><li>对于大多数程序员来说，Thread.yield的唯一用途是在测试期间人为地增加程序的并发性。</li></ol><h1 id="避免使用线程组"><a href="#避免使用线程组" class="headerlink" title="避免使用线程组"></a>避免使用线程组</h1><ol><li>线程组并没有提供太多有用的功能，而且它们提供的许多功能还都是有缺陷的。</li></ol><h1 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h1><h2 id="谨慎地实现Serializable接口"><a href="#谨慎地实现Serializable接口" class="headerlink" title="谨慎地实现Serializable接口"></a>谨慎地实现Serializable接口</h2><p><strong>实现Serializable的代价</strong></p><ol><li>实现Serializable接口而付出地最大代价是，一旦一个类被发布，就大大降低了“改变这个类的实现”的灵活性。</li><li>实现Serializable的第二个代价是，它增加了出现Bug和安全漏洞的可能性。反序列化机制是一个隐藏的构造器，具备与其他构造器相同的特点。</li><li>实现Serializable的第三个代价是，随着类发行新的版本，相关的测试负担也增加了。</li></ol><p><strong>注意</strong></p><ol><li>为了继承而设计的类应该尽可能少地去实现Serializable接口，用户的接口应该尽可能少地继承Serializable接口。在为了继承而设计的类中，真正实现了Serializable接口的有Throwable、Component和HttpServlet类，这样RMI的异常才可以从服务器端传到客户端，GUI才可以被发送、保存和恢复，会话状态可以被缓存。</li><li>内部类不应该实现Serializable，它们使用编译器产生的合成字段来保存只想外围实例的引用，以及保存来自外围作用域的局部变量的值。这些字段如何对应到类定义中没有明确的规定，因此，内部类的默认序列化形式是定义不清楚的。然而，静态成员类可以实现Serializable接口。</li></ol><h2 id="考虑使用自定义的序列化形式"><a href="#考虑使用自定义的序列化形式" class="headerlink" title="考虑使用自定义的序列化形式"></a>考虑使用自定义的序列化形式</h2><ol><li>接受默认的序列化形式是一个非常重要的决定，你需要从正确性、性能和灵活性多个角度对这种编码形式进行考察。</li><li>即使你确定了默认的序列化形式是合适的，通常还必须提供一个readObject方法以保证约束关系和安全性。</li></ol><p><strong>对象的物理表示法与它的逻辑数据内容有区别时</strong></p><ol><li>它将这个类的导出API永远地束缚在该类的内部表示法上。私有的StringList.Entry类变成了公有API的一部分，使得类永远也摆脱不掉维护链表项所需要的所有代码，即使它不再使用链表作为内部数据结构。</li><li>它会消耗过多的空间。序列化形式保存了实现细节的链接关系。</li><li>它会消耗过多的时间。序列化逻辑不了解对象图的拓扑关系，必须经过一个昂贵的突变里过程。</li><li>它会引起栈溢出。默认的序列化过程要对对象图执行一次递归遍历。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringList</span> <span class="keyword">implements</span> <span class="title">Serializable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line">    <span class="keyword">private</span> Entry head;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">implements</span> <span class="title">Serializable</span></span>&#123;</span><br><span class="line">        String data;</span><br><span class="line">        Entry next;</span><br><span class="line">        Entry previous;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>默认的序列化不能描述对象的逻辑状态时自定义序列化</strong></p><ol><li>transient修饰符表明这个实例字段将从一个类的默认序列化形式中省略掉。在反序列化的时候，这些字段将被初始化为默认值。</li><li>私有的writeObjet和readObject通过反射机制可以自定义序列化形式。defaultWriteObject和defaultReadObject可以方便以后的发行版本中增加非transient的实例字段。</li><li>序列化形式需要文档注释，哪怕是私有的也将作为API的一部分。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringList</span> <span class="keyword">implements</span> <span class="title">Serializable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">int</span> size;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> Entry head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//不再需要实现序列化接口，因为不用默认的序列化形式。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span></span>&#123;</span><br><span class="line">        String data;</span><br><span class="line">        Entry next;</span><br><span class="line">        Entry previous;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(ObjectOutputStream s)</span></span>&#123;</span><br><span class="line">        s.defaultWriteObject(); </span><br><span class="line">        s.wirteInt(size);</span><br><span class="line">        <span class="keyword">for</span>(Entry e=head,;e!=<span class="keyword">null</span>;e=e.next)&#123;</span><br><span class="line">            s.writeObject(e.data);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(ObjectInputStram s)</span></span>&#123;</span><br><span class="line">        s.defaultReadObject();</span><br><span class="line">        size=s.readInt();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;size;i++)&#123;</span><br><span class="line">            entry.add((String)s.readObject());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>不管你选择了哪种序列化形式，都要为你自己编写的每个可序列化的类声明一个显示的序列版本UID。</li></ol><h2 id="保护性地编写readObject"><a href="#保护性地编写readObject" class="headerlink" title="保护性地编写readObject"></a>保护性地编写readObject</h2><ol><li>readObject相当于另一个公有的构造器。构造器必须检查参数的有效性，必要的时候对参数进行保护性拷贝。</li><li>当一个对象被反序列化的时候，对于客户端不应该拥有的对象引用，如果哪个字段包含了这样的对象引用，就必须要做保护性拷贝。</li><li>readObject方法不可以调用可被覆盖的方法，不然被覆盖的方法将在子类的状态被反序列化之前先运行，程序很可能会失败。</li></ol><p><strong>健壮的readObject</strong></p><ol><li>对于对象引用域必须保持为私有的类，要保护性地拷贝这些域中的每个对象。不可变类的可变组件就属于这一类别。</li><li>对于任何约束条件，如果检查失败，则抛出一个InvalidObjectException异常。这些检查动作应该跟在所有的保护性拷贝之后。</li><li>如果整个对象图在被反序列化之后必须进行验证，就应该使用ObjectInputValidation接口。</li><li>无论是直接方式还是间接方式，都不要调用类中任何可被覆盖的方法。</li></ol><h2 id="对于实例控制，枚举类型优先于readResolve。"><a href="#对于实例控制，枚举类型优先于readResolve。" class="headerlink" title="对于实例控制，枚举类型优先于readResolve。"></a>对于实例控制，枚举类型优先于readResolve。</h2><ol><li>readObject不管是显示还是默认的，都会返回一个新建的实例，这个实例不同于该类初始化时创建的实例。</li><li>readResolve特性允许你用另一个实例代替readObject创建的实例。对于一个正在被反序列化的对象，如果它的类定义了一个readResolve方法，并且具备正确的声明，那么在反序列化之后，新建对象上的readResolve方法就会被调用。然后，该方法返回的对象引用将被返回，取代新建的对象，新建对象的引用不需要再被保留。</li><li>如果依赖readResolve进行实例控制，那么所有实例字段要么是基本类型，要么是transient。因为该方法忽略了被反序列化的对象，所以序列化形式并不需要包含任何是的数据。如果Singleton包含一个非transient对象引用字段，这个字段的内容就可以在Singleton的readResolve方法运行之前被反序列化，当对象引用字段的内容被反序列化时，它将允许一个精心制作的流盗用指向最初被反序列化的Singleton的引用。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">readResovle</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> INSTANCE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>如果readResolve是私有的，则不能继承，如果是保护的或者公有的，如果子类没有覆盖，那么反序列化后将会产生一个超类，导致ClassCastException。</li></ol><h2 id="考虑用序列化代理代替序列化实例"><a href="#考虑用序列化代理代替序列化实例" class="headerlink" title="考虑用序列化代理代替序列化实例"></a>考虑用序列化代理代替序列化实例</h2><ol><li>为可序列化的类设计一个私有的静态嵌套类，精确地表示外围类的实例的逻辑状态，这个嵌套类被称作序列化代理，它应该有一个单独的构造器，参数类型是外围类。</li><li>外围类添加writeReplace方法，在序列化之前，产生代理类实例代替外围类的实例。这样将永远不会产生外围类的序列化实例，为了防止伪造攻击，可以禁用readObject。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SerializationProxy</span> <span class="keyword">implements</span> <span class="title">Serializable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Date start;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Date end;</span><br><span class="line"></span><br><span class="line">    SerializationProxy(Period p)&#123;</span><br><span class="line">        <span class="keyword">this</span>.start=p.start;</span><br><span class="line">        <span class="keyword">this</span>.end=p.end;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Object <span class="title">readResolve</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Period(start,end);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">writeReplace</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span>  SerializationProxy(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(ObjectInputStream stream)</span> ObjectInputStream stream</span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> InvalidObjectException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>序列化代理方法的缺点是增加了开销，但是可以阻止为字节流的攻击以及内部字段的盗用攻击。这种方法允许Period的字段为final的。</li></ol>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>WebSocket</title>
      <link href="/2018/10/08/WebSocket/"/>
      <url>/2018/10/08/WebSocket/</url>
      
        <content type="html"><![CDATA[<h2 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a>WebSocket</h2><p>实现服务器和浏览器全双工通信。<br>使用ws和wss作为URL协议，默认使用80和443端口，HTTP状态码是101。</p><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ol><li>更强的实时性。服务器可以主动向客户端发送数据。</li><li>保持连接状态。创建连接后可以省略部分状态信息。 </li><li>较少的控制开销。协议控制的数据包头部较小。</li><li>更好的压缩效果。</li><li>更好的二进制支持。</li><li>可以支持扩展。</li></ol><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>推送技术所用的技术是轮询，Comet采用长连接实现轮询。</p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>Spring实战</title>
      <link href="/2018/10/08/Spring%E5%AE%9E%E6%88%98/"/>
      <url>/2018/10/08/Spring%E5%AE%9E%E6%88%98/</url>
      
        <content type="html"><![CDATA[<h1 id="Spring实战"><a href="#Spring实战" class="headerlink" title="Spring实战"></a>Spring实战</h1><h2 id="ApplicationContext：基于BeanFactory"><a href="#ApplicationContext：基于BeanFactory" class="headerlink" title="ApplicationContext：基于BeanFactory"></a>ApplicationContext：基于BeanFactory</h2><h2 id="bean的生命周期"><a href="#bean的生命周期" class="headerlink" title="bean的生命周期"></a>bean的生命周期</h2><ol><li>实例化</li><li>注入和Aware接口</li><li>BeanPostProcessor接口</li><li>InitializingBean接口或init-method方法</li><li>BeanPostProcessor接口</li><li>准备就绪和一直驻留ApplicationContext</li><li>DisposableBean接口或destroy-method方法</li></ol><h2 id="装配Bean"><a href="#装配Bean" class="headerlink" title="装配Bean"></a>装配Bean</h2><ul><li>隐式组件扫描和自动装配<ul><li>@Configuration</li><li>@ComponentScan @ComponentScan() @ComponentScan(basePackages=) @ComponentScan(basePackages={}) @ComponentScan(basePackageClasses={}) [类坐在的包]</li><li>@Component @Component()</li><li>@Autowired @Autowired(required=true) [构造器 Setter方法 字段（安全管理必须允许通过反射访问私有字段）]</li></ul></li><li>显式Java<ul><li>@Configuration</li><li>@Bean @Bean(name=)</li></ul></li><li>显式XML</li></ul><h3 id="JavaConfig引用其他配置"><a href="#JavaConfig引用其他配置" class="headerlink" title="JavaConfig引用其他配置"></a>JavaConfig引用其他配置</h3><ul><li>@Import(Class) @Import({})</li><li>@ImportResource(“xml”)</li></ul><h3 id="XML引用其他配置"><a href="#XML引用其他配置" class="headerlink" title="XML引用其他配置"></a>XML引用其他配置</h3><h2 id="高级装配"><a href="#高级装配" class="headerlink" title="高级装配"></a>高级装配</h2><ul><li>运行时值注入<ul><li>占位符 “${}”<ul><li>@PropertySource()</li><li>@Value(占位符) 必须配置PropertySourcesPlaceholderConfigurer</li></ul></li><li>SpEL Spring表达式语言 “#{}” #{3.14} #{‘hello’} #{true}<ol><li>使用bean的ID id.field id.method() ?.[可null]</li><li>调用方法和访问字段 T()[类]</li><li>算术^、关系、逻辑and or not |、条件？：[可判断null true没有表示不变]</li><li>正则表达式匹配 matches</li><li>集合操作[] .?[]过滤 .^[] .$[] .![]投影</li></ol></li></ul></li></ul><h2 id="junit测试"><a href="#junit测试" class="headerlink" title="junit测试"></a>junit测试</h2><ul><li>@RunWith(SpringJUnit4ClassRunner.class) 自动创建应用上下文</li><li>ContextConfiguration(classes=) </li></ul><h2 id="AOP-切面-切点-增强"><a href="#AOP-切面-切点-增强" class="headerlink" title="AOP 切面=切点+增强"></a>AOP 切面=切点+增强</h2><ul><li>EnableAspectJAutoProxy</li><li>@Aspect</li><li>@Pointcut</li></ul><h3 id="切点-选择方法-连接点"><a href="#切点-选择方法-连接点" class="headerlink" title="切点 选择方法(连接点)"></a>切点 选择方法(连接点)</h3><ul><li>execution(<em> pkg.class.method(..)) &amp;&amp; within(pkg.</em>) &amp;&amp; !bean(‘id’)</li><li>execution(* pkg.class.method(int)) &amp;&amp; args(增强参数)</li><li>指示器<ol><li>args()</li><li>@args()</li><li>execution()</li><li>this()</li><li>target()</li><li>@target()</li><li>within()</li><li>@within()</li><li>@annotation</li></ol></li></ul><h4 id="增强"><a href="#增强" class="headerlink" title="增强"></a>增强</h4><ul><li>@Before()</li><li>@After()</li><li>@AfterReturning()</li><li>@AfterThrowing()</li><li>@Around()<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Around()</span><br><span class="line">method(ProceedingJoinPoint jp)&#123;</span><br><span class="line">    ...</span><br><span class="line">    jp.proceed();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Spring标记</title>
      <link href="/2018/10/08/Spring%E6%A0%87%E8%AE%B0/"/>
      <url>/2018/10/08/Spring%E6%A0%87%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="The-IoC-container"><a href="#The-IoC-container" class="headerlink" title="The IoC container"></a>The IoC container</h1><h2 id="Bean-scopes"><a href="#Bean-scopes" class="headerlink" title="Bean scopes"></a>Bean scopes</h2><h3 id="RequestScope"><a href="#RequestScope" class="headerlink" title="@RequestScope"></a>@RequestScope</h3><ul><li>the @RequestScope annotation can be used to assign a component to the request scope.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@RequestScope</span><br><span class="line">@Component</span><br><span class="line">public class LoginAction &#123;</span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="SessionScope"><a href="#SessionScope" class="headerlink" title="@SessionScope"></a>@SessionScope</h3><ul><li>the @SessionScope annotation can be used to assign a component to the session scope.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@SessionScope</span><br><span class="line">@Component</span><br><span class="line">public class UserPreferences &#123;</span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="ApplicationScope"><a href="#ApplicationScope" class="headerlink" title="@ApplicationScope"></a>@ApplicationScope</h3><ul><li>the @ApplicationScope annotation can be used to assign a component to the application scope.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@ApplicationScope</span><br><span class="line">@Component</span><br><span class="line">public class AppPreferences &#123;</span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="Annotation-based-container-configuration"><a href="#Annotation-based-container-configuration" class="headerlink" title="Annotation-based container configuration"></a>Annotation-based container configuration</h2><h3 id="Requried"><a href="#Requried" class="headerlink" title="@Requried"></a>@Requried</h3><ul><li>The @Required annotation applies to bean property setter methods, as in the following example:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class SimpleMovieLister &#123;</span><br><span class="line"></span><br><span class="line">    private MovieFinder movieFinder;</span><br><span class="line"></span><br><span class="line">    @Required</span><br><span class="line">    public void setMovieFinder(MovieFinder movieFinder) &#123;</span><br><span class="line">        this.movieFinder = movieFinder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="Autowired"><a href="#Autowired" class="headerlink" title="@Autowired"></a>@Autowired</h3><ul><li><p>You can apply the @Autowired annotation to constructors:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class MovieRecommender &#123;</span><br><span class="line"></span><br><span class="line">    private final CustomerPreferenceDao customerPreferenceDao;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    public MovieRecommender(CustomerPreferenceDao customerPreferenceDao) &#123;</span><br><span class="line">        this.customerPreferenceDao = customerPreferenceDao;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>As expected, you can also apply the @Autowired annotation to “traditional” setter methods:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class SimpleMovieLister &#123;</span><br><span class="line"></span><br><span class="line">    private MovieFinder movieFinder;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    public void setMovieFinder(MovieFinder movieFinder) &#123;</span><br><span class="line">        this.movieFinder = movieFinder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>You can also apply the annotation to methods with arbitrary names and/or multiple arguments:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class MovieRecommender &#123;</span><br><span class="line"></span><br><span class="line">    private MovieCatalog movieCatalog;</span><br><span class="line"></span><br><span class="line">    private CustomerPreferenceDao customerPreferenceDao;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    public void prepare(MovieCatalog movieCatalog,</span><br><span class="line">            CustomerPreferenceDao customerPreferenceDao) &#123;</span><br><span class="line">        this.movieCatalog = movieCatalog;</span><br><span class="line">        this.customerPreferenceDao = customerPreferenceDao;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>You can apply @Autowired to fields as well and even mix it with constructors:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class MovieRecommender &#123;</span><br><span class="line"></span><br><span class="line">    private final CustomerPreferenceDao customerPreferenceDao;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private MovieCatalog movieCatalog;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    public MovieRecommender(CustomerPreferenceDao customerPreferenceDao) &#123;</span><br><span class="line">        this.customerPreferenceDao = customerPreferenceDao;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>It is also possible to provide all beans of a particular type from the ApplicationContext by adding the annotation to a field or method that expects an array of that type:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class MovieRecommender &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private MovieCatalog[] movieCatalogs;</span><br><span class="line"></span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>The same applies for typed collections:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class MovieRecommender &#123;</span><br><span class="line"></span><br><span class="line">    private Set&lt;MovieCatalog&gt; movieCatalogs;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    public void setMovieCatalogs(Set&lt;MovieCatalog&gt; movieCatalogs) &#123;</span><br><span class="line">        this.movieCatalogs = movieCatalogs;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Even typed Maps can be autowired as long as the expected key type is String. The Map values will contain all beans of the expected type, and the keys will contain the corresponding bean names:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class MovieRecommender &#123;</span><br><span class="line"></span><br><span class="line">    private Map&lt;String, MovieCatalog&gt; movieCatalogs;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    public void setMovieCatalogs(Map&lt;String, MovieCatalog&gt; movieCatalogs) &#123;</span><br><span class="line">        this.movieCatalogs = movieCatalogs;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>By default, the autowiring fails whenever zero candidate beans are available; the default behavior is to treat annotated methods, constructors, and fields as indicating required dependencies. This behavior can be changed as demonstrated below.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class SimpleMovieLister &#123;</span><br><span class="line"></span><br><span class="line">    private MovieFinder movieFinder;</span><br><span class="line"></span><br><span class="line">    @Autowired(required = false)</span><br><span class="line">    public void setMovieFinder(MovieFinder movieFinder) &#123;</span><br><span class="line">        this.movieFinder = movieFinder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Alternatively, you may express the non-required nature of a particular dependency through Java 8’s java.util.Optional:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class SimpleMovieLister &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    public void setMovieFinder(Optional&lt;MovieFinder&gt; movieFinder) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>As of Spring Framework 5.0, you may also use an @Nullable annotation (of any kind in any package, e.g. javax.annotation.Nullable from JSR-305):</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class SimpleMovieLister &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    public void setMovieFinder(@Nullable MovieFinder movieFinder) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>You can also use @Autowired for interfaces that are well-known resolvable dependencies: BeanFactory, ApplicationContext, Environment, ResourceLoader, ApplicationEventPublisher, and MessageSource. These interfaces and their extended interfaces, such as ConfigurableApplicationContext or ResourcePatternResolver, are automatically resolved, with no special setup necessary.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class MovieRecommender &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private ApplicationContext context;</span><br><span class="line"></span><br><span class="line">    public MovieRecommender() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Let’s assume we have the following configuration that defines firstMovieCatalog as the primary MovieCatalog.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class MovieConfiguration &#123;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    @Primary</span><br><span class="line">    public MovieCatalog firstMovieCatalog() &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public MovieCatalog secondMovieCatalog() &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>With such configuration, the following MovieRecommender will be autowired with the firstMovieCatalog.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class MovieRecommender &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private MovieCatalog movieCatalog;</span><br><span class="line"></span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="QUalifier"><a href="#QUalifier" class="headerlink" title="@QUalifier"></a>@QUalifier</h3><ul><li><p>@Primary is an effective way to use autowiring by type with several instances when one primary candidate can be determined. When more control over the selection process is required, Spring’s @Qualifier annotation can be used. You can associate qualifier values with specific arguments, narrowing the set of type matches so that a specific bean is chosen for each argument. In the simplest case, this can be a plain descriptive value:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class MovieRecommender &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    @Qualifier(&quot;main&quot;)</span><br><span class="line">    private MovieCatalog movieCatalog;</span><br><span class="line"></span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>The @Qualifier annotation can also be specified on individual constructor arguments or method parameters:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class MovieRecommender &#123;</span><br><span class="line"></span><br><span class="line">    private MovieCatalog movieCatalog;</span><br><span class="line"></span><br><span class="line">    private CustomerPreferenceDao customerPreferenceDao;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    public void prepare(@Qualifier(&quot;main&quot;)MovieCatalog movieCatalog,</span><br><span class="line">            CustomerPreferenceDao customerPreferenceDao) &#123;</span><br><span class="line">        this.movieCatalog = movieCatalog;</span><br><span class="line">        this.customerPreferenceDao = customerPreferenceDao;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>You can create your own custom qualifier annotations. Simply define an annotation and provide the @Qualifier annotation within your definition:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Target(&#123;ElementType.FIELD, ElementType.PARAMETER&#125;)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Qualifier</span><br><span class="line">public @interface Genre &#123;</span><br><span class="line"></span><br><span class="line">    String value();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Then you can provide the custom qualifier on autowired fields and parameters:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class MovieRecommender &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    @Genre(&quot;Action&quot;)</span><br><span class="line">    private MovieCatalog actionCatalog;</span><br><span class="line"></span><br><span class="line">    private MovieCatalog comedyCatalog;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    public void setComedyCatalog(@Genre(&quot;Comedy&quot;) MovieCatalog comedyCatalog) &#123;</span><br><span class="line">        this.comedyCatalog = comedyCatalog;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>In some cases, it may be sufficient to use an annotation without a value. This may be useful when the annotation serves a more generic purpose and can be applied across several different types of dependencies. For example, you may provide an offline catalog that would be searched when no Internet connection is available. First define the simple annotation:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Target(&#123;ElementType.FIELD, ElementType.PARAMETER&#125;)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Qualifier</span><br><span class="line">public @interface Offline &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Then add the annotation to the field or property to be autowired:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class MovieRecommender &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    @Offline</span><br><span class="line">    private MovieCatalog offlineCatalog;</span><br><span class="line"></span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>You can also define custom qualifier annotations that accept named attributes in addition to or instead of the simple value attribute. If multiple attribute values are then specified on a field or parameter to be autowired, a bean definition must match all such attribute values to be considered an autowire candidate. As an example, consider the following annotation definition:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Target(&#123;ElementType.FIELD, ElementType.PARAMETER&#125;)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Qualifier</span><br><span class="line">public @interface MovieQualifier &#123;</span><br><span class="line"></span><br><span class="line">    String genre();</span><br><span class="line"></span><br><span class="line">    Format format();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>In this case Format is an enum:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public enum Format &#123;</span><br><span class="line">    VHS, DVD, BLURAY</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>The fields to be autowired are annotated with the custom qualifier and include values for both attributes: genre and format.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class MovieRecommender &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    @MovieQualifier(format=Format.VHS, genre=&quot;Action&quot;)</span><br><span class="line">    private MovieCatalog actionVhsCatalog;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    @MovieQualifier(format=Format.VHS, genre=&quot;Comedy&quot;)</span><br><span class="line">    private MovieCatalog comedyVhsCatalog;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    @MovieQualifier(format=Format.DVD, genre=&quot;Action&quot;)</span><br><span class="line">    private MovieCatalog actionDvdCatalog;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    @MovieQualifier(format=Format.BLURAY, genre=&quot;Comedy&quot;)</span><br><span class="line">    private MovieCatalog comedyBluRayCatalog;</span><br><span class="line"></span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="Resource"><a href="#Resource" class="headerlink" title="@Resource"></a>@Resource</h3><ul><li><p>@Resource takes a name attribute, and by default Spring interprets that value as the bean name to be injected. In other words, it follows by-name semantics, as demonstrated in this example:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class SimpleMovieLister &#123;</span><br><span class="line"></span><br><span class="line">    private MovieFinder movieFinder;</span><br><span class="line"></span><br><span class="line">    @Resource(name=&quot;myMovieFinder&quot;)</span><br><span class="line">    public void setMovieFinder(MovieFinder movieFinder) &#123;</span><br><span class="line">        this.movieFinder = movieFinder;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>If no name is specified explicitly, the default name is derived from the field name or setter method. In case of a field, it takes the field name; in case of a setter method, it takes the bean property name. So the following example is going to have the bean with name “movieFinder” injected into its setter method:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class SimpleMovieLister &#123;</span><br><span class="line"></span><br><span class="line">    private MovieFinder movieFinder;</span><br><span class="line"></span><br><span class="line">    @Resource</span><br><span class="line">    public void setMovieFinder(MovieFinder movieFinder) &#123;</span><br><span class="line">        this.movieFinder = movieFinder;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Thus in the following example, the customerPreferenceDao field first looks for a bean named customerPreferenceDao, then falls back to a primary type match for the type CustomerPreferenceDao. The “context” field is injected based on the known resolvable dependency type ApplicationContext.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class MovieRecommender &#123;</span><br><span class="line"></span><br><span class="line">    @Resource</span><br><span class="line">    private CustomerPreferenceDao customerPreferenceDao;</span><br><span class="line"></span><br><span class="line">    @Resource</span><br><span class="line">    private ApplicationContext context;</span><br><span class="line"></span><br><span class="line">    public MovieRecommender() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="PostConstruct-and-PreDestroy"><a href="#PostConstruct-and-PreDestroy" class="headerlink" title="@PostConstruct and @PreDestroy"></a>@PostConstruct and @PreDestroy</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class CachingMovieLister &#123;</span><br><span class="line"></span><br><span class="line">    @PostConstruct</span><br><span class="line">    public void populateMovieCache() &#123;</span><br><span class="line">        // populates the movie cache upon initialization...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @PreDestroy</span><br><span class="line">    public void clearMovieCache() &#123;</span><br><span class="line">        // clears the movie cache upon destruction...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Classpath-scanning-and-managed-components"><a href="#Classpath-scanning-and-managed-components" class="headerlink" title="Classpath scanning and managed components"></a>Classpath scanning and managed components</h2><h3 id="Automatically-detecting-classes-and-registering-bean-definitions"><a href="#Automatically-detecting-classes-and-registering-bean-definitions" class="headerlink" title="Automatically detecting classes and registering bean definitions"></a>Automatically detecting classes and registering bean definitions</h3><ul><li><p>Spring can automatically detect stereotyped classes and register corresponding BeanDefinitions with the ApplicationContext. For example, the following two classes are eligible for such autodetection:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class SimpleMovieLister &#123;</span><br><span class="line"></span><br><span class="line">    private MovieFinder movieFinder;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    public SimpleMovieLister(MovieFinder movieFinder) &#123;</span><br><span class="line">        this.movieFinder = movieFinder;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Repository</span><br><span class="line">public class JpaMovieFinder implements MovieFinder &#123;</span><br><span class="line">    // implementation elided for clarity</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>To autodetect these classes and register the corresponding beans, you need to add @ComponentScan to your @Configuration class, where the basePackages attribute is a common parent package for the two classes. (Alternatively, you can specify a comma/semicolon/space-separated list that includes the parent package of each class.)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@ComponentScan(basePackages = &quot;org.example&quot;)</span><br><span class="line">public class AppConfig  &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>The following example shows the configuration ignoring all @Repository annotations and using “stub” repositories instead.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@ComponentScan(basePackages = &quot;org.example&quot;,</span><br><span class="line">        includeFilters = @Filter(type = FilterType.REGEX, pattern = &quot;.*Stub.*Repository&quot;),</span><br><span class="line">        excludeFilters = @Filter(Repository.class))</span><br><span class="line">public class AppConfig &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="Defining-bean-metadata-within-components"><a href="#Defining-bean-metadata-within-components" class="headerlink" title="Defining bean metadata within components"></a>Defining bean metadata within components</h3><ul><li><p>Spring components can also contribute bean definition metadata to the container. You do this with the same @Bean annotation used to define bean metadata within @Configuration annotated classes. Here is a simple example:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class FactoryMethodComponent &#123;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    @Qualifier(&quot;public&quot;)</span><br><span class="line">    public TestBean publicInstance() &#123;</span><br><span class="line">        return new TestBean(&quot;publicInstance&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void doWork() &#123;</span><br><span class="line">        // Component method implementation omitted</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Autowired fields and methods are supported as previously discussed, with additional support for autowiring of @Bean methods:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class FactoryMethodComponent &#123;</span><br><span class="line"></span><br><span class="line">    private static int i;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    @Qualifier(&quot;public&quot;)</span><br><span class="line">    public TestBean publicInstance() &#123;</span><br><span class="line">        return new TestBean(&quot;publicInstance&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // use of a custom qualifier and autowiring of method parameters</span><br><span class="line">    @Bean</span><br><span class="line">    protected TestBean protectedInstance(</span><br><span class="line">            @Qualifier(&quot;public&quot;) TestBean spouse,</span><br><span class="line">            @Value(&quot;#&#123;privateInstance.age&#125;&quot;) String country) &#123;</span><br><span class="line">        TestBean tb = new TestBean(&quot;protectedInstance&quot;, 1);</span><br><span class="line">        tb.setSpouse(spouse);</span><br><span class="line">        tb.setCountry(country);</span><br><span class="line">        return tb;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    private TestBean privateInstance() &#123;</span><br><span class="line">        return new TestBean(&quot;privateInstance&quot;, i++);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    @RequestScope</span><br><span class="line">    public TestBean requestScopedInstance() &#123;</span><br><span class="line">        return new TestBean(&quot;requestScopedInstance&quot;, 3);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class FactoryMethodComponent &#123;</span><br><span class="line"></span><br><span class="line">    @Bean @Scope(&quot;prototype&quot;)</span><br><span class="line">    public TestBean prototypeInstance(InjectionPoint injectionPoint) &#123;</span><br><span class="line">        return new TestBean(&quot;prototypeInstance for &quot; + injectionPoint.getMember());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Naming-autodetected-components"><a href="#Naming-autodetected-components" class="headerlink" title="Naming autodetected components"></a>Naming autodetected components</h3><ul><li>If such an annotation contains no name value or for any other detected component (such as those discovered by custom filters), the default bean name generator returns the uncapitalized non-qualified class name. For example, if the following component classes were detected, the names would be myMovieLister and movieFinderImpl:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Service(&quot;myMovieLister&quot;)</span><br><span class="line">public class SimpleMovieLister &#123;</span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br><span class="line">@Repository</span><br><span class="line">public class MovieFinderImpl implements MovieFinder &#123;</span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="Providing-a-scope-for-autodetected-components"><a href="#Providing-a-scope-for-autodetected-components" class="headerlink" title="Providing a scope for autodetected components"></a>Providing a scope for autodetected components</h3><ul><li>As with Spring-managed components in general, the default and most common scope for autodetected components is singleton. However, sometimes you need a different scope which can be specified via the @Scope annotation. Simply provide the name of the scope within the annotation:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Scope(&quot;prototype&quot;)</span><br><span class="line">@Repository</span><br><span class="line">public class MovieFinderImpl implements MovieFinder &#123;</span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="Java-based-contiainer-configuration"><a href="#Java-based-contiainer-configuration" class="headerlink" title="Java-based contiainer configuration"></a>Java-based contiainer configuration</h2><h3 id="Bean"><a href="#Bean" class="headerlink" title="@Bean"></a>@Bean</h3><ul><li><p>To declare a bean, simply annotate a method with the @Bean annotation. You use this method to register a bean definition within an ApplicationContext of the type specified as the method’s return value. By default, the bean name will be the same as the method name. The following is a simple example of a @Bean method declaration:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class AppConfig &#123;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public TransferServiceImpl transferService() &#123;</span><br><span class="line">        return new TransferServiceImpl();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>You may also declare your @Bean method with an interface (or base class) return type:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class AppConfig &#123;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public TransferService transferService() &#123;</span><br><span class="line">        return new TransferServiceImpl();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>A @Bean annotated method can have an arbitrary number of parameters describing the dependencies required to build that bean. For instance if our TransferService requires an AccountRepository we can materialize that dependency via a method parameter:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class AppConfig &#123;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public TransferService transferService(AccountRepository accountRepository) &#123;</span><br><span class="line">        return new TransferServiceImpl(accountRepository);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>The @Bean annotation supports specifying arbitrary initialization and destruction callback methods, much like Spring XML’s init-method and destroy-method attributes on the bean element:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public class Foo &#123;</span><br><span class="line"></span><br><span class="line">    public void init() &#123;</span><br><span class="line">        // initialization logic</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Bar &#123;</span><br><span class="line"></span><br><span class="line">    public void cleanup() &#123;</span><br><span class="line">        // destruction logic</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Configuration</span><br><span class="line">public class AppConfig &#123;</span><br><span class="line"></span><br><span class="line">    @Bean(initMethod = &quot;init&quot;)</span><br><span class="line">    public Foo foo() &#123;</span><br><span class="line">        return new Foo();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean(destroyMethod = &quot;cleanup&quot;)</span><br><span class="line">    public Bar bar() &#123;</span><br><span class="line">        return new Bar();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Of course, in the case of Foo above, it would be equally as valid to call the init() method directly during construction:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class AppConfig &#123;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public Foo foo() &#123;</span><br><span class="line">        Foo foo = new Foo();</span><br><span class="line">        foo.init();</span><br><span class="line">        return foo;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>The default scope is singleton, but you can override this with the @Scope annotation:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class MyConfiguration &#123;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    @Scope(&quot;prototype&quot;)</span><br><span class="line">    public Encryptor encryptor() &#123;</span><br><span class="line">        // ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>If you port the scoped proxy example from the XML reference documentation (see preceding link) to our @Bean using Java, it would look like the following:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// an HTTP Session-scoped bean exposed as a proxy</span><br><span class="line">@Bean</span><br><span class="line">@SessionScope</span><br><span class="line">public UserPreferences userPreferences() &#123;</span><br><span class="line">    return new UserPreferences();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Bean</span><br><span class="line">public Service userService() &#123;</span><br><span class="line">    UserService service = new SimpleUserService();</span><br><span class="line">    // a reference to the proxied userPreferences bean</span><br><span class="line">    service.setUserPreferences(userPreferences());</span><br><span class="line">    return service;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>By default, configuration classes use a @Bean method’s name as the name of the resulting bean. This functionality can be overridden, however, with the name attribute.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class AppConfig &#123;</span><br><span class="line"></span><br><span class="line">    @Bean(name = &quot;myFoo&quot;)</span><br><span class="line">    public Foo foo() &#123;</span><br><span class="line">        return new Foo();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>As discussed in Naming beans, it is sometimes desirable to give a single bean multiple names, otherwise known as bean aliasing. The name attribute of the @Bean annotation accepts a String array for this purpose.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class AppConfig &#123;</span><br><span class="line"></span><br><span class="line">    @Bean(name = &#123; &quot;dataSource&quot;, &quot;subsystemA-dataSource&quot;, &quot;subsystemB-dataSource&quot; &#125;)</span><br><span class="line">    public DataSource dataSource() &#123;</span><br><span class="line">        // instantiate, configure and return DataSource bean...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>To add a description to a @Bean the @Description annotation can be used:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class AppConfig &#123;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    @Description(&quot;Provides a basic example of a bean&quot;)</span><br><span class="line">    public Foo foo() &#123;</span><br><span class="line">        return new Foo();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="Using-the-Configuration-annotation"><a href="#Using-the-Configuration-annotation" class="headerlink" title="Using the @Configuration annotation"></a>Using the @Configuration annotation</h3><ul><li>When @Beans have dependencies on one another, expressing that dependency is as simple as having one bean method call another:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class AppConfig &#123;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public Foo foo() &#123;</span><br><span class="line">        return new Foo(bar());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public Bar bar() &#123;</span><br><span class="line">        return new Bar();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="Composing-Java-based-configurations"><a href="#Composing-Java-based-configurations" class="headerlink" title="Composing Java-based configurations"></a>Composing Java-based configurations</h3><ul><li><p>Much as the <import> element is used within Spring XML files to aid in modularizing configurations, the @Import annotation allows for loading @Bean definitions from another configuration class:</import></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class ConfigA &#123;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public A a() &#123;</span><br><span class="line">        return new A();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Configuration</span><br><span class="line">@Import(ConfigA.class)</span><br><span class="line">public class ConfigB &#123;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public B b() &#123;</span><br><span class="line">        return new B();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Fortunately, solving this problem is simple. As we already discussed, @Bean method can have an arbitrary number of parameters describing the bean dependencies. Let’s consider a more real-world scenario with several @Configuration classes, each depending on beans declared in the others:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class ServiceConfig &#123;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public TransferService transferService(AccountRepository accountRepository) &#123;</span><br><span class="line">        return new TransferServiceImpl(accountRepository);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Configuration</span><br><span class="line">public class RepositoryConfig &#123;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public AccountRepository accountRepository(DataSource dataSource) &#123;</span><br><span class="line">        return new JdbcAccountRepository(dataSource);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Configuration</span><br><span class="line">@Import(&#123;ServiceConfig.class, RepositoryConfig.class&#125;)</span><br><span class="line">public class SystemTestConfig &#123;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public DataSource dataSource() &#123;</span><br><span class="line">        // return new DataSource</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    ApplicationContext ctx = new AnnotationConfigApplicationContext(SystemTestConfig.class);</span><br><span class="line">    // everything wires up across configuration classes...</span><br><span class="line">    TransferService transferService = ctx.getBean(TransferService.class);</span><br><span class="line">    transferService.transfer(100.00, &quot;A123&quot;, &quot;C456&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>In cases where this ambiguity is not acceptable and you wish to have direct navigation from within your IDE from one @Configuration class to another, consider autowiring the configuration classes themselves:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class ServiceConfig &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private RepositoryConfig repositoryConfig;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public TransferService transferService() &#123;</span><br><span class="line">        // navigate &apos;through&apos; the config class to the @Bean method!</span><br><span class="line">        return new TransferServiceImpl(repositoryConfig.accountRepository());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Spring事务机制</title>
      <link href="/2018/10/08/Spring%E4%BA%8B%E5%8A%A1%E6%9C%BA%E5%88%B6/"/>
      <url>/2018/10/08/Spring%E4%BA%8B%E5%8A%A1%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="事务机制"><a href="#事务机制" class="headerlink" title="事务机制"></a>事务机制</h1><h2 id="事务的传播行为"><a href="#事务的传播行为" class="headerlink" title="事务的传播行为"></a>事务的传播行为</h2><ul><li>事务方法被另一个事务方法调用时，事务如何传播。</li></ul><ol><li>propagation_required</li></ol><ul><li>如果当前事务存在，加入当前事务。如果不存在事务，开启一个新的事务。</li></ul><ol start="2"><li>propagation_supports</li></ol><ul><li>如果当前事务存在，加入当前事务。如果不存在事务，非事务地执行。</li></ul><ol start="3"><li>propagation_mandatory<br>如果当前事务存在，加入当前事务。如果不存在事务，抛出异常。</li><li>propagation_requires_new</li></ol><ul><li>总是开启一个新的事务，并挂起任何存在的事务。内外层事务互相独立。</li><li>使用JtaTransactionManager作为事务管理器。</li></ul><ol start="5"><li>propagatrion_not_supported</li></ol><ul><li>总是非事务地执行，并挂起任何存在的事务。</li><li>使用JtaTransactionManager作为事务管理器。</li></ul><ol start="6"><li>propagation_never</li></ol><ul><li>总是非事务地执行。如果存在事务，抛出异常。</li></ul><ol start="7"><li>propagation_nested</li></ol><ul><li>类似propation_required。</li><li>内层事务依赖于外层事务。外层事务会回滚内层事务的动作。内层事务不会回滚外层事务。</li></ul><h2 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h2><ul><li>事务受其他并发事务影响的程度。</li></ul><ol><li>isolation_default</li></ol><ul><li>使用后端数据库默认的隔离级别。</li></ul><ol start="2"><li>isolation_read_uncommitted</li></ol><ul><li>允许读取未提交的数据。最低的隔离级别。</li><li>会导致脏读、不可重复读和幻读。</li></ul><ol start="3"><li>isolation_read_committed</li></ol><ul><li>允许读取并发事务已经提交的数据。</li><li>可以防止脏读，会导致不可重复读和幻读。</li></ul><ol start="4"><li>isolation_repeatable_read</li></ol><ul><li>会导致幻读。</li></ul><ol start="5"><li>isolation_serializable</li></ol><ul><li>最高也是最慢的隔离级别。通过锁定事务相关的数据库表来实现。</li></ul><h3 id="并发事务引起的问题"><a href="#并发事务引起的问题" class="headerlink" title="并发事务引起的问题"></a>并发事务引起的问题</h3><ol><li>脏读</li></ol><ul><li>还没提交的修改被其他事务读取了。事务自身没有原子性。</li></ul><ol start="2"><li>不可重复读</li></ol><ul><li>同一事务的多次相同查询得到不同的数据。事务之间没有原子性。</li></ul><ol start="3"><li>幻读</li></ol><ul><li><p>同一事务的多次相同查询记录数不同。事务之间没有原子性。</p></li><li><p>不可重复读和幻读的区别</p><ol><li>不可重复读重点是修改，幻读重点是增加和删除。</li><li>本质原因都是事务之间没有原子性。从控制的角度来看，修改只需锁住满足条件的记录，而增加和删除需要锁住满足条件及其相近的记录。</li></ol></li></ul><h2 id="只读事务"><a href="#只读事务" class="headerlink" title="只读事务"></a>只读事务</h2><ul><li>只读事务可以让数据库进行一些特定的优化。</li></ul><h2 id="事务超时"><a href="#事务超时" class="headerlink" title="事务超时"></a>事务超时</h2><ul><li>在特定事件内事务没有执行完毕就会自动回滚。</li></ul><h2 id="回滚规则"><a href="#回滚规则" class="headerlink" title="回滚规则"></a>回滚规则</h2><ul><li>默认情况下，事务遇到运行期异常才会回滚，而遇到受查型异常不会回滚。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Transactiona(propagation=Propagation.REQUIRES_NEW,isolation=Isolation.READ_COMMITTED,noRollbackFor=&#123;UserAccountException.class&#125;,readOnly=true, timeout=3)</span><br><span class="line">public void f()&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>高性能MySQL</title>
      <link href="/2018/10/08/%E9%AB%98%E6%80%A7%E8%83%BDMySQL/"/>
      <url>/2018/10/08/%E9%AB%98%E6%80%A7%E8%83%BDMySQL/</url>
      
        <content type="html"><![CDATA[<h1 id="MySQL架构"><a href="#MySQL架构" class="headerlink" title="MySQL架构"></a>MySQL架构</h1><h2 id="MySQL逻辑架构"><a href="#MySQL逻辑架构" class="headerlink" title="MySQL逻辑架构"></a>MySQL逻辑架构</h2><ol><li>连接/线程处理</li><li>查询缓存 解析器 优化器</li><li>存储引擎（InnoDB会解析外键定义）</li></ol><h2 id="并发控制"><a href="#并发控制" class="headerlink" title="并发控制"></a>并发控制</h2><ol><li>读写锁，读锁是共享锁，写锁是排他锁。</li><li>锁粒度<ol><li>表锁</li><li>行级锁</li></ol><ul><li>最大程度地支持并发处理，同时也带来了最大的锁开销。</li></ul></li></ol><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><ul><li><p>一组原子性地SQL查询</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">start transaction;</span><br><span class="line">...</span><br><span class="line">commit;</span><br></pre></td></tr></table></figure></li><li><p>事务处理系统具备ACID，A原子性，C一致性，I隔离性，D持久性。</p><ol><li>原子性</li></ol><ul><li>要么全部提交，要么全部回滚。</li></ul><ol start="2"><li>一致性</li></ol><ul><li>从一个一致性状态转换到另一个一致性状态。</li></ul><ol start="3"><li>隔离性</li></ol><ul><li>一个事务的修改在最终提交以前，对其他事务是不可见的。</li></ul><ol start="4"><li>持久性</li></ol><ul><li>一旦事务提交，所做的修改就会永久保存到数据库中。</li></ul></li></ul><h3 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set transaction isolation level read committed;</span><br><span class="line">set session transaction isolation level read committed;</span><br></pre></td></tr></table></figure><ol><li>read uncommitted 未提交读</li></ol><ul><li>事务中的修改，即使没有提交，对其他事务也都是可见的。</li><li>脏读：事务可以读取未提交的数据。</li><li>性能比其他级别不会好太多，却缺乏很多好处，很少使用。</li></ul><ol start="2"><li>read committed 提交读</li></ol><ul><li>事务只能看见已经提交的事务的修改。</li><li>大多数数据库的默认隔离级别，MySQL不是。</li><li>未提交事务就可以读取数据，导致一个事务内2次读取数据可能是不一样的，即保证了可见性却没有原子性。</li></ul><ol start="3"><li>repeatable read 可重复读</li></ol><ul><li>保证同一个事务中多次读取同样的记录的结果是一致的。</li><li>MySQL默认隔离级别。</li><li>不能解决幻读。</li></ul><ol start="4"><li>serializable 可串行化</li></ol><ul><li>最高的隔离级别，强制事务串行执行。</li><li>每一行数据都加锁，导致大量的超时和锁争用问题，很少使用。</li></ul><h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><ul><li>InnoDB处理死锁的方法，将持有最少行级排他锁的事务进行回滚。</li></ul><h3 id="事务日志"><a href="#事务日志" class="headerlink" title="事务日志"></a>事务日志</h3><ul><li>顺序I/O，速度快。</li></ul><h3 id="MySQL中的事务"><a href="#MySQL中的事务" class="headerlink" title="MySQL中的事务"></a>MySQL中的事务</h3><ul><li>事务型存储引擎：InnoDB和NDB Cluster。</li></ul><ol><li>自动提交</li></ol><ul><li>MySQL默认模式，autocommit=1。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">set autocommit=0;</span><br><span class="line">...</span><br><span class="line">commit;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>集合</title>
      <link href="/2018/10/08/%E9%9B%86%E5%90%88/"/>
      <url>/2018/10/08/%E9%9B%86%E5%90%88/</url>
      
        <content type="html"><![CDATA[<h1 id="CopyOnWriteArraySet"><a href="#CopyOnWriteArraySet" class="headerlink" title="CopyOnWriteArraySet"></a>CopyOnWriteArraySet</h1><ul><li>写操作需要复制整个数组，写开销大。</li><li>适合大小保持很小，读操作远多于写操作，需要在遍历期间防止线程间的冲突。</li><li>线程安全的。</li><li>迭代器不支持写操作。</li><li>迭代器速度快，不会和其他线程冲突。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Redis面试</title>
      <link href="/2018/10/08/Redis%E9%9D%A2%E8%AF%95/"/>
      <url>/2018/10/08/Redis%E9%9D%A2%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<h1 id="Redis作用"><a href="#Redis作用" class="headerlink" title="Redis作用"></a>Redis作用</h1><ol><li>缓存</li><li>list保存最新的数据 队列系统 lpush ltrim</li><li>zset保存权重最大的数据 优先级队列系统 zadd zrevrange zrank</li><li>set数据排重</li><li>清除过期数据</li><li>计数</li><li>subscribe/publish构建实时消息系统</li></ol>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>MyBatis面试</title>
      <link href="/2018/10/08/MyBatis%E9%9D%A2%E8%AF%95/"/>
      <url>/2018/10/08/MyBatis%E9%9D%A2%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<h1 id="MyBatis如何防止注入？"><a href="#MyBatis如何防止注入？" class="headerlink" title="MyBatis如何防止注入？"></a>MyBatis如何防止注入？</h1><ul><li>#{}是预编译处理，${}是字符串替换。</li><li>#{}可以防止SQL注入。</li></ul><h1 id="类的属性和表的字段不一样？"><a href="#类的属性和表的字段不一样？" class="headerlink" title="类的属性和表的字段不一样？"></a>类的属性和表的字段不一样？</h1><ol><li>定义字段的别名为属性名。</li><li>映射属性名和字段名。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;resultMap id=&quot;&quot; type=&quot;&quot;&gt;</span><br><span class="line">    &lt;id property=&quot;&quot; column=&quot;&quot;/&gt;</span><br><span class="line">    &lt;result property=&quot;&quot; column=&quot;&quot;/&gt;</span><br><span class="line">&lt;/resultMap&gt;</span><br></pre></td></tr></table></figure></li></ol><h1 id="获取自动生成的键值？"><a href="#获取自动生成的键值？" class="headerlink" title="获取自动生成的键值？"></a>获取自动生成的键值？</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;insert id=&quot;&quot; parameterType=&quot;&quot;&gt;</span><br><span class="line">    &lt;selectKey keyProperty=&quot;id&quot; order=&quot;AFTER&quot; resultType=&quot;int&quot;&gt;</span><br><span class="line">        select last_insert_id()</span><br><span class="line">    &lt;/selectKey&gt;</span><br><span class="line">    insert into...</span><br><span class="line">&lt;/insert&gt;</span><br></pre></td></tr></table></figure><h1 id="在mapper中传递多个参数？"><a href="#在mapper中传递多个参数？" class="headerlink" title="在mapper中传递多个参数？"></a>在mapper中传递多个参数？</h1><ol><li>使用占位符<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;select id=&quot;&quot; resultMap=&quot;&quot;&gt;</span><br><span class="line">    select * from t where id=#&#123;0&#125; and name=#&#123;1&#125;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public T f(@param(&quot;id&quot;) Integer id,@param(&quot;name&quot;) String name);</span><br><span class="line"></span><br><span class="line">&lt;select id=&quot;f&quot; resultType=&quot;T&quot;&gt;</span><br><span class="line">    select * from t where id=#&#123;id&#125; and name=#&#123;name&#125;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure><ol start="2"><li>使用Map集合参数</li><li>使用Bean参数</li></ol><h1 id="动态标签？"><a href="#动态标签？" class="headerlink" title="动态标签？"></a>动态标签？</h1><ul><li>在Xml映射文件内，已标签的形式编写动态SQL，完成逻辑判断和动态拼接SQL的功能。</li><li>9种标签：<ol><li>trim</li><li>where</li><li>set</li><li>foreach</li><li>if</li><li>choose</li><li>when</li><li>otherwise</li><li>bind</li></ol></li><li>原理：使用OGNL（Object-Graph Navigation Languag）计算表达式，根据表达式的值动态拼接SQL。</li></ul><h1 id="MyBatis不同的Xml映射文件中，id重复？"><a href="#MyBatis不同的Xml映射文件中，id重复？" class="headerlink" title="MyBatis不同的Xml映射文件中，id重复？"></a>MyBatis不同的Xml映射文件中，id重复？</h1><ul><li>定位=namespace+id</li><li>如果有namespace可以重复，如果没有配置namespace会导致覆盖。</li></ul><h1 id="MyBatis是半自动的ORM映射工具？"><a href="#MyBatis是半自动的ORM映射工具？" class="headerlink" title="MyBatis是半自动的ORM映射工具？"></a>MyBatis是半自动的ORM映射工具？</h1><ul><li>Hibernate是全自动ORM映射工具，查询关联对象或关联集合对象时，可以根据对象关系模型直接获取。</li><li>MyBatis则需要手动编写SQL。</li></ul><h1 id="一个Xml映射文件，需要一个Dao接口对应？Dao接口的方法能重载吗？"><a href="#一个Xml映射文件，需要一个Dao接口对应？Dao接口的方法能重载吗？" class="headerlink" title="一个Xml映射文件，需要一个Dao接口对应？Dao接口的方法能重载吗？"></a>一个Xml映射文件，需要一个Dao接口对应？Dao接口的方法能重载吗？</h1><ul><li>Dao接口，即Mapper接口，接口的全限名就是namespace，接口的方法名就是id，接口的参数就是传递给SQL的参数。</li><li>Mapper接口没有实现类，当调用接口方法时，会定位一个MappedStatement。</li><li>Dao接口里的方法不能重载。</li><li>Dao接口的工作原理：JDK动态代理，MyBatis运行时会使用JDK动态代理为Dao接口生成代理proxy对象，代理对象proxy会拦截接口方法，转而执行MappedStatement所代表的SQL。</li></ul><h1 id="接口绑定的实现方式？"><a href="#接口绑定的实现方式？" class="headerlink" title="接口绑定的实现方式？"></a>接口绑定的实现方式？</h1><ol><li>注解绑定</li><li>Xml绑定</li></ol><h1 id="MyBatis是如何分页的？分页插件的原理是什么？"><a href="#MyBatis是如何分页的？分页插件的原理是什么？" class="headerlink" title="MyBatis是如何分页的？分页插件的原理是什么？"></a>MyBatis是如何分页的？分页插件的原理是什么？</h1><ul><li>MyBatis使用RowBounds对象进行分页，RowBounds是针对ResultSet执行的内存分页，而非物理分页。</li><li>可以用SQL实现物理分页，也可以使用分页插件完成物理分页。</li><li>分页插件的基本原理:插件的拦截方法内拦截待执行的SQL，然后重写SQL，添加物理分页语句和物理分页参数。</li></ul><h1 id="MyBatis插件运行原理？"><a href="#MyBatis插件运行原理？" class="headerlink" title="MyBatis插件运行原理？"></a>MyBatis插件运行原理？</h1><ul><li>MyBatis仅可以编写针对ParameterHandler、ResultSetHandler、StatementHandler和Executor这4种接口的插件，MyBatis使用JDK的动态代理，为需要拦截的接口生成代理对象以实现接口方法拦截功能。</li></ul><h1 id="MyBatis延迟加载的实现原理？"><a href="#MyBatis延迟加载的实现原理？" class="headerlink" title="MyBatis延迟加载的实现原理？"></a>MyBatis延迟加载的实现原理？</h1><ul><li>MyBatis仅支持association和collection关联集合对象的延迟加载。</li><li>原理：使用cglib创建目标对象的代理对象，当调用目标方法时，进入拦截器方法，如果当拦截器方法发现字段是null值，就会单独发送事先保存好的查询，然后保存到对象的字段中。</li></ul><h1 id="MyBatis的Executor执行器？"><a href="#MyBatis的Executor执行器？" class="headerlink" title="MyBatis的Executor执行器？"></a>MyBatis的Executor执行器？</h1><ul><li>SimpleExecutor、ReuseExecutor和BatchExecutor</li></ul><ol><li>SimpleExecutor：每次执行一次update或select，开启一个Statement对象，用完立刻关闭Statement对象。</li><li>ReuseExecutor：执行update或select，以SQL作为key查找Statement对象，存在直接使用，不存在则创建，不关闭Statement对象而是在Map&lt;String,Statement&gt;内重复使用。</li><li>BatchExecutor：执行update（JDBC批处理不支持select），将sql添加到批处理中，等待统一执行executeBatch()。</li></ol>]]></content>
      
      
      <categories>
          
          <category> MyBatis </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>JDK8新特性</title>
      <link href="/2018/10/07/JDK8%E6%96%B0%E7%89%B9%E6%80%A7/"/>
      <url>/2018/10/07/JDK8%E6%96%B0%E7%89%B9%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<h1 id="Java语言"><a href="#Java语言" class="headerlink" title="Java语言"></a>Java语言</h1><h2 id="Lambda表达式与Functional接口"><a href="#Lambda表达式与Functional接口" class="headerlink" title="Lambda表达式与Functional接口"></a>Lambda表达式与Functional接口</h2><ul><li>访问局部变量时，会将变量隐式转换成常量。</li><li>接口的静态方法和默认方法不影响函数式接口。</li><li>@<em>FunctionalInterface</em>。</li></ul><h2 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h2><ul><li>方法引用用来支持Lambda简写。</li><li>构造器引用<em>T::new</em>，构造器本质上静态方法。</li><li>静态方法引用<em>T::staticMethod</em>。</li><li>类的任意对象的方法引用<em>T::Method</em>，第一个参数是对象。</li><li>对象的方法引用<em>O::Method</em>。</li></ul><h2 id="接口的静态方法与默认方法"><a href="#接口的静态方法与默认方法" class="headerlink" title="接口的静态方法与默认方法"></a>接口的静态方法与默认方法</h2><ul><li>接口的字段是<em>public static final</em>,接口的方法是<em>public</em>。</li><li>接口的方法新增<em>static</em>与<em>default</em>。</li></ul><h2 id="类型推测机制"><a href="#类型推测机制" class="headerlink" title="类型推测机制"></a>类型推测机制</h2><ul><li>List<t> list=new List&lt;&gt;();</t></li></ul><h2 id="重复注解"><a href="#重复注解" class="headerlink" title="重复注解"></a>重复注解</h2><ul><li>@R<em>epeatable</em>。</li></ul><h2 id="注解类型"><a href="#注解类型" class="headerlink" title="注解类型"></a>注解类型</h2><ul><li>field、constructor、method、parameter、local_variable、package和type(类、接口和enum)。</li></ul><h1 id="Java编译器"><a href="#Java编译器" class="headerlink" title="Java编译器"></a>Java编译器</h1><h2 id="参数名字"><a href="#参数名字" class="headerlink" title="参数名字"></a>参数名字</h2><ul><li>参数名字保存在Java字节码中，<em>javac -parameters</em>。</li></ul><h2 id="Java类库"><a href="#Java类库" class="headerlink" title="Java类库"></a>Java类库</h2><h2 id="Stream"><a href="#Stream" class="headerlink" title="Stream"></a>Stream</h2><ul><li>集合函数式编程</li></ul><h2 id="并行数组"><a href="#并行数组" class="headerlink" title="并行数组"></a>并行数组</h2><ul><li>数组并行处理。</li></ul><h2 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h2><ul><li>ConcurrentHashMap。<ol><li><em>取消段segments</em>，采用transient volatile hashEntry保存数据，实现<em>对每一行数据进行加锁</em>代替原来的段加锁，减少并发冲突。</li><li>数据结构改为<em>数组+单向链表+红黑树</em>。</li></ol></li><li>ForkJoinPool支持共有资源池。</li><li>容量锁StampedLock，代替ReadWriteLock。</li><li>atomic增加：<ol><li>DoubleAccumulator</li><li>DoubleAdder</li><li>LongAccumulator</li><li>LongAdder</li></ol></li></ul><h2 id="Optional"><a href="#Optional" class="headerlink" title="Optional"></a>Optional</h2><h2 id="Date-Time-API"><a href="#Date-Time-API" class="headerlink" title="Date/Time API"></a>Date/Time API</h2><ol><li>Clock</li></ol><ul><li>替换System.currentTimeMillis()和TimeZone.getDefault()。</li></ul><ol start="2"><li>LocaleDate LocalTime LocalDateTime</li></ol><ul><li>无时区。</li></ul><ol start="3"><li>ZonedDateTIme</li><li>Duration</li></ol><ul><li>时间差</li></ul><h2 id="JS引擎"><a href="#JS引擎" class="headerlink" title="JS引擎"></a>JS引擎</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ScriptEngineManager manager = new ScriptEngineManager();</span><br><span class="line">ScriptEngine engine = manager.getEngineByName( &quot;JavaScript&quot; );</span><br><span class="line">engine.eval( &quot;function f() &#123; return 1; &#125;; f() + 1;&quot; );</span><br></pre></td></tr></table></figure><h2 id="Base64"><a href="#Base64" class="headerlink" title="Base64"></a>Base64</h2><ul><li>编码。</li></ul><h1 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h1><h2 id="元空间Metaspace代替永久代PermGen"><a href="#元空间Metaspace代替永久代PermGen" class="headerlink" title="元空间Metaspace代替永久代PermGen"></a>元空间Metaspace代替永久代PermGen</h2><ul><li>字符串和静态变量转移到Java堆。</li><li>元空间使用本地内存而不在JVM中，元空间受本地内存限制，可以用-XX:MetaspaceSize -XX:MaxMetaspaceSize限制。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JDK8 </tag>
            
        </tags>
      
    </entry>
    
  
  
    
    <entry>
      <title></title>
      <link href="/baidu_verify_ysuwxPEgQM.html"/>
      <url>/baidu_verify_ysuwxPEgQM.html</url>
      
        <content type="html"><![CDATA[ysuwxPEgQM]]></content>
      
    </entry>
    
    <entry>
      <title></title>
      <link href="/googlea5bf63acdc3dbd82.html"/>
      <url>/googlea5bf63acdc3dbd82.html</url>
      
        <content type="html"><![CDATA[google-site-verification: googlea5bf63acdc3dbd82.html]]></content>
      
    </entry>
    
    <entry>
      <title>categories</title>
      <link href="/categories/index.html"/>
      <url>/categories/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    <entry>
      <title>tags</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
  
</search>
