<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>设计模式</title>
      <link href="/2018/10/10/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
      <url>/2018/10/10/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">interface I&#123;</span><br><span class="line">    f();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class C&#123;</span><br><span class="line">    f();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Adapter extends C implements I&#123;&#125;</span><br><span class="line"></span><br><span class="line">public class Main&#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        Adapter adapter=new Adapter();</span><br><span class="line">        f(adapter);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void f(I i)&#123;</span><br><span class="line">        i.f();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>Hello World</title>
      <link href="/2018/10/09/hello-world/"/>
      <url>/2018/10/09/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>Effective Java</title>
      <link href="/2018/10/09/Effective-Java/"/>
      <url>/2018/10/09/Effective-Java/</url>
      
        <content type="html"><![CDATA[<h1 id="创建和销毁对象"><a href="#创建和销毁对象" class="headerlink" title="创建和销毁对象"></a>创建和销毁对象</h1><h2 id="考虑用静态工厂方法代替构造器"><a href="#考虑用静态工厂方法代替构造器" class="headerlink" title="考虑用静态工厂方法代替构造器"></a>考虑用静态工厂方法代替构造器</h2><p><strong>优点</strong></p><ol><li>有名称,能确切地描述正被返回的对象。</li><li>不必在每次调用的时候都创建一个新对象,可以控制实例实现Singleton或者使得不可变类能使用==操作符代替equals方法，从而提升性能。</li><li>可以返回原返回类型的任何子类型对象,可以隐藏底层的实现使API变得简洁。 <ul><li>静态工厂方法是服务提供者框架的基础，服务提供者框架包含3个组件：服务接口、提供者注册API和服务访问API,除此之外还有第4个可选的组件，服务提供者接口，默认是通过反射按照服务类名实例化。</li><li>对于JDBC来说，Connection是服务接口，DriverManager.registerDriver是提供者注册API，DriverManager.getConnection是服务访问API以及Driver就是服务提供者接口。</li></ul></li><li>创建参数化类型实例的时候，可以实现类型推导。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class HashMap&#123;</span><br><span class="line">    public static &lt;K,V&gt; HashMap&lt;K,V&gt; newInstance()&#123;</span><br><span class="line">        return new HashMap&lt;K,V&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Map&lt;String,List&lt;String&gt;&gt; map=HashMap.newIntstance();</span><br></pre></td></tr></table></figure><p><strong>缺点</strong></p><ol><li>类如果不含public或protected的构造器，就不能子类化。</li><li>静态工厂方法和其他静态方法没有区别，在API文档中无法明确标志出来。常用名称：<ul><li>valueOf/of</li><li>getInstance/newInstance</li><li>getType/newType</li></ul></li></ol><h2 id="遇到多个构造器参数时要考虑用构建器"><a href="#遇到多个构造器参数时要考虑用构建器" class="headerlink" title="遇到多个构造器参数时要考虑用构建器"></a>遇到多个构造器参数时要考虑用构建器</h2><p><strong>重叠构造器模式</strong></p><ol><li>当参数过多时，代码会变得难编写，并且较难阅读。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class Student&#123;</span><br><span class="line">    private String id;</span><br><span class="line">    private String name;</span><br><span class="line">    private int age;</span><br><span class="line"></span><br><span class="line">    public Student(String id)&#123;</span><br><span class="line">        this(id,null,0);</span><br><span class="line">    &#125;</span><br><span class="line">    public Student(String id,String name)&#123;</span><br><span class="line">        this(id,name,0);</span><br><span class="line">    &#125;</span><br><span class="line">    public Student(String id,String name,int age)&#123;</span><br><span class="line">        this.id=id;</span><br><span class="line">        this.name=name;</span><br><span class="line">        this.age=age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>JavaBeansm模式</strong></p><ol><li>通过setter设置参数，阅读容易，但构造过程被分割导致JavaBean在构造过程中可能处于不一致的状态。另外，JavaBeans模式也阻止了把类变成不可变的可能。</li></ol><p><strong>Builder模式</strong></p><ol><li>既保证了安全性，也有很好的可读性。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">public class Student&#123;</span><br><span class="line">    private final String id;</span><br><span class="line">    private final String name;</span><br><span class="line">    private final int age;</span><br><span class="line"></span><br><span class="line">    private Student(Builder builder)&#123;</span><br><span class="line">        id=builder.id;</span><br><span class="line">        name=builder.name;</span><br><span class="line">        age=builder.age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static class Builder&#123;</span><br><span class="line">        private String id;</span><br><span class="line">        private String name;</span><br><span class="line">        private int age;</span><br><span class="line"></span><br><span class="line">        public Builder id(String id)&#123;</span><br><span class="line">            this.id=id;return this;</span><br><span class="line">        &#125;</span><br><span class="line">        public Builder name(String name)&#123;</span><br><span class="line">            this.name=name;return this;</span><br><span class="line">        &#125;</span><br><span class="line">        public Builder age(int age)&#123;</span><br><span class="line">            this.age=age;return this;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public Student build()&#123;</span><br><span class="line">            return new Student(this);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Student student=new Student.Builder().id(&quot;id&quot;).name(&quot;name&quot;).age(1).build();</span><br></pre></td></tr></table></figure><h2 id="用私有构造器或者枚举类型强化Singleton属性"><a href="#用私有构造器或者枚举类型强化Singleton属性" class="headerlink" title="用私有构造器或者枚举类型强化Singleton属性"></a>用私有构造器或者枚举类型强化Singleton属性</h2><p><strong>饿汉模式</strong></p><ol><li>没有限制的话，可以通过反射调用私有构造器。</li><li>由于反序列化时会创建一个新的实例，所以可序列化的Singleton类的实例字段必须都是transient。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class Student&#123;</span><br><span class="line">    private static final Student INSTANCE=new Student();</span><br><span class="line"></span><br><span class="line">    private Student()&#123;&#125;</span><br><span class="line">    public static Student getInstance()&#123;return INSTANCE;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>单个元素的枚举类型</strong></p><ol><li>无偿地提供序列化机制，绝对防止多次实例化。</li><li>单元数的枚举类型是实现Singleton的最佳方法。</li></ol><h2 id="通过私有构造器强化不可实例化的能力"><a href="#通过私有构造器强化不可实例化的能力" class="headerlink" title="通过私有构造器强化不可实例化的能力"></a>通过私有构造器强化不可实例化的能力</h2><ol><li>私有构造器不仅不能实例化，还不可以继承，可以防止子类实例化。</li></ol><h2 id="避免创建不必要的对象"><a href="#避免创建不必要的对象" class="headerlink" title="避免创建不必要的对象"></a>避免创建不必要的对象</h2><ol><li>要优先使用基本类型而不是装箱基本类型，要当心无意识的自动装箱。</li><li>适配器除了后被对象之外，没有其他状态信息，所以不需要创建多个适配器实例。</li></ol><h2 id="消除过期的对象引用"><a href="#消除过期的对象引用" class="headerlink" title="消除过期的对象引用"></a>消除过期的对象引用</h2><ol><li>内存泄漏极端情况下会导致磁盘交换，甚至会导致OutOfMemoryError。</li><li>清空对象引用应该是一种例外，而不是一种规范行为。</li><li>只要类是自己管理内存，就应该警惕内存泄漏问题。</li><li>内存泄漏的另一个常见来源是缓存。如果回调没有显式取消注册，它们就会积聚。</li><li>内存泄漏的第三个常见来源是监听器和其他回调。</li></ol><h2 id="避免使用终结方法"><a href="#避免使用终结方法" class="headerlink" title="避免使用终结方法"></a>避免使用终结方法</h2><ol><li>终结方法finalizer通常是不可预测的，也是危险的，一般情况下是不必要的。终结方法的缺点在于不能保证会被及时地执行，而且根本那就补保证它们会被执行。</li><li>如果未被捕获的异常在终结过程中被抛出来，那么异常会被忽略，终结过程也会终止。</li><li>使用终结方法会有非常严重的性能损失。</li><li>普通对象通过本地方法委托给本地对象，当普通对象回收时，GC不会发现本地对等体，如果本地对等体不拥有关键资源，则可以用终结方法回收。</li><li>子类的终结方法不会自动调用超类的终结方法。</li></ol><h1 id="对于所有对象都通用的方法"><a href="#对于所有对象都通用的方法" class="headerlink" title="对于所有对象都通用的方法"></a>对于所有对象都通用的方法</h1><ol><li>Object的非final方法：equals、hashCode、toString、clone和finalize。</li></ol><h2 id="覆盖equals时请遵守通用约定"><a href="#覆盖equals时请遵守通用约定" class="headerlink" title="覆盖equals时请遵守通用约定"></a>覆盖equals时请遵守通用约定</h2><p><strong>满足以下任何一个条件可以不覆盖equals方法</strong></p><ol><li>类的每个实例本质上都是唯一的。</li><li>不关心类是否提供了“逻辑相等”的测试功能。</li><li>超类已经覆盖了equals，从超类继承过来的行为对于子类也是合适的。</li><li>类的私有的或是包级私有的，可以确定它的equals方法永远不会被调用。</li></ol><p><strong>equals方法实现了等价关系</strong></p><ol><li>自反性。对于任何非null的引用值x，x.quals(x)必须返回true。</li><li>对称性。对于任何非null的引用值x和y，当且仅当y.equals(x)返回true时，x.equals(y)必须返回true。</li><li>传递性。对于任何非null的引用值x、y和z，如果x.equals(y)返回true，并且y.equals(z)也返回true，那么x.equals(z)也必须返回true。</li><li>一致性。对于任何非null的引用值x和y，只要equals的比较操作在对象中所用的信息没有被修改，多次调用x.equals(y)就会一致地返回true，或者一致地返回false。</li><li>对于任何非null的引用值x，x.equals(null)必须返回false。</li></ol><p><strong>等价与继承不可兼得</strong></p><ol><li>无法在扩展可实例化的类的同时，既增加新的值组件，同时又保留equals约定。</li><li>getClass可以完全隔离超类和子类，可以解决等价关系，但会导致超类的一些方法不能用于子类，破坏了继承关系。instanceof反之。</li><li>可以用复合代替继承，需要扩展值组件的类可以包含原类，并提供一个获得原类的视图方法。还有就是不混用超类和子类也可以避免问题，这和getClass速途同归。</li><li>抽象类的子类中增加新的值组件，不会违反equals约定。</li></ol><p><strong>高质量equals</strong></p><ol><li>使用==操作符检查“参数是否是对象引用”。性能优化。</li><li>使用isntanceof操作符检查“参数是否为对象的类型或子类”。同时也检查了参数非空。</li><li>把参数转换成正确的类型。</li><li>检查参数中的关键字段是否与该对象中对应的相匹配。float和double需要对NaN和-0.0等进行特殊处理。</li><li>检查等价关系。<ul><li>覆盖equals时总要覆盖hashCode。</li><li>不要企图让equals方法过于智能。</li><li>不要将equals声明中的Object对象替换成其他的类型。重写时参数类型必须是一样的，返回类型可以说子类型。</li></ul></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class Student&#123;</span><br><span class="line">    private String id;</span><br><span class="line">    private String name;</span><br><span class="line">    private int age;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean equals(Object o)&#123;</span><br><span class="line">        if(o==this) return true;</span><br><span class="line">        if(!(o instanceof Student)) return false;</span><br><span class="line">        Student oStudent=(Student)o;</span><br><span class="line">        return Objects.equals(id,oStudent.id)</span><br><span class="line">            &amp;&amp; Objects.equals(name,oStudent.name)</span><br><span class="line">            &amp;&amp; age==oStudent.age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="覆盖equals时总要覆盖hashCode"><a href="#覆盖equals时总要覆盖hashCode" class="headerlink" title="覆盖equals时总要覆盖hashCode"></a>覆盖equals时总要覆盖hashCode</h2><p><strong>Object规范</strong></p><ol><li>默认情况下，Object.hashCoe返回对象的内存地址。</li><li>如果2个对象的根据equals(Object)比较是相等的，那么hashCode方法返回的整数结果必须相等。</li><li>如果2个对象的根据equals(Object)比较是不相等的，那么hashCode方法返回的整数结果是不确定的。<ul><li>散列函数会倾向于为不相等的对象产生不相等的散列码。</li><li>HashMap有一项优化，将散列码缓存起来，如果散列码不匹配，则对象不相等。对于HashMap来说，没有覆盖hashCode的类的所有键都是不相等的。</li></ul></li></ol><p><strong>散列码的计算</strong></p><ol><li>简单的散列函数实现：<ul><li>hash=非零常数值，比如17。</li><li>boolean，f?1:0。</li><li>byte char short int，(int)f。</li><li>long，(int)(f^(f&gt;&gt;&gt;32))。</li><li>float，Float.floatToIntBits(f)。</li><li>double，Double.doubleToLongBits(f)，再从long-&gt;int。</li><li>Object，f==null?0:f.hashCode()。</li><li>Array，把每一个元素当做单独的字段。</li><li>循环计算，hash=31*hash+每一个字段的计算值。</li><li>return hash。</li><li>测试。</li></ul></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class Studnet&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public int hashCode()&#123;</span><br><span class="line">        int hash=17;</span><br><span class="line">        hash=31*hash+id.hashCode();</span><br><span class="line">        hash=31*hash+name.hashCode();</span><br><span class="line">        hash=31*hash+age;</span><br><span class="line">        return hash;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>散列码的计算必须排除equals比较计算中没有用到的任何域。之所以选择31奇素数，如果是偶数的话，乘法溢出会导致信息丢失，因为与2相乘等价于移位运算。而使用素数只是习惯使然，并且31可以很容易用移位和减法代替乘法，31*i==(i&lt;&lt;5)-i。</li><li>如果是不可变类，计算散列码的开销也比较大，可以考虑把散列码缓存在对象内部。如果类的大多数对象会被用做散列键，可以在实例的时候计算散列码，否则可以延迟初始化散列码。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//缓存，延迟初始化。</span><br><span class="line">private volatile int hashCode;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public int hashCode()&#123;</span><br><span class="line">    int hash=hashCode;</span><br><span class="line">    if(hash==0)&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    return hash;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>不要试图从散列码计算中排除掉一个对象的关键部分来提高性能。</li></ol><h2 id="始终要覆盖toString"><a href="#始终要覆盖toString" class="headerlink" title="始终要覆盖toString"></a>始终要覆盖toString</h2><ol><li>默认显示“类名@hashCode”。</li><li>如果指定了格式，最好提供一个相匹配的静态工厂或者构造器，以便对象和字符串之间来回转换。Java类库的很多值类都采用了这种做法，包括BigInteger和BigDecimal和绝大多数的基本类型包装类。</li><li>指定了格式的缺点是必须始终如一地坚持。</li></ol><h2 id="谨慎地覆盖clone"><a href="#谨慎地覆盖clone" class="headerlink" title="谨慎地覆盖clone"></a>谨慎地覆盖clone</h2>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>WebSocket</title>
      <link href="/2018/10/08/WebSocket/"/>
      <url>/2018/10/08/WebSocket/</url>
      
        <content type="html"><![CDATA[<h2 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a>WebSocket</h2><p>实现服务器和浏览器全双工通信。<br>使用ws和wss作为URL协议，默认使用80和443端口，HTTP状态码是101。</p><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ol><li>更强的实时性。服务器可以主动向客户端发送数据。</li><li>保持连接状态。创建连接后可以省略部分状态信息。 </li><li>较少的控制开销。协议控制的数据包头部较小。</li><li>更好的压缩效果。</li><li>更好的二进制支持。</li><li>可以支持扩展。</li></ol><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>推送技术所用的技术是轮询，Comet采用长连接实现轮询。</p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>Spring实战</title>
      <link href="/2018/10/08/Spring%E5%AE%9E%E6%88%98/"/>
      <url>/2018/10/08/Spring%E5%AE%9E%E6%88%98/</url>
      
        <content type="html"><![CDATA[<h1 id="Spring实战"><a href="#Spring实战" class="headerlink" title="Spring实战"></a>Spring实战</h1><h2 id="ApplicationContext：基于BeanFactory"><a href="#ApplicationContext：基于BeanFactory" class="headerlink" title="ApplicationContext：基于BeanFactory"></a>ApplicationContext：基于BeanFactory</h2><h2 id="bean的生命周期"><a href="#bean的生命周期" class="headerlink" title="bean的生命周期"></a>bean的生命周期</h2><ol><li>实例化</li><li>注入和Aware接口</li><li>BeanPostProcessor接口</li><li>InitializingBean接口或init-method方法</li><li>BeanPostProcessor接口</li><li>准备就绪和一直驻留ApplicationContext</li><li>DisposableBean接口或destroy-method方法</li></ol><h2 id="装配Bean"><a href="#装配Bean" class="headerlink" title="装配Bean"></a>装配Bean</h2><ul><li>隐式组件扫描和自动装配<ul><li>@Configuration</li><li>@ComponentScan @ComponentScan() @ComponentScan(basePackages=) @ComponentScan(basePackages={}) @ComponentScan(basePackageClasses={}) [类坐在的包]</li><li>@Component @Component()</li><li>@Autowired @Autowired(required=true) [构造器 Setter方法 字段（安全管理必须允许通过反射访问私有字段）]</li></ul></li><li>显式Java<ul><li>@Configuration</li><li>@Bean @Bean(name=)</li></ul></li><li>显式XML</li></ul><h3 id="JavaConfig引用其他配置"><a href="#JavaConfig引用其他配置" class="headerlink" title="JavaConfig引用其他配置"></a>JavaConfig引用其他配置</h3><ul><li>@Import(Class) @Import({})</li><li>@ImportResource(“xml”)</li></ul><h3 id="XML引用其他配置"><a href="#XML引用其他配置" class="headerlink" title="XML引用其他配置"></a>XML引用其他配置</h3><h2 id="高级装配"><a href="#高级装配" class="headerlink" title="高级装配"></a>高级装配</h2><ul><li>运行时值注入<ul><li>占位符 “${}”<ul><li>@PropertySource()</li><li>@Value(占位符) 必须配置PropertySourcesPlaceholderConfigurer</li></ul></li><li>SpEL Spring表达式语言 “#{}” #{3.14} #{‘hello’} #{true}<ol><li>使用bean的ID id.field id.method() ?.[可null]</li><li>调用方法和访问字段 T()[类]</li><li>算术^、关系、逻辑and or not |、条件？：[可判断null true没有表示不变]</li><li>正则表达式匹配 matches</li><li>集合操作[] .?[]过滤 .^[] .$[] .![]投影</li></ol></li></ul></li></ul><h2 id="junit测试"><a href="#junit测试" class="headerlink" title="junit测试"></a>junit测试</h2><ul><li>@RunWith(SpringJUnit4ClassRunner.class) 自动创建应用上下文</li><li>ContextConfiguration(classes=) </li></ul><h2 id="AOP-切面-切点-增强"><a href="#AOP-切面-切点-增强" class="headerlink" title="AOP 切面=切点+增强"></a>AOP 切面=切点+增强</h2><ul><li>EnableAspectJAutoProxy</li><li>@Aspect</li><li>@Pointcut</li></ul><h3 id="切点-选择方法-连接点"><a href="#切点-选择方法-连接点" class="headerlink" title="切点 选择方法(连接点)"></a>切点 选择方法(连接点)</h3><ul><li>execution(<em> pkg.class.method(..)) &amp;&amp; within(pkg.</em>) &amp;&amp; !bean(‘id’)</li><li>execution(* pkg.class.method(int)) &amp;&amp; args(增强参数)</li><li>指示器<ol><li>args()</li><li>@args()</li><li>execution()</li><li>this()</li><li>target()</li><li>@target()</li><li>within()</li><li>@within()</li><li>@annotation</li></ol></li></ul><h4 id="增强"><a href="#增强" class="headerlink" title="增强"></a>增强</h4><ul><li>@Before()</li><li>@After()</li><li>@AfterReturning()</li><li>@AfterThrowing()</li><li>@Around()<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Around()</span><br><span class="line">method(ProceedingJoinPoint jp)&#123;</span><br><span class="line">    ...</span><br><span class="line">    jp.proceed();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Spring标记</title>
      <link href="/2018/10/08/Spring%E6%A0%87%E8%AE%B0/"/>
      <url>/2018/10/08/Spring%E6%A0%87%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="The-IoC-container"><a href="#The-IoC-container" class="headerlink" title="The IoC container"></a>The IoC container</h1><h2 id="Bean-scopes"><a href="#Bean-scopes" class="headerlink" title="Bean scopes"></a>Bean scopes</h2><h3 id="RequestScope"><a href="#RequestScope" class="headerlink" title="@RequestScope"></a>@RequestScope</h3><ul><li>the @RequestScope annotation can be used to assign a component to the request scope.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@RequestScope</span><br><span class="line">@Component</span><br><span class="line">public class LoginAction &#123;</span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="SessionScope"><a href="#SessionScope" class="headerlink" title="@SessionScope"></a>@SessionScope</h3><ul><li>the @SessionScope annotation can be used to assign a component to the session scope.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@SessionScope</span><br><span class="line">@Component</span><br><span class="line">public class UserPreferences &#123;</span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="ApplicationScope"><a href="#ApplicationScope" class="headerlink" title="@ApplicationScope"></a>@ApplicationScope</h3><ul><li>the @ApplicationScope annotation can be used to assign a component to the application scope.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@ApplicationScope</span><br><span class="line">@Component</span><br><span class="line">public class AppPreferences &#123;</span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="Annotation-based-container-configuration"><a href="#Annotation-based-container-configuration" class="headerlink" title="Annotation-based container configuration"></a>Annotation-based container configuration</h2><h3 id="Requried"><a href="#Requried" class="headerlink" title="@Requried"></a>@Requried</h3><ul><li>The @Required annotation applies to bean property setter methods, as in the following example:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class SimpleMovieLister &#123;</span><br><span class="line"></span><br><span class="line">    private MovieFinder movieFinder;</span><br><span class="line"></span><br><span class="line">    @Required</span><br><span class="line">    public void setMovieFinder(MovieFinder movieFinder) &#123;</span><br><span class="line">        this.movieFinder = movieFinder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="Autowired"><a href="#Autowired" class="headerlink" title="@Autowired"></a>@Autowired</h3><ul><li><p>You can apply the @Autowired annotation to constructors:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class MovieRecommender &#123;</span><br><span class="line"></span><br><span class="line">    private final CustomerPreferenceDao customerPreferenceDao;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    public MovieRecommender(CustomerPreferenceDao customerPreferenceDao) &#123;</span><br><span class="line">        this.customerPreferenceDao = customerPreferenceDao;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>As expected, you can also apply the @Autowired annotation to “traditional” setter methods:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class SimpleMovieLister &#123;</span><br><span class="line"></span><br><span class="line">    private MovieFinder movieFinder;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    public void setMovieFinder(MovieFinder movieFinder) &#123;</span><br><span class="line">        this.movieFinder = movieFinder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>You can also apply the annotation to methods with arbitrary names and/or multiple arguments:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class MovieRecommender &#123;</span><br><span class="line"></span><br><span class="line">    private MovieCatalog movieCatalog;</span><br><span class="line"></span><br><span class="line">    private CustomerPreferenceDao customerPreferenceDao;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    public void prepare(MovieCatalog movieCatalog,</span><br><span class="line">            CustomerPreferenceDao customerPreferenceDao) &#123;</span><br><span class="line">        this.movieCatalog = movieCatalog;</span><br><span class="line">        this.customerPreferenceDao = customerPreferenceDao;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>You can apply @Autowired to fields as well and even mix it with constructors:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class MovieRecommender &#123;</span><br><span class="line"></span><br><span class="line">    private final CustomerPreferenceDao customerPreferenceDao;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private MovieCatalog movieCatalog;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    public MovieRecommender(CustomerPreferenceDao customerPreferenceDao) &#123;</span><br><span class="line">        this.customerPreferenceDao = customerPreferenceDao;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>It is also possible to provide all beans of a particular type from the ApplicationContext by adding the annotation to a field or method that expects an array of that type:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class MovieRecommender &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private MovieCatalog[] movieCatalogs;</span><br><span class="line"></span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>The same applies for typed collections:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class MovieRecommender &#123;</span><br><span class="line"></span><br><span class="line">    private Set&lt;MovieCatalog&gt; movieCatalogs;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    public void setMovieCatalogs(Set&lt;MovieCatalog&gt; movieCatalogs) &#123;</span><br><span class="line">        this.movieCatalogs = movieCatalogs;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Even typed Maps can be autowired as long as the expected key type is String. The Map values will contain all beans of the expected type, and the keys will contain the corresponding bean names:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class MovieRecommender &#123;</span><br><span class="line"></span><br><span class="line">    private Map&lt;String, MovieCatalog&gt; movieCatalogs;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    public void setMovieCatalogs(Map&lt;String, MovieCatalog&gt; movieCatalogs) &#123;</span><br><span class="line">        this.movieCatalogs = movieCatalogs;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>By default, the autowiring fails whenever zero candidate beans are available; the default behavior is to treat annotated methods, constructors, and fields as indicating required dependencies. This behavior can be changed as demonstrated below.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class SimpleMovieLister &#123;</span><br><span class="line"></span><br><span class="line">    private MovieFinder movieFinder;</span><br><span class="line"></span><br><span class="line">    @Autowired(required = false)</span><br><span class="line">    public void setMovieFinder(MovieFinder movieFinder) &#123;</span><br><span class="line">        this.movieFinder = movieFinder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Alternatively, you may express the non-required nature of a particular dependency through Java 8’s java.util.Optional:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class SimpleMovieLister &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    public void setMovieFinder(Optional&lt;MovieFinder&gt; movieFinder) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>As of Spring Framework 5.0, you may also use an @Nullable annotation (of any kind in any package, e.g. javax.annotation.Nullable from JSR-305):</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class SimpleMovieLister &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    public void setMovieFinder(@Nullable MovieFinder movieFinder) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>You can also use @Autowired for interfaces that are well-known resolvable dependencies: BeanFactory, ApplicationContext, Environment, ResourceLoader, ApplicationEventPublisher, and MessageSource. These interfaces and their extended interfaces, such as ConfigurableApplicationContext or ResourcePatternResolver, are automatically resolved, with no special setup necessary.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class MovieRecommender &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private ApplicationContext context;</span><br><span class="line"></span><br><span class="line">    public MovieRecommender() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Let’s assume we have the following configuration that defines firstMovieCatalog as the primary MovieCatalog.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class MovieConfiguration &#123;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    @Primary</span><br><span class="line">    public MovieCatalog firstMovieCatalog() &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public MovieCatalog secondMovieCatalog() &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>With such configuration, the following MovieRecommender will be autowired with the firstMovieCatalog.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class MovieRecommender &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private MovieCatalog movieCatalog;</span><br><span class="line"></span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="QUalifier"><a href="#QUalifier" class="headerlink" title="@QUalifier"></a>@QUalifier</h3><ul><li><p>@Primary is an effective way to use autowiring by type with several instances when one primary candidate can be determined. When more control over the selection process is required, Spring’s @Qualifier annotation can be used. You can associate qualifier values with specific arguments, narrowing the set of type matches so that a specific bean is chosen for each argument. In the simplest case, this can be a plain descriptive value:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class MovieRecommender &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    @Qualifier(&quot;main&quot;)</span><br><span class="line">    private MovieCatalog movieCatalog;</span><br><span class="line"></span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>The @Qualifier annotation can also be specified on individual constructor arguments or method parameters:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class MovieRecommender &#123;</span><br><span class="line"></span><br><span class="line">    private MovieCatalog movieCatalog;</span><br><span class="line"></span><br><span class="line">    private CustomerPreferenceDao customerPreferenceDao;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    public void prepare(@Qualifier(&quot;main&quot;)MovieCatalog movieCatalog,</span><br><span class="line">            CustomerPreferenceDao customerPreferenceDao) &#123;</span><br><span class="line">        this.movieCatalog = movieCatalog;</span><br><span class="line">        this.customerPreferenceDao = customerPreferenceDao;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>You can create your own custom qualifier annotations. Simply define an annotation and provide the @Qualifier annotation within your definition:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Target(&#123;ElementType.FIELD, ElementType.PARAMETER&#125;)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Qualifier</span><br><span class="line">public @interface Genre &#123;</span><br><span class="line"></span><br><span class="line">    String value();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Then you can provide the custom qualifier on autowired fields and parameters:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class MovieRecommender &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    @Genre(&quot;Action&quot;)</span><br><span class="line">    private MovieCatalog actionCatalog;</span><br><span class="line"></span><br><span class="line">    private MovieCatalog comedyCatalog;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    public void setComedyCatalog(@Genre(&quot;Comedy&quot;) MovieCatalog comedyCatalog) &#123;</span><br><span class="line">        this.comedyCatalog = comedyCatalog;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>In some cases, it may be sufficient to use an annotation without a value. This may be useful when the annotation serves a more generic purpose and can be applied across several different types of dependencies. For example, you may provide an offline catalog that would be searched when no Internet connection is available. First define the simple annotation:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Target(&#123;ElementType.FIELD, ElementType.PARAMETER&#125;)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Qualifier</span><br><span class="line">public @interface Offline &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Then add the annotation to the field or property to be autowired:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class MovieRecommender &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    @Offline</span><br><span class="line">    private MovieCatalog offlineCatalog;</span><br><span class="line"></span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>You can also define custom qualifier annotations that accept named attributes in addition to or instead of the simple value attribute. If multiple attribute values are then specified on a field or parameter to be autowired, a bean definition must match all such attribute values to be considered an autowire candidate. As an example, consider the following annotation definition:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Target(&#123;ElementType.FIELD, ElementType.PARAMETER&#125;)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Qualifier</span><br><span class="line">public @interface MovieQualifier &#123;</span><br><span class="line"></span><br><span class="line">    String genre();</span><br><span class="line"></span><br><span class="line">    Format format();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>In this case Format is an enum:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public enum Format &#123;</span><br><span class="line">    VHS, DVD, BLURAY</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>The fields to be autowired are annotated with the custom qualifier and include values for both attributes: genre and format.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class MovieRecommender &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    @MovieQualifier(format=Format.VHS, genre=&quot;Action&quot;)</span><br><span class="line">    private MovieCatalog actionVhsCatalog;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    @MovieQualifier(format=Format.VHS, genre=&quot;Comedy&quot;)</span><br><span class="line">    private MovieCatalog comedyVhsCatalog;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    @MovieQualifier(format=Format.DVD, genre=&quot;Action&quot;)</span><br><span class="line">    private MovieCatalog actionDvdCatalog;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    @MovieQualifier(format=Format.BLURAY, genre=&quot;Comedy&quot;)</span><br><span class="line">    private MovieCatalog comedyBluRayCatalog;</span><br><span class="line"></span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="Resource"><a href="#Resource" class="headerlink" title="@Resource"></a>@Resource</h3><ul><li><p>@Resource takes a name attribute, and by default Spring interprets that value as the bean name to be injected. In other words, it follows by-name semantics, as demonstrated in this example:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class SimpleMovieLister &#123;</span><br><span class="line"></span><br><span class="line">    private MovieFinder movieFinder;</span><br><span class="line"></span><br><span class="line">    @Resource(name=&quot;myMovieFinder&quot;)</span><br><span class="line">    public void setMovieFinder(MovieFinder movieFinder) &#123;</span><br><span class="line">        this.movieFinder = movieFinder;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>If no name is specified explicitly, the default name is derived from the field name or setter method. In case of a field, it takes the field name; in case of a setter method, it takes the bean property name. So the following example is going to have the bean with name “movieFinder” injected into its setter method:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class SimpleMovieLister &#123;</span><br><span class="line"></span><br><span class="line">    private MovieFinder movieFinder;</span><br><span class="line"></span><br><span class="line">    @Resource</span><br><span class="line">    public void setMovieFinder(MovieFinder movieFinder) &#123;</span><br><span class="line">        this.movieFinder = movieFinder;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Thus in the following example, the customerPreferenceDao field first looks for a bean named customerPreferenceDao, then falls back to a primary type match for the type CustomerPreferenceDao. The “context” field is injected based on the known resolvable dependency type ApplicationContext.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class MovieRecommender &#123;</span><br><span class="line"></span><br><span class="line">    @Resource</span><br><span class="line">    private CustomerPreferenceDao customerPreferenceDao;</span><br><span class="line"></span><br><span class="line">    @Resource</span><br><span class="line">    private ApplicationContext context;</span><br><span class="line"></span><br><span class="line">    public MovieRecommender() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="PostConstruct-and-PreDestroy"><a href="#PostConstruct-and-PreDestroy" class="headerlink" title="@PostConstruct and @PreDestroy"></a>@PostConstruct and @PreDestroy</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class CachingMovieLister &#123;</span><br><span class="line"></span><br><span class="line">    @PostConstruct</span><br><span class="line">    public void populateMovieCache() &#123;</span><br><span class="line">        // populates the movie cache upon initialization...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @PreDestroy</span><br><span class="line">    public void clearMovieCache() &#123;</span><br><span class="line">        // clears the movie cache upon destruction...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Classpath-scanning-and-managed-components"><a href="#Classpath-scanning-and-managed-components" class="headerlink" title="Classpath scanning and managed components"></a>Classpath scanning and managed components</h2><h3 id="Automatically-detecting-classes-and-registering-bean-definitions"><a href="#Automatically-detecting-classes-and-registering-bean-definitions" class="headerlink" title="Automatically detecting classes and registering bean definitions"></a>Automatically detecting classes and registering bean definitions</h3><ul><li><p>Spring can automatically detect stereotyped classes and register corresponding BeanDefinitions with the ApplicationContext. For example, the following two classes are eligible for such autodetection:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class SimpleMovieLister &#123;</span><br><span class="line"></span><br><span class="line">    private MovieFinder movieFinder;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    public SimpleMovieLister(MovieFinder movieFinder) &#123;</span><br><span class="line">        this.movieFinder = movieFinder;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Repository</span><br><span class="line">public class JpaMovieFinder implements MovieFinder &#123;</span><br><span class="line">    // implementation elided for clarity</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>To autodetect these classes and register the corresponding beans, you need to add @ComponentScan to your @Configuration class, where the basePackages attribute is a common parent package for the two classes. (Alternatively, you can specify a comma/semicolon/space-separated list that includes the parent package of each class.)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@ComponentScan(basePackages = &quot;org.example&quot;)</span><br><span class="line">public class AppConfig  &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>The following example shows the configuration ignoring all @Repository annotations and using “stub” repositories instead.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@ComponentScan(basePackages = &quot;org.example&quot;,</span><br><span class="line">        includeFilters = @Filter(type = FilterType.REGEX, pattern = &quot;.*Stub.*Repository&quot;),</span><br><span class="line">        excludeFilters = @Filter(Repository.class))</span><br><span class="line">public class AppConfig &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="Defining-bean-metadata-within-components"><a href="#Defining-bean-metadata-within-components" class="headerlink" title="Defining bean metadata within components"></a>Defining bean metadata within components</h3><ul><li><p>Spring components can also contribute bean definition metadata to the container. You do this with the same @Bean annotation used to define bean metadata within @Configuration annotated classes. Here is a simple example:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class FactoryMethodComponent &#123;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    @Qualifier(&quot;public&quot;)</span><br><span class="line">    public TestBean publicInstance() &#123;</span><br><span class="line">        return new TestBean(&quot;publicInstance&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void doWork() &#123;</span><br><span class="line">        // Component method implementation omitted</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Autowired fields and methods are supported as previously discussed, with additional support for autowiring of @Bean methods:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class FactoryMethodComponent &#123;</span><br><span class="line"></span><br><span class="line">    private static int i;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    @Qualifier(&quot;public&quot;)</span><br><span class="line">    public TestBean publicInstance() &#123;</span><br><span class="line">        return new TestBean(&quot;publicInstance&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // use of a custom qualifier and autowiring of method parameters</span><br><span class="line">    @Bean</span><br><span class="line">    protected TestBean protectedInstance(</span><br><span class="line">            @Qualifier(&quot;public&quot;) TestBean spouse,</span><br><span class="line">            @Value(&quot;#&#123;privateInstance.age&#125;&quot;) String country) &#123;</span><br><span class="line">        TestBean tb = new TestBean(&quot;protectedInstance&quot;, 1);</span><br><span class="line">        tb.setSpouse(spouse);</span><br><span class="line">        tb.setCountry(country);</span><br><span class="line">        return tb;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    private TestBean privateInstance() &#123;</span><br><span class="line">        return new TestBean(&quot;privateInstance&quot;, i++);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    @RequestScope</span><br><span class="line">    public TestBean requestScopedInstance() &#123;</span><br><span class="line">        return new TestBean(&quot;requestScopedInstance&quot;, 3);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class FactoryMethodComponent &#123;</span><br><span class="line"></span><br><span class="line">    @Bean @Scope(&quot;prototype&quot;)</span><br><span class="line">    public TestBean prototypeInstance(InjectionPoint injectionPoint) &#123;</span><br><span class="line">        return new TestBean(&quot;prototypeInstance for &quot; + injectionPoint.getMember());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Naming-autodetected-components"><a href="#Naming-autodetected-components" class="headerlink" title="Naming autodetected components"></a>Naming autodetected components</h3><ul><li>If such an annotation contains no name value or for any other detected component (such as those discovered by custom filters), the default bean name generator returns the uncapitalized non-qualified class name. For example, if the following component classes were detected, the names would be myMovieLister and movieFinderImpl:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Service(&quot;myMovieLister&quot;)</span><br><span class="line">public class SimpleMovieLister &#123;</span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br><span class="line">@Repository</span><br><span class="line">public class MovieFinderImpl implements MovieFinder &#123;</span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="Providing-a-scope-for-autodetected-components"><a href="#Providing-a-scope-for-autodetected-components" class="headerlink" title="Providing a scope for autodetected components"></a>Providing a scope for autodetected components</h3><ul><li>As with Spring-managed components in general, the default and most common scope for autodetected components is singleton. However, sometimes you need a different scope which can be specified via the @Scope annotation. Simply provide the name of the scope within the annotation:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Scope(&quot;prototype&quot;)</span><br><span class="line">@Repository</span><br><span class="line">public class MovieFinderImpl implements MovieFinder &#123;</span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="Java-based-contiainer-configuration"><a href="#Java-based-contiainer-configuration" class="headerlink" title="Java-based contiainer configuration"></a>Java-based contiainer configuration</h2><h3 id="Bean"><a href="#Bean" class="headerlink" title="@Bean"></a>@Bean</h3><ul><li><p>To declare a bean, simply annotate a method with the @Bean annotation. You use this method to register a bean definition within an ApplicationContext of the type specified as the method’s return value. By default, the bean name will be the same as the method name. The following is a simple example of a @Bean method declaration:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class AppConfig &#123;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public TransferServiceImpl transferService() &#123;</span><br><span class="line">        return new TransferServiceImpl();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>You may also declare your @Bean method with an interface (or base class) return type:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class AppConfig &#123;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public TransferService transferService() &#123;</span><br><span class="line">        return new TransferServiceImpl();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>A @Bean annotated method can have an arbitrary number of parameters describing the dependencies required to build that bean. For instance if our TransferService requires an AccountRepository we can materialize that dependency via a method parameter:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class AppConfig &#123;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public TransferService transferService(AccountRepository accountRepository) &#123;</span><br><span class="line">        return new TransferServiceImpl(accountRepository);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>The @Bean annotation supports specifying arbitrary initialization and destruction callback methods, much like Spring XML’s init-method and destroy-method attributes on the bean element:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public class Foo &#123;</span><br><span class="line"></span><br><span class="line">    public void init() &#123;</span><br><span class="line">        // initialization logic</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Bar &#123;</span><br><span class="line"></span><br><span class="line">    public void cleanup() &#123;</span><br><span class="line">        // destruction logic</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Configuration</span><br><span class="line">public class AppConfig &#123;</span><br><span class="line"></span><br><span class="line">    @Bean(initMethod = &quot;init&quot;)</span><br><span class="line">    public Foo foo() &#123;</span><br><span class="line">        return new Foo();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean(destroyMethod = &quot;cleanup&quot;)</span><br><span class="line">    public Bar bar() &#123;</span><br><span class="line">        return new Bar();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Of course, in the case of Foo above, it would be equally as valid to call the init() method directly during construction:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class AppConfig &#123;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public Foo foo() &#123;</span><br><span class="line">        Foo foo = new Foo();</span><br><span class="line">        foo.init();</span><br><span class="line">        return foo;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>The default scope is singleton, but you can override this with the @Scope annotation:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class MyConfiguration &#123;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    @Scope(&quot;prototype&quot;)</span><br><span class="line">    public Encryptor encryptor() &#123;</span><br><span class="line">        // ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>If you port the scoped proxy example from the XML reference documentation (see preceding link) to our @Bean using Java, it would look like the following:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// an HTTP Session-scoped bean exposed as a proxy</span><br><span class="line">@Bean</span><br><span class="line">@SessionScope</span><br><span class="line">public UserPreferences userPreferences() &#123;</span><br><span class="line">    return new UserPreferences();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Bean</span><br><span class="line">public Service userService() &#123;</span><br><span class="line">    UserService service = new SimpleUserService();</span><br><span class="line">    // a reference to the proxied userPreferences bean</span><br><span class="line">    service.setUserPreferences(userPreferences());</span><br><span class="line">    return service;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>By default, configuration classes use a @Bean method’s name as the name of the resulting bean. This functionality can be overridden, however, with the name attribute.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class AppConfig &#123;</span><br><span class="line"></span><br><span class="line">    @Bean(name = &quot;myFoo&quot;)</span><br><span class="line">    public Foo foo() &#123;</span><br><span class="line">        return new Foo();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>As discussed in Naming beans, it is sometimes desirable to give a single bean multiple names, otherwise known as bean aliasing. The name attribute of the @Bean annotation accepts a String array for this purpose.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class AppConfig &#123;</span><br><span class="line"></span><br><span class="line">    @Bean(name = &#123; &quot;dataSource&quot;, &quot;subsystemA-dataSource&quot;, &quot;subsystemB-dataSource&quot; &#125;)</span><br><span class="line">    public DataSource dataSource() &#123;</span><br><span class="line">        // instantiate, configure and return DataSource bean...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>To add a description to a @Bean the @Description annotation can be used:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class AppConfig &#123;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    @Description(&quot;Provides a basic example of a bean&quot;)</span><br><span class="line">    public Foo foo() &#123;</span><br><span class="line">        return new Foo();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="Using-the-Configuration-annotation"><a href="#Using-the-Configuration-annotation" class="headerlink" title="Using the @Configuration annotation"></a>Using the @Configuration annotation</h3><ul><li>When @Beans have dependencies on one another, expressing that dependency is as simple as having one bean method call another:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class AppConfig &#123;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public Foo foo() &#123;</span><br><span class="line">        return new Foo(bar());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public Bar bar() &#123;</span><br><span class="line">        return new Bar();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="Composing-Java-based-configurations"><a href="#Composing-Java-based-configurations" class="headerlink" title="Composing Java-based configurations"></a>Composing Java-based configurations</h3><ul><li><p>Much as the <import> element is used within Spring XML files to aid in modularizing configurations, the @Import annotation allows for loading @Bean definitions from another configuration class:</import></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class ConfigA &#123;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public A a() &#123;</span><br><span class="line">        return new A();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Configuration</span><br><span class="line">@Import(ConfigA.class)</span><br><span class="line">public class ConfigB &#123;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public B b() &#123;</span><br><span class="line">        return new B();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Fortunately, solving this problem is simple. As we already discussed, @Bean method can have an arbitrary number of parameters describing the bean dependencies. Let’s consider a more real-world scenario with several @Configuration classes, each depending on beans declared in the others:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class ServiceConfig &#123;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public TransferService transferService(AccountRepository accountRepository) &#123;</span><br><span class="line">        return new TransferServiceImpl(accountRepository);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Configuration</span><br><span class="line">public class RepositoryConfig &#123;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public AccountRepository accountRepository(DataSource dataSource) &#123;</span><br><span class="line">        return new JdbcAccountRepository(dataSource);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Configuration</span><br><span class="line">@Import(&#123;ServiceConfig.class, RepositoryConfig.class&#125;)</span><br><span class="line">public class SystemTestConfig &#123;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public DataSource dataSource() &#123;</span><br><span class="line">        // return new DataSource</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    ApplicationContext ctx = new AnnotationConfigApplicationContext(SystemTestConfig.class);</span><br><span class="line">    // everything wires up across configuration classes...</span><br><span class="line">    TransferService transferService = ctx.getBean(TransferService.class);</span><br><span class="line">    transferService.transfer(100.00, &quot;A123&quot;, &quot;C456&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>In cases where this ambiguity is not acceptable and you wish to have direct navigation from within your IDE from one @Configuration class to another, consider autowiring the configuration classes themselves:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class ServiceConfig &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private RepositoryConfig repositoryConfig;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public TransferService transferService() &#123;</span><br><span class="line">        // navigate &apos;through&apos; the config class to the @Bean method!</span><br><span class="line">        return new TransferServiceImpl(repositoryConfig.accountRepository());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Spring事务机制</title>
      <link href="/2018/10/08/Spring%E4%BA%8B%E5%8A%A1%E6%9C%BA%E5%88%B6/"/>
      <url>/2018/10/08/Spring%E4%BA%8B%E5%8A%A1%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="事务机制"><a href="#事务机制" class="headerlink" title="事务机制"></a>事务机制</h1><h2 id="事务的传播行为"><a href="#事务的传播行为" class="headerlink" title="事务的传播行为"></a>事务的传播行为</h2><ul><li>事务方法被另一个事务方法调用时，事务如何传播。</li></ul><ol><li>propagation_required</li></ol><ul><li>如果当前事务存在，加入当前事务。如果不存在事务，开启一个新的事务。</li></ul><ol start="2"><li>propagation_supports</li></ol><ul><li>如果当前事务存在，加入当前事务。如果不存在事务，非事务地执行。</li></ul><ol start="3"><li>propagation_mandatory<br>如果当前事务存在，加入当前事务。如果不存在事务，抛出异常。</li><li>propagation_requires_new</li></ol><ul><li>总是开启一个新的事务，并挂起任何存在的事务。内外层事务互相独立。</li><li>使用JtaTransactionManager作为事务管理器。</li></ul><ol start="5"><li>propagatrion_not_supported</li></ol><ul><li>总是非事务地执行，并挂起任何存在的事务。</li><li>使用JtaTransactionManager作为事务管理器。</li></ul><ol start="6"><li>propagation_never</li></ol><ul><li>总是非事务地执行。如果存在事务，抛出异常。</li></ul><ol start="7"><li>propagation_nested</li></ol><ul><li>类似propation_required。</li><li>内层事务依赖于外层事务。外层事务会回滚内层事务的动作。内层事务不会回滚外层事务。</li></ul><h2 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h2><ul><li>事务受其他并发事务影响的程度。</li></ul><ol><li>isolation_default</li></ol><ul><li>使用后端数据库默认的隔离级别。</li></ul><ol start="2"><li>isolation_read_uncommitted</li></ol><ul><li>允许读取未提交的数据。最低的隔离级别。</li><li>会导致脏读、不可重复读和幻读。</li></ul><ol start="3"><li>isolation_read_committed</li></ol><ul><li>允许读取并发事务已经提交的数据。</li><li>可以防止脏读，会导致不可重复读和幻读。</li></ul><ol start="4"><li>isolation_repeatable_read</li></ol><ul><li>会导致幻读。</li></ul><ol start="5"><li>isolation_serializable</li></ol><ul><li>最高也是最慢的隔离级别。通过锁定事务相关的数据库表来实现。</li></ul><h3 id="并发事务引起的问题"><a href="#并发事务引起的问题" class="headerlink" title="并发事务引起的问题"></a>并发事务引起的问题</h3><ol><li>脏读</li></ol><ul><li>还没提交的修改被其他事务读取了。事务自身没有原子性。</li></ul><ol start="2"><li>不可重复读</li></ol><ul><li>同一事务的多次相同查询得到不同的数据。事务之间没有原子性。</li></ul><ol start="3"><li>幻读</li></ol><ul><li><p>同一事务的多次相同查询记录数不同。事务之间没有原子性。</p></li><li><p>不可重复读和幻读的区别</p><ol><li>不可重复读重点是修改，幻读重点是增加和删除。</li><li>本质原因都是事务之间没有原子性。从控制的角度来看，修改只需锁住满足条件的记录，而增加和删除需要锁住满足条件及其相近的记录。</li></ol></li></ul><h2 id="只读事务"><a href="#只读事务" class="headerlink" title="只读事务"></a>只读事务</h2><ul><li>只读事务可以让数据库进行一些特定的优化。</li></ul><h2 id="事务超时"><a href="#事务超时" class="headerlink" title="事务超时"></a>事务超时</h2><ul><li>在特定事件内事务没有执行完毕就会自动回滚。</li></ul><h2 id="回滚规则"><a href="#回滚规则" class="headerlink" title="回滚规则"></a>回滚规则</h2><ul><li>默认情况下，事务遇到运行期异常才会回滚，而遇到受查型异常不会回滚。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Transactiona(propagation=Propagation.REQUIRES_NEW,isolation=Isolation.READ_COMMITTED,noRollbackFor=&#123;UserAccountException.class&#125;,readOnly=true, timeout=3)</span><br><span class="line">public void f()&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>高性能MySQL</title>
      <link href="/2018/10/08/%E9%AB%98%E6%80%A7%E8%83%BDMySQL/"/>
      <url>/2018/10/08/%E9%AB%98%E6%80%A7%E8%83%BDMySQL/</url>
      
        <content type="html"><![CDATA[<h1 id="MySQL架构"><a href="#MySQL架构" class="headerlink" title="MySQL架构"></a>MySQL架构</h1><h2 id="MySQL逻辑架构"><a href="#MySQL逻辑架构" class="headerlink" title="MySQL逻辑架构"></a>MySQL逻辑架构</h2><ol><li>连接/线程处理</li><li>查询缓存 解析器 优化器</li><li>存储引擎（InnoDB会解析外键定义）</li></ol><h2 id="并发控制"><a href="#并发控制" class="headerlink" title="并发控制"></a>并发控制</h2><ol><li>读写锁，读锁是共享锁，写锁是排他锁。</li><li>锁粒度<ol><li>表锁</li><li>行级锁</li></ol><ul><li>最大程度地支持并发处理，同时也带来了最大的锁开销。</li></ul></li></ol><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><ul><li><p>一组原子性地SQL查询</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">start transaction;</span><br><span class="line">...</span><br><span class="line">commit;</span><br></pre></td></tr></table></figure></li><li><p>事务处理系统具备ACID，A原子性，C一致性，I隔离性，D持久性。</p><ol><li>原子性</li></ol><ul><li>要么全部提交，要么全部回滚。</li></ul><ol start="2"><li>一致性</li></ol><ul><li>从一个一致性状态转换到另一个一致性状态。</li></ul><ol start="3"><li>隔离性</li></ol><ul><li>一个事务的修改在最终提交以前，对其他事务是不可见的。</li></ul><ol start="4"><li>持久性</li></ol><ul><li>一旦事务提交，所做的修改就会永久保存到数据库中。</li></ul></li></ul><h3 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set transaction isolation level read committed;</span><br><span class="line">set session transaction isolation level read committed;</span><br></pre></td></tr></table></figure><ol><li>read uncommitted 未提交读</li></ol><ul><li>事务中的修改，即使没有提交，对其他事务也都是可见的。</li><li>脏读：事务可以读取未提交的数据。</li><li>性能比其他级别不会好太多，却缺乏很多好处，很少使用。</li></ul><ol start="2"><li>read committed 提交读</li></ol><ul><li>事务只能看见已经提交的事务的修改。</li><li>大多数数据库的默认隔离级别，MySQL不是。</li><li>未提交事务就可以读取数据，导致一个事务内2次读取数据可能是不一样的，即保证了可见性却没有原子性。</li></ul><ol start="3"><li>repeatable read 可重复读</li></ol><ul><li>保证同一个事务中多次读取同样的记录的结果是一致的。</li><li>MySQL默认隔离级别。</li><li>不能解决幻读。</li></ul><ol start="4"><li>serializable 可串行化</li></ol><ul><li>最高的隔离级别，强制事务串行执行。</li><li>每一行数据都加锁，导致大量的超时和锁争用问题，很少使用。</li></ul><h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><ul><li>InnoDB处理死锁的方法，将持有最少行级排他锁的事务进行回滚。</li></ul><h3 id="事务日志"><a href="#事务日志" class="headerlink" title="事务日志"></a>事务日志</h3><ul><li>顺序I/O，速度快。</li></ul><h3 id="MySQL中的事务"><a href="#MySQL中的事务" class="headerlink" title="MySQL中的事务"></a>MySQL中的事务</h3><ul><li>事务型存储引擎：InnoDB和NDB Cluster。</li></ul><ol><li>自动提交</li></ol><ul><li>MySQL默认模式，autocommit=1。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">set autocommit=0;</span><br><span class="line">...</span><br><span class="line">commit;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>集合</title>
      <link href="/2018/10/08/%E9%9B%86%E5%90%88/"/>
      <url>/2018/10/08/%E9%9B%86%E5%90%88/</url>
      
        <content type="html"><![CDATA[<h1 id="CopyOnWriteArraySet"><a href="#CopyOnWriteArraySet" class="headerlink" title="CopyOnWriteArraySet"></a>CopyOnWriteArraySet</h1><ul><li>写操作需要复制整个数组，写开销大。</li><li>适合大小保持很小，读操作远多于写操作，需要在遍历期间防止线程间的冲突。</li><li>线程安全的。</li><li>迭代器不支持写操作。</li><li>迭代器速度快，不会和其他线程冲突。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>JavaScript事件绑定与方法调用</title>
      <link href="/2018/10/08/JavaScript%E4%BA%8B%E4%BB%B6%E7%BB%91%E5%AE%9A%E4%B8%8E%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8/"/>
      <url>/2018/10/08/JavaScript%E4%BA%8B%E4%BB%B6%E7%BB%91%E5%AE%9A%E4%B8%8E%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="事件绑定"><a href="#事件绑定" class="headerlink" title="事件绑定"></a>事件绑定</h1><ol><li><p>事件与对象绑定，而不是与引用绑定，如果引用的对象改变，事件也会随着改变。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;h1&gt;h1&lt;/h1&gt;</span><br><span class="line">&lt;button&gt;button&lt;/button&gt;</span><br><span class="line"></span><br><span class="line">$(&apos;button&apos;).click(function()&#123;</span><br><span class="line">    alert(&apos;hello&apos;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">//remove方法会删除对象，然后重新创建，事件丢失。</span><br><span class="line">$(&apos;button&apos;).remove();</span><br><span class="line">$(&apos;h1&apos;).after(&apos;&lt;button&gt;button&lt;/button&gt;&apos;);</span><br><span class="line"></span><br><span class="line">//detach方法不会删除对象，所以调用after方法后也不会重新创建，事件不会丢失。</span><br></pre></td></tr></table></figure></li><li><p>方法调用和对象引用绑定，即动态分派，在运行时动态确定调用的方法。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Redis面试</title>
      <link href="/2018/10/08/Redis%E9%9D%A2%E8%AF%95/"/>
      <url>/2018/10/08/Redis%E9%9D%A2%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<h1 id="Redis作用"><a href="#Redis作用" class="headerlink" title="Redis作用"></a>Redis作用</h1><ol><li>缓存</li><li>list保存最新的数据 队列系统 lpush ltrim</li><li>zset保存权重最大的数据 优先级队列系统 zadd zrevrange zrank</li><li>set数据排重</li><li>清除过期数据</li><li>计数</li><li>subscribe/publish构建实时消息系统</li></ol>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>MyBatis面试</title>
      <link href="/2018/10/08/MyBatis%E9%9D%A2%E8%AF%95/"/>
      <url>/2018/10/08/MyBatis%E9%9D%A2%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<h1 id="MyBatis如何防止注入？"><a href="#MyBatis如何防止注入？" class="headerlink" title="MyBatis如何防止注入？"></a>MyBatis如何防止注入？</h1><ul><li>#{}是预编译处理，${}是字符串替换。</li><li>#{}可以防止SQL注入。</li></ul><h1 id="类的属性和表的字段不一样？"><a href="#类的属性和表的字段不一样？" class="headerlink" title="类的属性和表的字段不一样？"></a>类的属性和表的字段不一样？</h1><ol><li>定义字段的别名为属性名。</li><li>映射属性名和字段名。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;resultMap id=&quot;&quot; type=&quot;&quot;&gt;</span><br><span class="line">    &lt;id property=&quot;&quot; column=&quot;&quot;/&gt;</span><br><span class="line">    &lt;result property=&quot;&quot; column=&quot;&quot;/&gt;</span><br><span class="line">&lt;/resultMap&gt;</span><br></pre></td></tr></table></figure></li></ol><h1 id="获取自动生成的键值？"><a href="#获取自动生成的键值？" class="headerlink" title="获取自动生成的键值？"></a>获取自动生成的键值？</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;insert id=&quot;&quot; parameterType=&quot;&quot;&gt;</span><br><span class="line">    &lt;selectKey keyProperty=&quot;id&quot; order=&quot;AFTER&quot; resultType=&quot;int&quot;&gt;</span><br><span class="line">        select last_insert_id()</span><br><span class="line">    &lt;/selectKey&gt;</span><br><span class="line">    insert into...</span><br><span class="line">&lt;/insert&gt;</span><br></pre></td></tr></table></figure><h1 id="在mapper中传递多个参数？"><a href="#在mapper中传递多个参数？" class="headerlink" title="在mapper中传递多个参数？"></a>在mapper中传递多个参数？</h1><ol><li>使用占位符<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;select id=&quot;&quot; resultMap=&quot;&quot;&gt;</span><br><span class="line">    select * from t where id=#&#123;0&#125; and name=#&#123;1&#125;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public T f(@param(&quot;id&quot;) Integer id,@param(&quot;name&quot;) String name);</span><br><span class="line"></span><br><span class="line">&lt;select id=&quot;f&quot; resultType=&quot;T&quot;&gt;</span><br><span class="line">    select * from t where id=#&#123;id&#125; and name=#&#123;name&#125;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure><ol start="2"><li>使用Map集合参数</li><li>使用Bean参数</li></ol><h1 id="动态标签？"><a href="#动态标签？" class="headerlink" title="动态标签？"></a>动态标签？</h1><ul><li>在Xml映射文件内，已标签的形式编写动态SQL，完成逻辑判断和动态拼接SQL的功能。</li><li>9种标签：<ol><li>trim</li><li>where</li><li>set</li><li>foreach</li><li>if</li><li>choose</li><li>when</li><li>otherwise</li><li>bind</li></ol></li><li>原理：使用OGNL（Object-Graph Navigation Languag）计算表达式，根据表达式的值动态拼接SQL。</li></ul><h1 id="MyBatis不同的Xml映射文件中，id重复？"><a href="#MyBatis不同的Xml映射文件中，id重复？" class="headerlink" title="MyBatis不同的Xml映射文件中，id重复？"></a>MyBatis不同的Xml映射文件中，id重复？</h1><ul><li>定位=namespace+id</li><li>如果有namespace可以重复，如果没有配置namespace会导致覆盖。</li></ul><h1 id="MyBatis是半自动的ORM映射工具？"><a href="#MyBatis是半自动的ORM映射工具？" class="headerlink" title="MyBatis是半自动的ORM映射工具？"></a>MyBatis是半自动的ORM映射工具？</h1><ul><li>Hibernate是全自动ORM映射工具，查询关联对象或关联集合对象时，可以根据对象关系模型直接获取。</li><li>MyBatis则需要手动编写SQL。</li></ul><h1 id="一个Xml映射文件，需要一个Dao接口对应？Dao接口的方法能重载吗？"><a href="#一个Xml映射文件，需要一个Dao接口对应？Dao接口的方法能重载吗？" class="headerlink" title="一个Xml映射文件，需要一个Dao接口对应？Dao接口的方法能重载吗？"></a>一个Xml映射文件，需要一个Dao接口对应？Dao接口的方法能重载吗？</h1><ul><li>Dao接口，即Mapper接口，接口的全限名就是namespace，接口的方法名就是id，接口的参数就是传递给SQL的参数。</li><li>Mapper接口没有实现类，当调用接口方法时，会定位一个MappedStatement。</li><li>Dao接口里的方法不能重载。</li><li>Dao接口的工作原理：JDK动态代理，MyBatis运行时会使用JDK动态代理为Dao接口生成代理proxy对象，代理对象proxy会拦截接口方法，转而执行MappedStatement所代表的SQL。</li></ul><h1 id="接口绑定的实现方式？"><a href="#接口绑定的实现方式？" class="headerlink" title="接口绑定的实现方式？"></a>接口绑定的实现方式？</h1><ol><li>注解绑定</li><li>Xml绑定</li></ol><h1 id="MyBatis是如何分页的？分页插件的原理是什么？"><a href="#MyBatis是如何分页的？分页插件的原理是什么？" class="headerlink" title="MyBatis是如何分页的？分页插件的原理是什么？"></a>MyBatis是如何分页的？分页插件的原理是什么？</h1><ul><li>MyBatis使用RowBounds对象进行分页，RowBounds是针对ResultSet执行的内存分页，而非物理分页。</li><li>可以用SQL实现物理分页，也可以使用分页插件完成物理分页。</li><li>分页插件的基本原理:插件的拦截方法内拦截待执行的SQL，然后重写SQL，添加物理分页语句和物理分页参数。</li></ul><h1 id="MyBatis插件运行原理？"><a href="#MyBatis插件运行原理？" class="headerlink" title="MyBatis插件运行原理？"></a>MyBatis插件运行原理？</h1><ul><li>MyBatis仅可以编写针对ParameterHandler、ResultSetHandler、StatementHandler和Executor这4种接口的插件，MyBatis使用JDK的动态代理，为需要拦截的接口生成代理对象以实现接口方法拦截功能。</li></ul><h1 id="MyBatis延迟加载的实现原理？"><a href="#MyBatis延迟加载的实现原理？" class="headerlink" title="MyBatis延迟加载的实现原理？"></a>MyBatis延迟加载的实现原理？</h1><ul><li>MyBatis仅支持association和collection关联集合对象的延迟加载。</li><li>原理：使用cglib创建目标对象的代理对象，当调用目标方法时，进入拦截器方法，如果当拦截器方法发现字段是null值，就会单独发送事先保存好的查询，然后保存到对象的字段中。</li></ul><h1 id="MyBatis的Executor执行器？"><a href="#MyBatis的Executor执行器？" class="headerlink" title="MyBatis的Executor执行器？"></a>MyBatis的Executor执行器？</h1><ul><li>SimpleExecutor、ReuseExecutor和BatchExecutor</li></ul><ol><li>SimpleExecutor：每次执行一次update或select，开启一个Statement对象，用完立刻关闭Statement对象。</li><li>ReuseExecutor：执行update或select，以SQL作为key查找Statement对象，存在直接使用，不存在则创建，不关闭Statement对象而是在Map&lt;String,Statement&gt;内重复使用。</li><li>BatchExecutor：执行update（JDBC批处理不支持select），将sql添加到批处理中，等待统一执行executeBatch()。</li></ol>]]></content>
      
      
      <categories>
          
          <category> MyBatis </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>JDK8新特性</title>
      <link href="/2018/10/07/JDK8%E6%96%B0%E7%89%B9%E6%80%A7/"/>
      <url>/2018/10/07/JDK8%E6%96%B0%E7%89%B9%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<h1 id="Java语言"><a href="#Java语言" class="headerlink" title="Java语言"></a>Java语言</h1><h2 id="Lambda表达式与Functional接口"><a href="#Lambda表达式与Functional接口" class="headerlink" title="Lambda表达式与Functional接口"></a>Lambda表达式与Functional接口</h2><ul><li>访问局部变量时，会将变量隐式转换成常量。</li><li>接口的静态方法和默认方法不影响函数式接口。</li><li>@<em>FunctionalInterface</em>。</li></ul><h2 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h2><ul><li>方法引用用来支持Lambda简写。</li><li>构造器引用<em>T::new</em>，构造器本质上静态方法。</li><li>静态方法引用<em>T::staticMethod</em>。</li><li>类的任意对象的方法引用<em>T::Method</em>，第一个参数是对象。</li><li>对象的方法引用<em>O::Method</em>。</li></ul><h2 id="接口的静态方法与默认方法"><a href="#接口的静态方法与默认方法" class="headerlink" title="接口的静态方法与默认方法"></a>接口的静态方法与默认方法</h2><ul><li>接口的字段是<em>public static final</em>,接口的方法是<em>public</em>。</li><li>接口的方法新增<em>static</em>与<em>default</em>。</li></ul><h2 id="类型推测机制"><a href="#类型推测机制" class="headerlink" title="类型推测机制"></a>类型推测机制</h2><ul><li>List<t> list=new List&lt;&gt;();</t></li></ul><h2 id="重复注解"><a href="#重复注解" class="headerlink" title="重复注解"></a>重复注解</h2><ul><li>@R<em>epeatable</em>。</li></ul><h2 id="注解类型"><a href="#注解类型" class="headerlink" title="注解类型"></a>注解类型</h2><ul><li>field、constructor、method、parameter、local_variable、package和type(类、接口和enum)。</li></ul><h1 id="Java编译器"><a href="#Java编译器" class="headerlink" title="Java编译器"></a>Java编译器</h1><h2 id="参数名字"><a href="#参数名字" class="headerlink" title="参数名字"></a>参数名字</h2><ul><li>参数名字保存在Java字节码中，<em>javac -parameters</em>。</li></ul><h2 id="Java类库"><a href="#Java类库" class="headerlink" title="Java类库"></a>Java类库</h2><h2 id="Stream"><a href="#Stream" class="headerlink" title="Stream"></a>Stream</h2><ul><li>集合函数式编程</li></ul><h2 id="并行数组"><a href="#并行数组" class="headerlink" title="并行数组"></a>并行数组</h2><ul><li>数组并行处理。</li></ul><h2 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h2><ul><li>ConcurrentHashMap。<ol><li><em>取消段segments</em>，采用transient volatile hashEntry保存数据，实现<em>对每一行数据进行加锁</em>代替原来的段加锁，减少并发冲突。</li><li>数据结构改为<em>数组+单向链表+红黑树</em>。</li></ol></li><li>ForkJoinPool支持共有资源池。</li><li>容量锁StampedLock，代替ReadWriteLock。</li><li>atomic增加：<ol><li>DoubleAccumulator</li><li>DoubleAdder</li><li>LongAccumulator</li><li>LongAdder</li></ol></li></ul><h2 id="Optional"><a href="#Optional" class="headerlink" title="Optional"></a>Optional</h2><h2 id="Date-Time-API"><a href="#Date-Time-API" class="headerlink" title="Date/Time API"></a>Date/Time API</h2><ol><li>Clock</li></ol><ul><li>替换System.currentTimeMillis()和TimeZone.getDefault()。</li></ul><ol start="2"><li>LocaleDate LocalTime LocalDateTime</li></ol><ul><li>无时区。</li></ul><ol start="3"><li>ZonedDateTIme</li><li>Duration</li></ol><ul><li>时间差</li></ul><h2 id="JS引擎"><a href="#JS引擎" class="headerlink" title="JS引擎"></a>JS引擎</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ScriptEngineManager manager = new ScriptEngineManager();</span><br><span class="line">ScriptEngine engine = manager.getEngineByName( &quot;JavaScript&quot; );</span><br><span class="line">engine.eval( &quot;function f() &#123; return 1; &#125;; f() + 1;&quot; );</span><br></pre></td></tr></table></figure><h2 id="Base64"><a href="#Base64" class="headerlink" title="Base64"></a>Base64</h2><ul><li>编码。</li></ul><h1 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h1><h2 id="元空间Metaspace代替永久代PermGen"><a href="#元空间Metaspace代替永久代PermGen" class="headerlink" title="元空间Metaspace代替永久代PermGen"></a>元空间Metaspace代替永久代PermGen</h2><ul><li>字符串和静态变量转移到Java堆。</li><li>元空间使用本地内存而不在JVM中，元空间受本地内存限制，可以用-XX:MetaspaceSize -XX:MaxMetaspaceSize限制。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JDK8 </tag>
            
        </tags>
      
    </entry>
    
  
  
    
    <entry>
      <title></title>
      <link href="/baidu_verify_ysuwxPEgQM.html"/>
      <url>/baidu_verify_ysuwxPEgQM.html</url>
      
        <content type="html"><![CDATA[ysuwxPEgQM]]></content>
      
    </entry>
    
    <entry>
      <title></title>
      <link href="/googlea5bf63acdc3dbd82.html"/>
      <url>/googlea5bf63acdc3dbd82.html</url>
      
        <content type="html"><![CDATA[google-site-verification: googlea5bf63acdc3dbd82.html]]></content>
      
    </entry>
    
    <entry>
      <title>categories</title>
      <link href="/categories/index.html"/>
      <url>/categories/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    <entry>
      <title>tags</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
  
</search>
