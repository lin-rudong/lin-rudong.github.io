---
title: Python核心编程(第3版)
date: 2019-03-23 23:33:42
tags:
categories: Python
---

# 正则表达式

## 简介/动机

主要有两种方法完成模式匹配,搜索即在字符串任意部分种搜索匹配的模式,而匹配是指判断一个字符串能否从起始处全部或者部分地匹配某个模式,搜索通过search()函数或方法来实现,而匹配通过调用match()函数或方法实现.

正则表达式描述一个可以识别各种字符串的模式,正则表达式的强大之处在于引入特殊字符来定义字符集,匹配子组和重复模式.

## 特殊符号和字符

|   表示法    | 描述                                                         |
| :---------: | :----------------------------------------------------------- |
|    符号     |                                                              |
| `re1 竖线或 re2` | 匹配正则表达式re1或者re2.                                    |
|     `.`     | 匹配任何字符,除了\n之外,Python正则表达式有一个编译标记\[S或者DOTALL\],该标记可以使点号能够匹配换行符. |
|     `^`     | 匹配字符串起始部分,等于`\A`.                                 |
|     `$`     | 匹配字符串终止部分,等于`\Z`.                                 |
|     `*`     | 匹配0次或者多次前面出现的正则表达式.                         |
|     `+`     | 匹配1次或者多次前面出现的正则表达式.                         |
|     `?`     | 匹配0次或者1次前面出现的正则表达式.                          |
|    `{n}`    | 匹配n次前面出现的正则表达式.                                 |
|   `{m,n}`   | 匹配m~n次前面出现的正则表达式.                               |
|   `[...]`   | 匹配来自字符集的任意单一字符.                                |
| `[..x-y..]` | 匹配x~y范围内中的任意单一字符.                               |
|  `[^...]`   | 匹配不在此字符集出现的任何一个字符.                          |
| `(*+?{})?`  | 用于匹配重复出现符号的非贪婪版本.                            |
|   `(...)`   | 匹配封闭的正则表达式,然后里另存为子组.                       |

特殊字符.

1. `\d`匹配任何十进制数字,与[0-9]一致,`\D`相反.
2. `\w`匹配任何字母数字字符,与[A-Za-z0-9]相同,`\W`相反.
3. `\s`匹配任何空格字符,与[\n\t\r\v\f]相同,`\S`相反.
4. `\b`匹配任何单词边界,`\B`相反.
5. `\n`匹配已保存的子组n.

扩展表示法

1. `(?iLmsux)`在正则表达式中嵌入一个或者多个特殊标记参数,或者通过函数/方法.
2. `(?:...)`表示一个匹配不用保存的分组.
3. `(?P\<name\>...)`像一个仅由name标识而不是数字ID标识的正则分组匹配.
4. `(?P=name)`在同一字符串中匹配由(?P<name)分组的之前文本.
5. `(?#...)`表示注释,所有内容都被忽略.
6. `(?=...)`匹配条件是如果...出现在之后的位置,而不是用输入字符串,称作正向前视断言.
7. `(?!...)`匹配条件是如果...不出现在之后的位置,而不是用输入字符串,称作负向前视断言.
8. `(?<=...)`匹配条件是如果...出现在之前的位置,而不使用输入字符串,称作正向后视断言.
9. `(?<!...)`匹配条件是如果...不出现在之前的位置,而不是用输入字符串,称作负向后视断言.
10. `(?(id/name)Y|N)`如果分组所提供的id或者name存在,就返回正则表达式的条件匹配Y,如果不存在,就返回N,N是可选项.

### 使用圆括号指定分组

对正则表达式进行分组的一个原因是对正则表达式进行分组可以在整个正则表达式中使用重复操作符,而不是一个单独的字符或者字符集.

使用圆括号进行分组的一个副作用就是,匹配模式的子字符串可以保存起来供后续使用,这些子组能够被同一次的匹配或者搜索重复调用,或者提取出来用于后续处理.

匹配子组那么重要的主要原因是很多时候除了进行匹配操作以外,我们还想要提取所匹配的模式.

### 扩展表示法

它们通常用于在判断匹配之前提供标记,实现一个前视或者后视匹配,或者条件检查,只有(?P\<name\>)表述一个分组匹配,所有其他的都没有创建一个分组.

1. `(?:\w+\.)*`以句点作为结尾的字符串,但是这些匹配不会保存下来供后续的使用和数据检索.
2. `(?#comment)`此处不做匹配,只是作为注释.
3. `(?=.com)`如果一个字符串后面跟着.com才做匹配操作,并不使用任何目标字符串.
4. `(?!.net)`如果一个字符串后面不是跟着.net才做匹配操作.
5. `(?<=800-)`如果字符串之前为800-才做匹配,同样,并不使用任何输入字符串.
6. `(?<!192\.168\.)`如果一个字符串之前不是192.168.才做匹配.
7. `(?(1)y|x)`如果一个匹配组1存在,就与y匹配,否则,就与x匹配.

## 正则表达式和Python语言

re模块允许许多个线程共享同一个已编译的正则表达式对象,也支持命名子组.

常见的正则表达式属性.

| 函数/方法                          | 描述                                                         |
| ---------------------------------- | ------------------------------------------------------------ |
| re模块函数                         |                                                              |
| `compile(pattern,flags=0)`         | 使用任何可选的标记来编译正则表达式的模式,然后返回一个正则表达式对象. |
| re模块函数和正则表达式对象的方法   |                                                              |
| `match(pattern,string,flags=0)`    | 尝试使用带有可选的标记的正则表达式的模式来匹配字符串,如果匹配成功,就返回匹配对象,如果失败,就返回None. |
| `search(pattern,string,flags=0)`   | 使用可选标记搜索字符串中第一次出现的正则表达式模式,如果匹配成功,则返回匹配对象,如果失败,则返回None. |
| `findall(pattern,string[,flags])`  | 查找字符串中所有非重复出现的正则表达式模式,并返回一个匹配列表. |
| `finditer(pattern,string[,flags])` | 和findall()函数相同,但返回的不是一个列表,而是一个迭代器.     |
| `split(pattern,string,max=0)`      | 根据正则表达式的模式分隔符,split函数将字符串分割为列表,然后返回成功匹配的列表,分割最多操作max次,默认分割所有匹配成功的位置. |
| `sub(pattern,repl,string,count=0)` | 使用repl替换所有正则表达式的模式在字符串中出现的位置,除非定义count,否则将替换所有出现的位置. |
| 常用的匹配对象方法                 |                                                              |
| `group(num=0)`                     | 返回整个匹配对象,或者编号为num的特定子组.                    |
| `groups(default=None)`             | 返回一个包含所有匹配子组的元组.                              |
| `groupdict(default=none)`          | 返回一个包含所有匹配的命名子组的字典,所有的子组名称作为字典的键. |
|                                    |                                                              |

### 使用compile()函数编译正则表达式

如果需要编译,就使用编译过的方法,如果不需要编译,就使用函数,幸运的是,不管使用函数还是方法,它们的名字都是相同的.

### 匹配对象以及group()和groups()方法

匹配对象是成功调用match()或者search()返回的对象,匹配对象有两个主要的方法,group()和groups().

如果没有子组的要求,groups()返回一个空元组,而group仍然返回整个匹配.

### 使用match()方法匹配字符串

```python
>>> m=re.match('foo','foo')
>>> if m is not None:
    	m.group()
'foo'  
```

只要模式从字符串的起始部分开始匹配,即使字符串比模式长,匹配也仍然能够成功.

### 使用search()在一个字符串中查找模式

```python
>>> m=re.match('foo','seafood')
>>> if m is not None:
		m.group()
'foo'
```

### 使用findall()和finditer()查找每一次出现的位置

findall()查询字符串中某个正则表达式模式全部的非重复出现情况,这与search()在执行字符串搜索时类似,但与match()和search()的不同之处在于,findall()总是返回一个列表.

```python
>>> re.findall('car', 'scary')
['car']

>>> re.findall('car', 'carry the barcardi to the car')
['car', 'car', 'car']
```

finditer()函数是与findall()函数类似但是更节省内存的变体,返回的是一个迭代器而不是列表,finditer在匹配对象中迭代.

对于一个成功的匹配,每个子组匹配是由findall()返回的结果列表中的单一元素,对于多个成功的匹配,每个子组匹配是返回一个元组的单一元素,而且每个元组(每个元组都对应一个成功的匹配)是结果列表中的元素.

```python
>>> s = 'This and that.'
>>> re.findall(r'(th\w+) and (th\w+)', s, re.I)
[('This', 'that')]

>>> s = 'This and that.'
>>> re.findall(r'(th\w+) and th\w+', s, re.I)
['This']

>>> re.finditer(r'(th\w+) and (th\w+)', s,re.I).next().groups()
('This', 'that')

>>> re.finditer(r'(th\w+) and (th\w+)', s,re.I).next().group(1)
'This'

>>> re.finditer(r'(th\w+) and (th\w+)', s,re.I).next().group(2)
'that'

>>> [g.groups() for g in re.finditer(r'(th\w+) and (th\w+)',s, re.I)]
[('This', 'that')]
```

### 使用sub()和subn()搜索与替换

subn()和sub()一样,但subn()还返回一个表示替换的总数,替换后的字符串和表示替换总数的数字一起作为一个拥有两个元素的元组返回.

```python
>>> re.sub('[ae]', 'X', 'abcdef')
'XbcdXf'

>>> re.subn('[ae]', 'X', 'abcdef')
('XbcdXf', 2)
```

\n在替换字符串中使用,能够取出匹配分组.

```python
>>> re.sub(r'(\d{1,2})/(\d{1,2})/(\d{2}|\d{4})',r'\2/\1/\3', '2/20/91')
'20/2/91'
```

### 在限定模式上使用split()分隔字符串

如果不想每次模式的出现都分割字符串,可以通过max参数设定.

如果给定分隔符不是使用特殊符号来匹配多重模式的正则表达式,那么re.split()与str.split()的工作方式相同.

```python
>>> re.split(':', 'str1:str2:str3')
['str1', 'str2', 'str3']
```

如果对字符串使用split方法已经足够好,就不需要引入额外复杂并且影响性能的正则表达式.

### 扩展符号

通过使用(?iLmsux)系统选项,用户可以直接在正则表达式里面指定一个或者多个标记,而不是通过compile()或者其他re模块函数.

```python
>>> re.findall(r'(?i)yes', 'yes? Yes. YES!!') 
['yes', 'Yes', 'YES']
```

i标记忽略大小写.

m标记能够在目标字符串中实现跨行搜索,而不必将整个字符串视为单个实体.

s标记表明点号能够用来表示\n符号.

x标记允许用户通过抑制在正则表达式中使用空白符(除了在字符类中或者在反斜线转义中)来创建更易读的正则表达式,此外,散列,注释和井号也可以用于一个注释的起始,只要它们不在一个用反斜线转义的字符类中.

```python
>>> re.search(r'''(?x)
	 \((\d{3})\) # 区号
	[ ]          # 空白符
	(\d{3})      # 前缀
	-            # 横线
	(\d{4})      # 终点数字
	''', '(800) 555-1212').groups()
('800', '555', '1212')
```

(?:...)通过使用该符号,可以对部分正则表达式进行分组,但是并不会保存该分组用于后续的检索或者应用.

```python
>>> re.findall(r'http://(?:\w+\.)*(\w+\.com)','http://google.com http://www.google.com http://code.google.com')
['google.com', 'google.com', 'google.com']

 re.search(r'\((?P<areacode>\d{3})\) (?P<prefix>\d{3})-(?:\d{4})','(800) 555-1212').groupdict()
{'areacode': '800', 'prefix': '555'}

 re.sub(r'\((?P<areacode>\d{3})\) (?P<prefix>\d{3})-(?:\d{4})','(\g<areacode>) \g<prefix>-xxxx', '(800) 555-1212')
'(800) 555-xxxx'
```

(?P\<name\>)通过使用一个名称标识符而不是使用从1开始的增量数字来保存匹配,可以使用一个类似\g\<name\>来检索它们.

使用(?P=name)可以在一个相同的正则表达式中重用模式.

```python
 bool(re.match(r'\((?P<areacode>\d{3})\) (?P<prefix>\d{3})-(?P<number>\d{4}) (?P=areacode)-(?P=prefix)-(?P=number)1(?P=areacode)(?P=prefix)(?P=number)','(800) 555-1212 800-555-1212 18005551212'))
True
```

可以使用(?=...)和(?!...)符号在目标字符串中实现一个前视匹配,而不必实际上使用这些字符串.

```python
>>> re.findall(r'\w+(?= van Rossum)',
 	'''
	Guido van Rossum
	Tim Peters
	Alex Martelli
	Just van Rossum
	Raymond Hettinger
	''')
['Guido', 'Just']

>>> bool(re.search(r'(?:(x)|y)(?(1)y|x)', 'xy'))
True
>>> bool(re.search(r'(?:(x)|y)(?(1)y|x)', 'xx'))
False
```

### 杂项

建议使用Python的原始字符串来避免使用特殊ASCII符号,如果不用原始字符串的话,需要用\\\\转义,和ASCII转义区分开来.

\w和\W字母数字字符集同时手re.L/LOCALE和re.U/UNICODE标记所影响.

